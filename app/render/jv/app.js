(function (electron) {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	var objectAssign$1 = /*#__PURE__*/Object.freeze({
		default: objectAssign,
		__moduleExports: objectAssign
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	var emptyObject = {};

	var emptyObject_1 = emptyObject;

	var emptyObject$1 = /*#__PURE__*/Object.freeze({
		default: emptyObject_1,
		__moduleExports: emptyObject_1
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	var emptyFunction_1 = emptyFunction;

	var emptyFunction$1 = /*#__PURE__*/Object.freeze({
		default: emptyFunction_1,
		__moduleExports: emptyFunction_1
	});

	var assign = ( objectAssign$1 && objectAssign ) || objectAssign$1;

	var require$$11 = ( emptyObject$1 && emptyObject_1 ) || emptyObject$1;

	var emptyFunction$2 = ( emptyFunction$1 && emptyFunction_1 ) || emptyFunction$1;

	var q="function"===typeof Symbol&&Symbol["for"],r=q?Symbol["for"]("react.element"):60103,t=q?Symbol["for"]("react.call"):60104,u=q?Symbol["for"]("react.return"):60105,v=q?Symbol["for"]("react.portal"):60106,w=q?Symbol["for"]("react.fragment"):60107,x="function"===typeof Symbol&&Symbol.iterator;
	function y(a){for(var b=arguments.length-1,e="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,c=0;c<b;c++)e+="\x26args[]\x3d"+encodeURIComponent(arguments[c+1]);b=Error(e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}
	var z={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function A(a,b,e){this.props=a;this.context=b;this.refs=require$$11;this.updater=e||z;}A.prototype.isReactComponent={};A.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?y("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState");};A.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};
	function B(a,b,e){this.props=a;this.context=b;this.refs=require$$11;this.updater=e||z;}function C(){}C.prototype=A.prototype;var D=B.prototype=new C;D.constructor=B;assign(D,A.prototype);D.isPureReactComponent=!0;function E(a,b,e){this.props=a;this.context=b;this.refs=require$$11;this.updater=e||z;}var F=E.prototype=new C;F.constructor=E;assign(F,A.prototype);F.unstable_isAsyncReactComponent=!0;F.render=function(){return this.props.children};var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};
	function J(a,b,e){var c,d={},g=null,k=null;if(null!=b)for(c in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)H.call(b,c)&&!I.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var h=Array(f),l=0;l<f;l++)h[l]=arguments[l+2];d.children=h;}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:r,type:a,key:g,ref:k,props:d,_owner:G.current}}function K(a){return"object"===typeof a&&null!==a&&a.$$typeof===r}
	function escape(a){var b={"\x3d":"\x3d0",":":"\x3d2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var L=/\/+/g,M=[];function N(a,b,e,c){if(M.length){var d=M.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function O(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>M.length&&M.push(a);}
	function P(a,b,e,c){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case r:case t:case u:case v:g=!0;}}if(g)return e(c,a,""===b?"."+Q(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+Q(d,k);g+=P(d,f,e,c);}else if(null===a||"undefined"===typeof a?f=null:(f=x&&a[x]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=
	f.call(a),k=0;!(d=a.next()).done;)d=d.value,f=b+Q(d,k++),g+=P(d,f,e,c);else"object"===d&&(e=""+a,y("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return g}function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function R(a,b){a.func.call(a.context,b,a.count++);}
	function S(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?T(a,c,e,emptyFunction$2.thatReturnsArgument):null!=a&&(K(a)&&(b=d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(L,"$\x26/")+"/")+e,a={$$typeof:r,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a));}function T(a,b,e,c,d){var g="";null!=e&&(g=(""+e).replace(L,"$\x26/")+"/");b=N(b,g,c,d);null==a||P(a,"",S,b);O(b);}
	var U={Children:{map:function(a,b,e){if(null==a)return a;var c=[];T(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=N(null,null,b,e);null==a||P(a,"",R,b);O(b);},count:function(a){return null==a?0:P(a,"",emptyFunction$2.thatReturnsNull,null)},toArray:function(a){var b=[];T(a,b,null,emptyFunction$2.thatReturnsArgument);return b},only:function(a){K(a)?void 0:y("143");return a}},Component:A,PureComponent:B,unstable_AsyncComponent:E,Fragment:w,createElement:J,cloneElement:function(a,b,e){var c=assign({},a.props),
	d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)H.call(b,h)&&!I.hasOwnProperty(h)&&(c[h]=void 0===b[h]&&void 0!==f?f[h]:b[h]);}var h=arguments.length-2;if(1===h)c.children=e;else if(1<h){f=Array(h);for(var l=0;l<h;l++)f[l]=arguments[l+2];c.children=f;}return{$$typeof:r,type:a.type,key:d,ref:g,props:c,_owner:k}},createFactory:function(a){var b=J.bind(null,a);b.type=a;return b},
	isValidElement:K,version:"16.2.0",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:G,assign:assign}},V=Object.freeze({default:U}),W=V&&U||V;var react_production_min=W["default"]?W["default"]:W;

	var react_production_min$1 = /*#__PURE__*/Object.freeze({
		default: react_production_min,
		__moduleExports: react_production_min
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	var invariant_1 = invariant;

	var invariant$1 = /*#__PURE__*/Object.freeze({
		default: invariant_1,
		__moduleExports: invariant_1
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	var ReactPropTypesSecret_1 = ReactPropTypesSecret;

	var ReactPropTypesSecret$1 = /*#__PURE__*/Object.freeze({
		default: ReactPropTypesSecret_1,
		__moduleExports: ReactPropTypesSecret_1
	});

	var require$$0 = ( invariant$1 && invariant_1 ) || invariant$1;

	var require$$2 = ( ReactPropTypesSecret$1 && ReactPropTypesSecret_1 ) || ReactPropTypesSecret$1;

	var react_development = createCommonjsModule(function (module) {
	});

	var require$$0$1 = ( react_production_min$1 && react_production_min ) || react_production_min$1;

	var react = createCommonjsModule(function (module) {

	{
	  module.exports = require$$0$1;
	}
	});
	var react_1 = react.React;
	var react_2 = react.Children;
	var react_3 = react.Component;
	var react_4 = react.createElement;

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {

	  canUseDOM: canUseDOM,

	  canUseWorkers: typeof Worker !== 'undefined',

	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

	  canUseViewport: canUseDOM && !!window.screen,

	  isInWorker: !canUseDOM // For now, this is true - might change in the future.

	};

	var ExecutionEnvironment_1 = ExecutionEnvironment;

	var ExecutionEnvironment$1 = /*#__PURE__*/Object.freeze({
		default: ExecutionEnvironment_1,
		__moduleExports: ExecutionEnvironment_1
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */



	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },

	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      return {
	        remove: emptyFunction$2
	      };
	    }
	  },

	  registerDefault: function registerDefault() {}
	};

	var EventListener_1 = EventListener;

	var EventListener$1 = /*#__PURE__*/Object.freeze({
		default: EventListener_1,
		__moduleExports: EventListener_1
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	/* eslint-disable fb-www/typeof-undefined */

	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 *
	 * @param {?DOMDocument} doc Defaults to current document.
	 * @return {?DOMElement}
	 */
	function getActiveElement(doc) /*?DOMElement*/{
	  doc = doc || (typeof document !== 'undefined' ? document : undefined);
	  if (typeof doc === 'undefined') {
	    return null;
	  }
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}

	var getActiveElement_1 = getActiveElement;

	var getActiveElement$1 = /*#__PURE__*/Object.freeze({
		default: getActiveElement_1,
		__moduleExports: getActiveElement_1
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 * 
	 */

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}

	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }

	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty$1.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }

	  return true;
	}

	var shallowEqual_1 = shallowEqual;

	var shallowEqual$1 = /*#__PURE__*/Object.freeze({
		default: shallowEqual_1,
		__moduleExports: shallowEqual_1
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  var doc = object ? object.ownerDocument || object : document;
	  var defaultView = doc.defaultView || window;
	  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}

	var isNode_1 = isNode;

	var isNode$1 = /*#__PURE__*/Object.freeze({
		default: isNode_1,
		__moduleExports: isNode_1
	});

	var isNode$2 = ( isNode$1 && isNode_1 ) || isNode$1;

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */



	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode$2(object) && object.nodeType == 3;
	}

	var isTextNode_1 = isTextNode;

	var isTextNode$1 = /*#__PURE__*/Object.freeze({
		default: isTextNode_1,
		__moduleExports: isTextNode_1
	});

	var isTextNode$2 = ( isTextNode$1 && isTextNode_1 ) || isTextNode$1;

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */



	/*eslint-disable no-bitwise */

	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode$2(outerNode)) {
	    return false;
	  } else if (isTextNode$2(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}

	var containsNode_1 = containsNode;

	var containsNode$1 = /*#__PURE__*/Object.freeze({
		default: containsNode_1,
		__moduleExports: containsNode_1
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	/**
	 * @param {DOMElement} node input/textarea to focus
	 */

	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}

	var focusNode_1 = focusNode;

	var focusNode$1 = /*#__PURE__*/Object.freeze({
		default: focusNode_1,
		__moduleExports: focusNode_1
	});

	var require$$3 = ( ExecutionEnvironment$1 && ExecutionEnvironment_1 ) || ExecutionEnvironment$1;

	var require$$6 = ( EventListener$1 && EventListener_1 ) || EventListener$1;

	var require$$7 = ( getActiveElement$1 && getActiveElement_1 ) || getActiveElement$1;

	var require$$8 = ( shallowEqual$1 && shallowEqual_1 ) || shallowEqual$1;

	var require$$9 = ( containsNode$1 && containsNode_1 ) || containsNode$1;

	var require$$10 = ( focusNode$1 && focusNode_1 ) || focusNode$1;

	function E$1(a){for(var b=arguments.length-1,c="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,d=0;d<b;d++)c+="\x26args[]\x3d"+encodeURIComponent(arguments[d+1]);b=Error(c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}react?void 0:E$1("227");
	var oa={children:!0,dangerouslySetInnerHTML:!0,defaultValue:!0,defaultChecked:!0,innerHTML:!0,suppressContentEditableWarning:!0,suppressHydrationWarning:!0,style:!0};function pa(a,b){return(a&b)===b}
	var ta={MUST_USE_PROPERTY:1,HAS_BOOLEAN_VALUE:4,HAS_NUMERIC_VALUE:8,HAS_POSITIVE_NUMERIC_VALUE:24,HAS_OVERLOADED_BOOLEAN_VALUE:32,HAS_STRING_BOOLEAN_VALUE:64,injectDOMPropertyConfig:function(a){var b=ta,c=a.Properties||{},d=a.DOMAttributeNamespaces||{},e=a.DOMAttributeNames||{};a=a.DOMMutationMethods||{};for(var f in c){ua.hasOwnProperty(f)?E$1("48",f):void 0;var g=f.toLowerCase(),h=c[f];g={attributeName:g,attributeNamespace:null,propertyName:f,mutationMethod:null,mustUseProperty:pa(h,b.MUST_USE_PROPERTY),
	hasBooleanValue:pa(h,b.HAS_BOOLEAN_VALUE),hasNumericValue:pa(h,b.HAS_NUMERIC_VALUE),hasPositiveNumericValue:pa(h,b.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:pa(h,b.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:pa(h,b.HAS_STRING_BOOLEAN_VALUE)};1>=g.hasBooleanValue+g.hasNumericValue+g.hasOverloadedBooleanValue?void 0:E$1("50",f);e.hasOwnProperty(f)&&(g.attributeName=e[f]);d.hasOwnProperty(f)&&(g.attributeNamespace=d[f]);a.hasOwnProperty(f)&&(g.mutationMethod=a[f]);ua[f]=g;}}},ua={};
	function va(a,b){if(oa.hasOwnProperty(a)||2<a.length&&("o"===a[0]||"O"===a[0])&&("n"===a[1]||"N"===a[1]))return!1;if(null===b)return!0;switch(typeof b){case "boolean":return oa.hasOwnProperty(a)?a=!0:(b=wa(a))?a=b.hasBooleanValue||b.hasStringBooleanValue||b.hasOverloadedBooleanValue:(a=a.toLowerCase().slice(0,5),a="data-"===a||"aria-"===a),a;case "undefined":case "number":case "string":case "object":return!0;default:return!1}}function wa(a){return ua.hasOwnProperty(a)?ua[a]:null}
	var xa=ta,ya=xa.MUST_USE_PROPERTY,K$1=xa.HAS_BOOLEAN_VALUE,za=xa.HAS_NUMERIC_VALUE,Aa=xa.HAS_POSITIVE_NUMERIC_VALUE,Ba=xa.HAS_OVERLOADED_BOOLEAN_VALUE,Ca=xa.HAS_STRING_BOOLEAN_VALUE,Da={Properties:{allowFullScreen:K$1,async:K$1,autoFocus:K$1,autoPlay:K$1,capture:Ba,checked:ya|K$1,cols:Aa,contentEditable:Ca,controls:K$1,"default":K$1,defer:K$1,disabled:K$1,download:Ba,draggable:Ca,formNoValidate:K$1,hidden:K$1,loop:K$1,multiple:ya|K$1,muted:ya|K$1,noValidate:K$1,open:K$1,playsInline:K$1,readOnly:K$1,required:K$1,reversed:K$1,rows:Aa,rowSpan:za,
	scoped:K$1,seamless:K$1,selected:ya|K$1,size:Aa,start:za,span:Aa,spellCheck:Ca,style:0,tabIndex:0,itemScope:K$1,acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,value:Ca},DOMAttributeNames:{acceptCharset:"accept-charset",className:"class",htmlFor:"for",httpEquiv:"http-equiv"},DOMMutationMethods:{value:function(a,b){if(null==b)return a.removeAttribute("value");"number"!==a.type||!1===a.hasAttribute("value")?a.setAttribute("value",""+b):a.validity&&!a.validity.badInput&&a.ownerDocument.activeElement!==a&&
	a.setAttribute("value",""+b);}}},Ea=xa.HAS_STRING_BOOLEAN_VALUE,M$1={xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace"},Ga={Properties:{autoReverse:Ea,externalResourcesRequired:Ea,preserveAlpha:Ea},DOMAttributeNames:{autoReverse:"autoReverse",externalResourcesRequired:"externalResourcesRequired",preserveAlpha:"preserveAlpha"},DOMAttributeNamespaces:{xlinkActuate:M$1.xlink,xlinkArcrole:M$1.xlink,xlinkHref:M$1.xlink,xlinkRole:M$1.xlink,xlinkShow:M$1.xlink,xlinkTitle:M$1.xlink,xlinkType:M$1.xlink,
	xmlBase:M$1.xml,xmlLang:M$1.xml,xmlSpace:M$1.xml}},Ha=/[\-\:]([a-z])/g;function Ia(a){return a[1].toUpperCase()}
	"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function(a){var b=a.replace(Ha,
	Ia);Ga.Properties[b]=0;Ga.DOMAttributeNames[b]=a;});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
	var P$1={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,injection:{injectErrorUtils:function(a){"function"!==typeof a.invokeGuardedCallback?E$1("197"):void 0;Ja=a.invokeGuardedCallback;}},invokeGuardedCallback:function(a,b,c,d,e,f,g,h,k){Ja.apply(P$1,arguments);},invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,k){P$1.invokeGuardedCallback.apply(this,arguments);if(P$1.hasCaughtError()){var q=P$1.clearCaughtError();P$1._hasRethrowError||(P$1._hasRethrowError=!0,P$1._rethrowError=
	q);}},rethrowCaughtError:function(){return Ka.apply(P$1,arguments)},hasCaughtError:function(){return P$1._hasCaughtError},clearCaughtError:function(){if(P$1._hasCaughtError){var a=P$1._caughtError;P$1._caughtError=null;P$1._hasCaughtError=!1;return a}E$1("198");}};function Ja(a,b,c,d,e,f,g,h,k){P$1._hasCaughtError=!1;P$1._caughtError=null;var q=Array.prototype.slice.call(arguments,3);try{b.apply(c,q);}catch(v){P$1._caughtError=v,P$1._hasCaughtError=!0;}}
	function Ka(){if(P$1._hasRethrowError){var a=P$1._rethrowError;P$1._rethrowError=null;P$1._hasRethrowError=!1;throw a;}}var La=null,Ma={};
	function Na(){if(La)for(var a in Ma){var b=Ma[a],c=La.indexOf(a);-1<c?void 0:E$1("96",a);if(!Oa[c]){b.extractEvents?void 0:E$1("97",a);Oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;Pa.hasOwnProperty(h)?E$1("99",h):void 0;Pa[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&Qa(k[e],g,h);e=!0;}else f.registrationName?(Qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:E$1("98",d,a);}}}}
	function Qa(a,b,c){Ra[a]?E$1("100",a):void 0;Ra[a]=b;Sa[a]=b.eventTypes[c].dependencies;}var Oa=[],Pa={},Ra={},Sa={};function Ta(a){La?E$1("101"):void 0;La=Array.prototype.slice.call(a);Na();}function Ua(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];Ma.hasOwnProperty(c)&&Ma[c]===d||(Ma[c]?E$1("102",c):void 0,Ma[c]=d,b=!0);}b&&Na();}
	var Va=Object.freeze({plugins:Oa,eventNameDispatchConfigs:Pa,registrationNameModules:Ra,registrationNameDependencies:Sa,possibleRegistrationNames:null,injectEventPluginOrder:Ta,injectEventPluginsByName:Ua}),Wa=null,Xa=null,Ya=null;function Za(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=Ya(d);P$1.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null;}
	function $a(a,b){null==b?E$1("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function ab(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a);}var bb=null;
	function cb(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)Za(a,b,c[e],d[e]);else c&&Za(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a);}}function db(a){return cb(a,!0)}function gb(a){return cb(a,!1)}var hb={injectEventPluginOrder:Ta,injectEventPluginsByName:Ua};
	function ib(a,b){var c=a.stateNode;if(!c)return null;var d=Wa(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1;}if(a)return null;c&&"function"!==typeof c?E$1("231",b,typeof c):void 0;
	return c}function jb(a,b,c,d){for(var e,f=0;f<Oa.length;f++){var g=Oa[f];g&&(g=g.extractEvents(a,b,c,d))&&(e=$a(e,g));}return e}function kb(a){a&&(bb=$a(bb,a));}function lb(a){var b=bb;bb=null;b&&(a?ab(b,db):ab(b,gb),bb?E$1("95"):void 0,P$1.rethrowCaughtError());}var mb=Object.freeze({injection:hb,getListener:ib,extractEvents:jb,enqueueEvents:kb,processEventQueue:lb}),nb=Math.random().toString(36).slice(2),Q$1="__reactInternalInstance$"+nb,ob="__reactEventHandlers$"+nb;
	function pb(a){if(a[Q$1])return a[Q$1];for(var b=[];!a[Q$1];)if(b.push(a),a.parentNode)a=a.parentNode;else return null;var c=void 0,d=a[Q$1];if(5===d.tag||6===d.tag)return d;for(;a&&(d=a[Q$1]);a=b.pop())c=d;return c}function qb(a){if(5===a.tag||6===a.tag)return a.stateNode;E$1("33");}function rb(a){return a[ob]||null}
	var sb=Object.freeze({precacheFiberNode:function(a,b){b[Q$1]=a;},getClosestInstanceFromNode:pb,getInstanceFromNode:function(a){a=a[Q$1];return!a||5!==a.tag&&6!==a.tag?null:a},getNodeFromInstance:qb,getFiberCurrentPropsFromNode:rb,updateFiberProps:function(a,b){a[ob]=b;}});function tb(a){do a=a["return"];while(a&&5!==a.tag);return a?a:null}function ub(a,b,c){for(var d=[];a;)d.push(a),a=tb(a);for(a=d.length;0<a--;)b(d[a],"captured",c);for(a=0;a<d.length;a++)b(d[a],"bubbled",c);}
	function vb(a,b,c){if(b=ib(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a);}function wb(a){a&&a.dispatchConfig.phasedRegistrationNames&&ub(a._targetInst,vb,a);}function xb(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?tb(b):null;ub(b,vb,a);}}
	function yb(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=ib(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a));}function zb(a){a&&a.dispatchConfig.registrationName&&yb(a._targetInst,null,a);}function Ab(a){ab(a,wb);}
	function Bb(a,b,c,d){if(c&&d)a:{var e=c;for(var f=d,g=0,h=e;h;h=tb(h))g++;h=0;for(var k=f;k;k=tb(k))h++;for(;0<g-h;)e=tb(e),g--;for(;0<h-g;)f=tb(f),h--;for(;g--;){if(e===f||e===f.alternate)break a;e=tb(e);f=tb(f);}e=null;}else e=null;f=e;for(e=[];c&&c!==f;){g=c.alternate;if(null!==g&&g===f)break;e.push(c);c=tb(c);}for(c=[];d&&d!==f;){g=d.alternate;if(null!==g&&g===f)break;c.push(d);d=tb(d);}for(d=0;d<e.length;d++)yb(e[d],"bubbled",a);for(a=c.length;0<a--;)yb(c[a],"captured",b);}
	var Cb=Object.freeze({accumulateTwoPhaseDispatches:Ab,accumulateTwoPhaseDispatchesSkipTarget:function(a){ab(a,xb);},accumulateEnterLeaveDispatches:Bb,accumulateDirectDispatches:function(a){ab(a,zb);}}),Db=null;function Eb(){!Db&&require$$3.canUseDOM&&(Db="textContent"in document.documentElement?"textContent":"innerText");return Db}var S$1={_root:null,_startText:null,_fallbackText:null};
	function Fb(){if(S$1._fallbackText)return S$1._fallbackText;var a,b=S$1._startText,c=b.length,d,e=Gb(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);S$1._fallbackText=e.slice(a,1<d?1-d:void 0);return S$1._fallbackText}function Gb(){return"value"in S$1._root?S$1._root.value:S$1._root[Eb()]}
	var Hb="dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),Ib={type:null,target:null,currentTarget:emptyFunction$2.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
	function T$1(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?emptyFunction$2.thatReturnsTrue:emptyFunction$2.thatReturnsFalse;this.isPropagationStopped=emptyFunction$2.thatReturnsFalse;return this}
	assign(T$1.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=emptyFunction$2.thatReturnsTrue);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=emptyFunction$2.thatReturnsTrue);},persist:function(){this.isPersistent=emptyFunction$2.thatReturnsTrue;},isPersistent:emptyFunction$2.thatReturnsFalse,
	destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<Hb.length;a++)this[Hb[a]]=null;}});T$1.Interface=Ib;T$1.augmentClass=function(a,b){function c(){}c.prototype=this.prototype;var d=new c;assign(d,a.prototype);a.prototype=d;a.prototype.constructor=a;a.Interface=assign({},this.Interface,b);a.augmentClass=this.augmentClass;Jb(a);};Jb(T$1);function Kb(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
	function Lb(a){a instanceof this?void 0:E$1("223");a.destructor();10>this.eventPool.length&&this.eventPool.push(a);}function Jb(a){a.eventPool=[];a.getPooled=Kb;a.release=Lb;}function Mb(a,b,c,d){return T$1.call(this,a,b,c,d)}T$1.augmentClass(Mb,{data:null});function Nb(a,b,c,d){return T$1.call(this,a,b,c,d)}T$1.augmentClass(Nb,{data:null});var Pb=[9,13,27,32],Vb=require$$3.canUseDOM&&"CompositionEvent"in window,Wb=null;require$$3.canUseDOM&&"documentMode"in document&&(Wb=document.documentMode);var Xb;
	if(Xb=require$$3.canUseDOM&&"TextEvent"in window&&!Wb){var Yb=window.opera;Xb=!("object"===typeof Yb&&"function"===typeof Yb.version&&12>=parseInt(Yb.version(),10));}
	var Zb=Xb,$b=require$$3.canUseDOM&&(!Vb||Wb&&8<Wb&&11>=Wb),ac=String.fromCharCode(32),bc={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["topCompositionEnd","topKeyPress","topTextInput","topPaste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
	captured:"onCompositionStartCapture"},dependencies:"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")}},cc=!1;
	function dc(a,b){switch(a){case "topKeyUp":return-1!==Pb.indexOf(b.keyCode);case "topKeyDown":return 229!==b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":return!0;default:return!1}}function ec(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var fc=!1;function gc(a,b){switch(a){case "topCompositionEnd":return ec(b);case "topKeyPress":if(32!==b.which)return null;cc=!0;return ac;case "topTextInput":return a=b.data,a===ac&&cc?null:a;default:return null}}
	function hc(a,b){if(fc)return"topCompositionEnd"===a||!Vb&&dc(a,b)?(a=Fb(),S$1._root=null,S$1._startText=null,S$1._fallbackText=null,fc=!1,a):null;switch(a){case "topPaste":return null;case "topKeyPress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "topCompositionEnd":return $b?null:b.data;default:return null}}
	var ic={eventTypes:bc,extractEvents:function(a,b,c,d){var e;if(Vb)b:{switch(a){case "topCompositionStart":var f=bc.compositionStart;break b;case "topCompositionEnd":f=bc.compositionEnd;break b;case "topCompositionUpdate":f=bc.compositionUpdate;break b}f=void 0;}else fc?dc(a,c)&&(f=bc.compositionEnd):"topKeyDown"===a&&229===c.keyCode&&(f=bc.compositionStart);f?($b&&(fc||f!==bc.compositionStart?f===bc.compositionEnd&&fc&&(e=Fb()):(S$1._root=d,S$1._startText=Gb(),fc=!0)),f=Mb.getPooled(f,b,c,d),e?f.data=
	e:(e=ec(c),null!==e&&(f.data=e)),Ab(f),e=f):e=null;(a=Zb?gc(a,c):hc(a,c))?(b=Nb.getPooled(bc.beforeInput,b,c,d),b.data=a,Ab(b)):b=null;return[e,b]}},jc=null,kc=null,lc=null;function mc(a){if(a=Xa(a)){jc&&"function"===typeof jc.restoreControlledState?void 0:E$1("194");var b=Wa(a.stateNode);jc.restoreControlledState(a.stateNode,a.type,b);}}var nc={injectFiberControlledHostComponent:function(a){jc=a;}};function oc(a){kc?lc?lc.push(a):lc=[a]:kc=a;}
	function pc(){if(kc){var a=kc,b=lc;lc=kc=null;mc(a);if(b)for(a=0;a<b.length;a++)mc(b[a]);}}var qc=Object.freeze({injection:nc,enqueueStateRestore:oc,restoreStateIfNeeded:pc});function rc(a,b){return a(b)}var sc=!1;function tc(a,b){if(sc)return rc(a,b);sc=!0;try{return rc(a,b)}finally{sc=!1,pc();}}var uc={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};
	function vc(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!uc[a.type]:"textarea"===b?!0:!1}function wc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var xc;require$$3.canUseDOM&&(xc=document.implementation&&document.implementation.hasFeature&&!0!==document.implementation.hasFeature("",""));
	function yc(a,b){if(!require$$3.canUseDOM||b&&!("addEventListener"in document))return!1;b="on"+a;var c=b in document;c||(c=document.createElement("div"),c.setAttribute(b,"return;"),c="function"===typeof c[b]);!c&&xc&&"wheel"===a&&(c=document.implementation.hasFeature("Events.wheel","3.0"));return c}function zc(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
	function Ac(a){var b=zc(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"function"===typeof c.get&&"function"===typeof c.set)return Object.defineProperty(a,b,{enumerable:c.enumerable,configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=""+a;c.set.call(this,a);}}),{getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=null;delete a[b];}}}
	function Bc(a){a._valueTracker||(a._valueTracker=Ac(a));}function Cc(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=zc(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Dc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")}};
	function Ec(a,b,c){a=T$1.getPooled(Dc.change,a,b,c);a.type="change";oc(c);Ab(a);return a}var Fc=null,Gc=null;function Hc(a){kb(a);lb(!1);}function Ic(a){var b=qb(a);if(Cc(b))return a}function Jc(a,b){if("topChange"===a)return b}var Kc=!1;require$$3.canUseDOM&&(Kc=yc("input")&&(!document.documentMode||9<document.documentMode));function Lc(){Fc&&(Fc.detachEvent("onpropertychange",Mc),Gc=Fc=null);}function Mc(a){"value"===a.propertyName&&Ic(Gc)&&(a=Ec(Gc,a,wc(a)),tc(Hc,a));}
	function Nc(a,b,c){"topFocus"===a?(Lc(),Fc=b,Gc=c,Fc.attachEvent("onpropertychange",Mc)):"topBlur"===a&&Lc();}function Oc(a){if("topSelectionChange"===a||"topKeyUp"===a||"topKeyDown"===a)return Ic(Gc)}function Pc(a,b){if("topClick"===a)return Ic(b)}function $c(a,b){if("topInput"===a||"topChange"===a)return Ic(b)}
	var ad={eventTypes:Dc,_isInputEventSupported:Kc,extractEvents:function(a,b,c,d){var e=b?qb(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Jc;else if(vc(e))if(Kc)g=$c;else{g=Oc;var h=Nc;}else f=e.nodeName,!f||"input"!==f.toLowerCase()||"checkbox"!==e.type&&"radio"!==e.type||(g=Pc);if(g&&(g=g(a,b)))return Ec(g,c,d);h&&h(a,e,b);"topBlur"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&"number"===e.type&&(a=""+e.value,e.getAttribute("value")!==
	a&&e.setAttribute("value",a));}};function bd(a,b,c,d){return T$1.call(this,a,b,c,d)}T$1.augmentClass(bd,{view:null,detail:null});var cd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function dd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=cd[a])?!!b[a]:!1}function ed(){return dd}function fd(a,b,c,d){return T$1.call(this,a,b,c,d)}
	bd.augmentClass(fd,{screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:ed,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)}});
	var gd={mouseEnter:{registrationName:"onMouseEnter",dependencies:["topMouseOut","topMouseOver"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["topMouseOut","topMouseOver"]}},hd={eventTypes:gd,extractEvents:function(a,b,c,d){if("topMouseOver"===a&&(c.relatedTarget||c.fromElement)||"topMouseOut"!==a&&"topMouseOver"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;"topMouseOut"===a?(a=b,b=(b=c.relatedTarget||c.toElement)?pb(b):null):a=null;if(a===
	b)return null;var f=null==a?e:qb(a);e=null==b?e:qb(b);var g=fd.getPooled(gd.mouseLeave,a,c,d);g.type="mouseleave";g.target=f;g.relatedTarget=e;c=fd.getPooled(gd.mouseEnter,b,c,d);c.type="mouseenter";c.target=e;c.relatedTarget=f;Bb(g,c,a,b);return[g,c]}},id=react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a){a=a.type;return"string"===typeof a?a:"function"===typeof a?a.displayName||a.name:null}
	function kd(a){var b=a;if(a.alternate)for(;b["return"];)b=b["return"];else{if(0!==(b.effectTag&2))return 1;for(;b["return"];)if(b=b["return"],0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function ld(a){return(a=a._reactInternalFiber)?2===kd(a):!1}function md(a){2!==kd(a)?E$1("188"):void 0;}
	function nd(a){var b=a.alternate;if(!b)return b=kd(a),3===b?E$1("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c["return"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return md(e),a;if(g===d)return md(e),b;g=g.sibling;}E$1("188");}if(c["return"]!==d["return"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling;}g?
	void 0:E$1("189");}}c.alternate!==d?E$1("190"):void 0;}3!==c.tag?E$1("188"):void 0;return c.stateNode.current===c?a:b}function od(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"];}b.sibling["return"]=b["return"];b=b.sibling;}}return null}
	function pd(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"];}b.sibling["return"]=b["return"];b=b.sibling;}}return null}var qd=[];
	function rd(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c;for(c=b;c["return"];)c=c["return"];c=3!==c.tag?null:c.stateNode.containerInfo;if(!c)break;a.ancestors.push(b);b=pb(c);}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],sd(a.topLevelType,b,a.nativeEvent,wc(a.nativeEvent));}var td=!0,sd=void 0;function ud(a){td=!!a;}function U$1(a,b,c){return c?require$$6.listen(c,b,vd.bind(null,a)):null}function wd(a,b,c){return c?require$$6.capture(c,b,vd.bind(null,a)):null}
	function vd(a,b){if(td){var c=wc(b);c=pb(c);null===c||"number"!==typeof c.tag||2===kd(c)||(c=null);if(qd.length){var d=qd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d;}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{tc(rd,a);}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>qd.length&&qd.push(a);}}}
	var xd=Object.freeze({get _enabled(){return td},get _handleTopLevel(){return sd},setHandleTopLevel:function(a){sd=a;},setEnabled:ud,isEnabled:function(){return td},trapBubbledEvent:U$1,trapCapturedEvent:wd,dispatchEvent:vd});function yd(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;c["ms"+a]="MS"+b;c["O"+a]="o"+b.toLowerCase();return c}
	var zd={animationend:yd("Animation","AnimationEnd"),animationiteration:yd("Animation","AnimationIteration"),animationstart:yd("Animation","AnimationStart"),transitionend:yd("Transition","TransitionEnd")},Ad={},Bd={};require$$3.canUseDOM&&(Bd=document.createElement("div").style,"AnimationEvent"in window||(delete zd.animationend.animation,delete zd.animationiteration.animation,delete zd.animationstart.animation),"TransitionEvent"in window||delete zd.transitionend.transition);
	function Cd(a){if(Ad[a])return Ad[a];if(!zd[a])return a;var b=zd[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Bd)return Ad[a]=b[c];return""}
	var Dd={topAbort:"abort",topAnimationEnd:Cd("animationend")||"animationend",topAnimationIteration:Cd("animationiteration")||"animationiteration",topAnimationStart:Cd("animationstart")||"animationstart",topBlur:"blur",topCancel:"cancel",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topChange:"change",topClick:"click",topClose:"close",topCompositionEnd:"compositionend",topCompositionStart:"compositionstart",topCompositionUpdate:"compositionupdate",topContextMenu:"contextmenu",topCopy:"copy",
	topCut:"cut",topDoubleClick:"dblclick",topDrag:"drag",topDragEnd:"dragend",topDragEnter:"dragenter",topDragExit:"dragexit",topDragLeave:"dragleave",topDragOver:"dragover",topDragStart:"dragstart",topDrop:"drop",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topFocus:"focus",topInput:"input",topKeyDown:"keydown",topKeyPress:"keypress",topKeyUp:"keyup",topLoadedData:"loadeddata",topLoad:"load",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",
	topMouseDown:"mousedown",topMouseMove:"mousemove",topMouseOut:"mouseout",topMouseOver:"mouseover",topMouseUp:"mouseup",topPaste:"paste",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topScroll:"scroll",topSeeked:"seeked",topSeeking:"seeking",topSelectionChange:"selectionchange",topStalled:"stalled",topSuspend:"suspend",topTextInput:"textInput",topTimeUpdate:"timeupdate",topToggle:"toggle",topTouchCancel:"touchcancel",topTouchEnd:"touchend",topTouchMove:"touchmove",
	topTouchStart:"touchstart",topTransitionEnd:Cd("transitionend")||"transitionend",topVolumeChange:"volumechange",topWaiting:"waiting",topWheel:"wheel"},Ed={},Fd=0,Gd="_reactListenersID"+(""+Math.random()).slice(2);function Hd(a){Object.prototype.hasOwnProperty.call(a,Gd)||(a[Gd]=Fd++,Ed[a[Gd]]={});return Ed[a[Gd]]}function Id(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
	function Jd(a,b){var c=Id(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=Id(c);}}function Kd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&"text"===a.type||"textarea"===b||"true"===a.contentEditable)}
	var Ld=require$$3.canUseDOM&&"documentMode"in document&&11>=document.documentMode,Md={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")}},Nd=null,Od=null,Pd=null,Qd=!1;
	function Rd(a,b){if(Qd||null==Nd||Nd!==require$$7())return null;var c=Nd;"selectionStart"in c&&Kd(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return Pd&&require$$8(Pd,c)?null:(Pd=c,a=T$1.getPooled(Md.select,Od,a,b),a.type="select",a.target=Nd,Ab(a),a)}
	var Sd={eventTypes:Md,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Hd(e);f=Sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0;}f=!e;}if(f)return null;e=b?qb(b):window;switch(a){case "topFocus":if(vc(e)||"true"===e.contentEditable)Nd=e,Od=b,Pd=null;break;case "topBlur":Pd=Od=Nd=null;break;case "topMouseDown":Qd=!0;break;case "topContextMenu":case "topMouseUp":return Qd=!1,Rd(c,d);case "topSelectionChange":if(Ld)break;
	case "topKeyDown":case "topKeyUp":return Rd(c,d)}return null}};function Td(a,b,c,d){return T$1.call(this,a,b,c,d)}T$1.augmentClass(Td,{animationName:null,elapsedTime:null,pseudoElement:null});function Ud(a,b,c,d){return T$1.call(this,a,b,c,d)}T$1.augmentClass(Ud,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}});function Vd(a,b,c,d){return T$1.call(this,a,b,c,d)}bd.augmentClass(Vd,{relatedTarget:null});
	function Wd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;return 32<=a||13===a?a:0}
	var Xd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Yd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
	116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};function Zd(a,b,c,d){return T$1.call(this,a,b,c,d)}
	bd.augmentClass(Zd,{key:function(a){if(a.key){var b=Xd[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Wd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Yd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:ed,charCode:function(a){return"keypress"===a.type?Wd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
	a.type?Wd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}});function $d(a,b,c,d){return T$1.call(this,a,b,c,d)}fd.augmentClass($d,{dataTransfer:null});function ae(a,b,c,d){return T$1.call(this,a,b,c,d)}bd.augmentClass(ae,{touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:ed});function be(a,b,c,d){return T$1.call(this,a,b,c,d)}T$1.augmentClass(be,{propertyName:null,elapsedTime:null,pseudoElement:null});
	function ce(a,b,c,d){return T$1.call(this,a,b,c,d)}fd.augmentClass(ce,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null});var de={},ee={};
	"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function(a){var b=a[0].toUpperCase()+
	a.slice(1),c="on"+b;b="top"+b;c={phasedRegistrationNames:{bubbled:c,captured:c+"Capture"},dependencies:[b]};de[a]=c;ee[b]=c;});
	var fe={eventTypes:de,extractEvents:function(a,b,c,d){var e=ee[a];if(!e)return null;switch(a){case "topKeyPress":if(0===Wd(c))return null;case "topKeyDown":case "topKeyUp":a=Zd;break;case "topBlur":case "topFocus":a=Vd;break;case "topClick":if(2===c.button)return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":a=fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":a=
	$d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":a=ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":a=Td;break;case "topTransitionEnd":a=be;break;case "topScroll":a=bd;break;case "topWheel":a=ce;break;case "topCopy":case "topCut":case "topPaste":a=Ud;break;default:a=T$1;}b=a.getPooled(e,b,c,d);Ab(b);return b}};sd=function(a,b,c,d){a=jb(a,b,c,d);kb(a);lb(!1);};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
	Wa=sb.getFiberCurrentPropsFromNode;Xa=sb.getInstanceFromNode;Ya=sb.getNodeFromInstance;hb.injectEventPluginsByName({SimpleEventPlugin:fe,EnterLeaveEventPlugin:hd,ChangeEventPlugin:ad,SelectEventPlugin:Sd,BeforeInputEventPlugin:ic});var ge=[],he=-1;function V$1(a){0>he||(a.current=ge[he],ge[he]=null,he--);}function W$1(a,b){he++;ge[he]=a.current;a.current=b;}var ie={current:require$$11},X={current:!1},je=require$$11;function ke(a){return le(a)?je:ie.current}
	function me(a,b){var c=a.type.contextTypes;if(!c)return require$$11;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function le(a){return 2===a.tag&&null!=a.type.childContextTypes}function ne(a){le(a)&&(V$1(X,a),V$1(ie,a));}
	function oe(a,b,c){null!=ie.cursor?E$1("168"):void 0;W$1(ie,b,a);W$1(X,c,a);}function pe(a,b){var c=a.stateNode,d=a.type.childContextTypes;if("function"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:E$1("108",jd(a)||"Unknown",e);return assign({},b,c)}function qe(a){if(!le(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||require$$11;je=ie.current;W$1(ie,b,a);W$1(X,X.current,a);return!0}
	function re(a,b){var c=a.stateNode;c?void 0:E$1("169");if(b){var d=pe(a,je);c.__reactInternalMemoizedMergedChildContext=d;V$1(X,a);V$1(ie,a);W$1(ie,d,a);}else V$1(X,a);W$1(X,b,a);}
	function Y(a,b,c){this.tag=a;this.key=b;this.stateNode=this.type=null;this.sibling=this.child=this["return"]=null;this.index=0;this.memoizedState=this.updateQueue=this.memoizedProps=this.pendingProps=this.ref=null;this.internalContextTag=c;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.expirationTime=0;this.alternate=null;}
	function se(a,b,c){var d=a.alternate;null===d?(d=new Y(a.tag,a.key,a.internalContextTag),d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.effectTag=0,d.nextEffect=null,d.firstEffect=null,d.lastEffect=null);d.expirationTime=c;d.pendingProps=b;d.child=a.child;d.memoizedProps=a.memoizedProps;d.memoizedState=a.memoizedState;d.updateQueue=a.updateQueue;d.sibling=a.sibling;d.index=a.index;d.ref=a.ref;return d}
	function te(a,b,c){var d=void 0,e=a.type,f=a.key;"function"===typeof e?(d=e.prototype&&e.prototype.isReactComponent?new Y(2,f,b):new Y(0,f,b),d.type=e,d.pendingProps=a.props):"string"===typeof e?(d=new Y(5,f,b),d.type=e,d.pendingProps=a.props):"object"===typeof e&&null!==e&&"number"===typeof e.tag?(d=e,d.pendingProps=a.props):E$1("130",null==e?e:typeof e,"");d.expirationTime=c;return d}function ue(a,b,c,d){b=new Y(10,d,b);b.pendingProps=a;b.expirationTime=c;return b}
	function ve(a,b,c){b=new Y(6,null,b);b.pendingProps=a;b.expirationTime=c;return b}function we(a,b,c){b=new Y(7,a.key,b);b.type=a.handler;b.pendingProps=a;b.expirationTime=c;return b}function xe(a,b,c){a=new Y(9,null,b);a.expirationTime=c;return a}function ye(a,b,c){b=new Y(4,a.key,b);b.pendingProps=a.children||[];b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}var ze=null,Ae=null;
	function Be(a){return function(b){try{return a(b)}catch(c){}}}function Ce(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);ze=Be(function(a){return b.onCommitFiberRoot(c,a)});Ae=Be(function(a){return b.onCommitFiberUnmount(c,a)});}catch(d){}return!0}function De(a){"function"===typeof ze&&ze(a);}function Ee(a){"function"===typeof Ae&&Ae(a);}
	function Fe(a){return{baseState:a,expirationTime:0,first:null,last:null,callbackList:null,hasForceUpdate:!1,isInitialized:!1}}function Ge(a,b){null===a.last?a.first=a.last=b:(a.last.next=b,a.last=b);if(0===a.expirationTime||a.expirationTime>b.expirationTime)a.expirationTime=b.expirationTime;}
	function He(a,b){var c=a.alternate,d=a.updateQueue;null===d&&(d=a.updateQueue=Fe(null));null!==c?(a=c.updateQueue,null===a&&(a=c.updateQueue=Fe(null))):a=null;a=a!==d?a:null;null===a?Ge(d,b):null===d.last||null===a.last?(Ge(d,b),Ge(a,b)):(Ge(d,b),a.last=b);}function Ie(a,b,c,d){a=a.partialState;return"function"===typeof a?a.call(b,c,d):a}
	function Je(a,b,c,d,e,f){null!==a&&a.updateQueue===c&&(c=b.updateQueue={baseState:c.baseState,expirationTime:c.expirationTime,first:c.first,last:c.last,isInitialized:c.isInitialized,callbackList:null,hasForceUpdate:!1});c.expirationTime=0;c.isInitialized?a=c.baseState:(a=c.baseState=b.memoizedState,c.isInitialized=!0);for(var g=!0,h=c.first,k=!1;null!==h;){var q=h.expirationTime;if(q>f){var v=c.expirationTime;if(0===v||v>q)c.expirationTime=q;k||(k=!0,c.baseState=a);}else{k||(c.first=h.next,null===
	c.first&&(c.last=null));if(h.isReplace)a=Ie(h,d,a,e),g=!0;else if(q=Ie(h,d,a,e))a=g?assign({},a,q):assign(a,q),g=!1;h.isForced&&(c.hasForceUpdate=!0);null!==h.callback&&(q=c.callbackList,null===q&&(q=c.callbackList=[]),q.push(h));}h=h.next;}null!==c.callbackList?b.effectTag|=32:null!==c.first||c.hasForceUpdate||(b.updateQueue=null);k||(c.baseState=a);return a}
	function Ke(a,b){var c=a.callbackList;if(null!==c)for(a.callbackList=null,a=0;a<c.length;a++){var d=c[a],e=d.callback;d.callback=null;"function"!==typeof e?E$1("191",e):void 0;e.call(b);}}
	function Le(a,b,c,d){function e(a,b){b.updater=f;a.stateNode=b;b._reactInternalFiber=a;}var f={isMounted:ld,enqueueSetState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!1,isForced:!1,nextCallback:null,next:null});a(c,g);},enqueueReplaceState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!0,isForced:!1,nextCallback:null,next:null});
	a(c,g);},enqueueForceUpdate:function(c,d){c=c._reactInternalFiber;d=void 0===d?null:d;var e=b(c);He(c,{expirationTime:e,partialState:null,callback:d,isReplace:!1,isForced:!0,nextCallback:null,next:null});a(c,e);}};return{adoptClassInstance:e,constructClassInstance:function(a,b){var c=a.type,d=ke(a),f=2===a.tag&&null!=a.type.contextTypes,g=f?me(a,d):require$$11;b=new c(b,g);e(a,b);f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=d,a.__reactInternalMemoizedMaskedChildContext=g);return b},mountClassInstance:function(a,
	b){var c=a.alternate,d=a.stateNode,e=d.state||null,g=a.pendingProps;g?void 0:E$1("158");var h=ke(a);d.props=g;d.state=a.memoizedState=e;d.refs=require$$11;d.context=me(a,h);null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent&&(a.internalContextTag|=1);"function"===typeof d.componentWillMount&&(e=d.state,d.componentWillMount(),e!==d.state&&f.enqueueReplaceState(d,d.state,null),e=a.updateQueue,null!==e&&(d.state=Je(c,a,e,d,g,b)));"function"===typeof d.componentDidMount&&(a.effectTag|=
	4);},updateClassInstance:function(a,b,e){var g=b.stateNode;g.props=b.memoizedProps;g.state=b.memoizedState;var h=b.memoizedProps,k=b.pendingProps;k||(k=h,null==k?E$1("159"):void 0);var u=g.context,z=ke(b);z=me(b,z);"function"!==typeof g.componentWillReceiveProps||h===k&&u===z||(u=g.state,g.componentWillReceiveProps(k,z),g.state!==u&&f.enqueueReplaceState(g,g.state,null));u=b.memoizedState;e=null!==b.updateQueue?Je(a,b,b.updateQueue,g,k,e):u;if(!(h!==k||u!==e||X.current||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return"function"!==
	typeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),!1;var G=k;if(null===h||null!==b.updateQueue&&b.updateQueue.hasForceUpdate)G=!0;else{var I=b.stateNode,L=b.type;G="function"===typeof I.shouldComponentUpdate?I.shouldComponentUpdate(G,e,z):L.prototype&&L.prototype.isPureReactComponent?!require$$8(h,G)||!require$$8(u,e):!0;}G?("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(k,e,z),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4)):("function"!==typeof g.componentDidUpdate||
	h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),c(b,k),d(b,e));g.props=k;g.state=e;g.context=z;return G}}}var Qe="function"===typeof Symbol&&Symbol["for"],Re=Qe?Symbol["for"]("react.element"):60103,Se=Qe?Symbol["for"]("react.call"):60104,Te=Qe?Symbol["for"]("react.return"):60105,Ue=Qe?Symbol["for"]("react.portal"):60106,Ve=Qe?Symbol["for"]("react.fragment"):60107,We="function"===typeof Symbol&&Symbol.iterator;
	function Xe(a){if(null===a||"undefined"===typeof a)return null;a=We&&a[We]||a["@@iterator"];return"function"===typeof a?a:null}var Ye=Array.isArray;
	function Ze(a,b){var c=b.ref;if(null!==c&&"function"!==typeof c){if(b._owner){b=b._owner;var d=void 0;b&&(2!==b.tag?E$1("110"):void 0,d=b.stateNode);d?void 0:E$1("147",c);var e=""+c;if(null!==a&&null!==a.ref&&a.ref._stringRef===e)return a.ref;a=function(a){var b=d.refs===require$$11?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a;};a._stringRef=e;return a}"string"!==typeof c?E$1("148"):void 0;b._owner?void 0:E$1("149",c);}return c}
	function $e(a,b){"textarea"!==a.type&&E$1("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"");}
	function af(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8;}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=se(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
	2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=ve(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function k(a,b,c,d){if(null!==b&&b.type===c.type)return d=e(b,c.props,d),d.ref=Ze(b,c),d["return"]=a,d;d=te(c,a.internalContextTag,d);d.ref=Ze(b,c);d["return"]=a;return d}function q(a,b,c,d){if(null===b||7!==b.tag)return b=we(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);
	b["return"]=a;return b}function v(a,b,c,d){if(null===b||9!==b.tag)return b=xe(c,a.internalContextTag,d),b.type=c.value,b["return"]=a,b;b=e(b,null,d);b.type=c.value;b["return"]=a;return b}function y(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=ye(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c.children||[],d);b["return"]=a;return b}function u(a,b,c,d,f){if(null===b||10!==b.tag)return b=ue(c,a.internalContextTag,
	d,f),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function z(a,b,c){if("string"===typeof b||"number"===typeof b)return b=ve(""+b,a.internalContextTag,c),b["return"]=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Re:if(b.type===Ve)return b=ue(b.props.children,a.internalContextTag,c,b.key),b["return"]=a,b;c=te(b,a.internalContextTag,c);c.ref=Ze(null,b);c["return"]=a;return c;case Se:return b=we(b,a.internalContextTag,c),b["return"]=a,b;case Te:return c=xe(b,a.internalContextTag,
	c),c.type=b.value,c["return"]=a,c;case Ue:return b=ye(b,a.internalContextTag,c),b["return"]=a,b}if(Ye(b)||Xe(b))return b=ue(b,a.internalContextTag,c,null),b["return"]=a,b;$e(a,b);}return null}function G(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Re:return c.key===e?c.type===Ve?u(a,b,c.props.children,d,e):k(a,b,c,d):null;case Se:return c.key===e?q(a,b,c,d):null;case Te:return null===
	e?v(a,b,c,d):null;case Ue:return c.key===e?y(a,b,c,d):null}if(Ye(c)||Xe(c))return null!==e?null:u(a,b,c,d,null);$e(a,c);}return null}function I(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Re:return a=a.get(null===d.key?c:d.key)||null,d.type===Ve?u(b,a,d.props.children,e,d.key):k(b,a,d,e);case Se:return a=a.get(null===d.key?c:d.key)||null,q(b,a,d,e);case Te:return a=a.get(c)||null,v(b,a,d,e);case Ue:return a=
	a.get(null===d.key?c:d.key)||null,y(b,a,d,e)}if(Ye(d)||Xe(d))return a=a.get(c)||null,u(b,a,d,e,null);$e(b,d);}return null}function L(e,g,m,A){for(var h=null,r=null,n=g,w=g=0,k=null;null!==n&&w<m.length;w++){n.index>w?(k=n,n=null):k=n.sibling;var x=G(e,n,m[w],A);if(null===x){null===n&&(n=k);break}a&&n&&null===x.alternate&&b(e,n);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x;n=k;}if(w===m.length)return c(e,n),h;if(null===n){for(;w<m.length;w++)if(n=z(e,m[w],A))g=f(n,g,w),null===r?h=n:r.sibling=n,r=n;return h}for(n=
	d(e,n);w<m.length;w++)if(k=I(n,e,w,m[w],A)){if(a&&null!==k.alternate)n["delete"](null===k.key?w:k.key);g=f(k,g,w);null===r?h=k:r.sibling=k;r=k;}a&&n.forEach(function(a){return b(e,a)});return h}function N(e,g,m,A){var h=Xe(m);"function"!==typeof h?E$1("150"):void 0;m=h.call(m);null==m?E$1("151"):void 0;for(var r=h=null,n=g,w=g=0,k=null,x=m.next();null!==n&&!x.done;w++,x=m.next()){n.index>w?(k=n,n=null):k=n.sibling;var J=G(e,n,x.value,A);if(null===J){n||(n=k);break}a&&n&&null===J.alternate&&b(e,n);g=f(J,
	g,w);null===r?h=J:r.sibling=J;r=J;n=k;}if(x.done)return c(e,n),h;if(null===n){for(;!x.done;w++,x=m.next())x=z(e,x.value,A),null!==x&&(g=f(x,g,w),null===r?h=x:r.sibling=x,r=x);return h}for(n=d(e,n);!x.done;w++,x=m.next())if(x=I(n,e,w,x.value,A),null!==x){if(a&&null!==x.alternate)n["delete"](null===x.key?w:x.key);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x;}a&&n.forEach(function(a){return b(e,a)});return h}return function(a,d,f,h){"object"===typeof f&&null!==f&&f.type===Ve&&null===f.key&&(f=f.props.children);
	var m="object"===typeof f&&null!==f;if(m)switch(f.$$typeof){case Re:a:{var r=f.key;for(m=d;null!==m;){if(m.key===r)if(10===m.tag?f.type===Ve:m.type===f.type){c(a,m.sibling);d=e(m,f.type===Ve?f.props.children:f.props,h);d.ref=Ze(m,f);d["return"]=a;a=d;break a}else{c(a,m);break}else b(a,m);m=m.sibling;}f.type===Ve?(d=ue(f.props.children,a.internalContextTag,h,f.key),d["return"]=a,a=d):(h=te(f,a.internalContextTag,h),h.ref=Ze(d,f),h["return"]=a,a=h);}return g(a);case Se:a:{for(m=f.key;null!==d;){if(d.key===
	m)if(7===d.tag){c(a,d.sibling);d=e(d,f,h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling;}d=we(f,a.internalContextTag,h);d["return"]=a;a=d;}return g(a);case Te:a:{if(null!==d)if(9===d.tag){c(a,d.sibling);d=e(d,null,h);d.type=f.value;d["return"]=a;a=d;break a}else c(a,d);d=xe(f,a.internalContextTag,h);d.type=f.value;d["return"]=a;a=d;}return g(a);case Ue:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===
	f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling;}d=ye(f,a.internalContextTag,h);d["return"]=a;a=d;}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h)):(c(a,d),d=ve(f,a.internalContextTag,h)),d["return"]=a,a=d,g(a);if(Ye(f))return L(a,d,f,h);if(Xe(f))return N(a,d,f,h);m&&$e(a,f);if("undefined"===typeof f)switch(a.tag){case 2:case 1:h=a.type,E$1("152",h.displayName||
	h.name||"Component");}return c(a,d)}}var bf=af(!0),cf=af(!1);
	function df(a,b,c,d,e){function f(a,b,c){var d=b.expirationTime;b.child=null===a?cf(b,null,c,d):bf(b,a.child,c,d);}function g(a,b){var c=b.ref;null===c||a&&a.ref===c||(b.effectTag|=128);}function h(a,b,c,d){g(a,b);if(!c)return d&&re(b,!1),q(a,b);c=b.stateNode;id.current=b;var e=c.render();b.effectTag|=1;f(a,b,e);b.memoizedState=c.state;b.memoizedProps=c.props;d&&re(b,!0);return b.child}function k(a){var b=a.stateNode;b.pendingContext?oe(a,b.pendingContext,b.pendingContext!==b.context):b.context&&oe(a,
	b.context,!1);I(a,b.containerInfo);}function q(a,b){null!==a&&b.child!==a.child?E$1("153"):void 0;if(null!==b.child){a=b.child;var c=se(a,a.pendingProps,a.expirationTime);b.child=c;for(c["return"]=b;null!==a.sibling;)a=a.sibling,c=c.sibling=se(a,a.pendingProps,a.expirationTime),c["return"]=b;c.sibling=null;}return b.child}function v(a,b){switch(b.tag){case 3:k(b);break;case 2:qe(b);break;case 4:I(b,b.stateNode.containerInfo);}return null}var y=a.shouldSetTextContent,u=a.useSyncScheduling,z=a.shouldDeprioritizeSubtree,
	G=b.pushHostContext,I=b.pushHostContainer,L=c.enterHydrationState,N=c.resetHydrationState,J=c.tryToClaimNextHydratableInstance;a=Le(d,e,function(a,b){a.memoizedProps=b;},function(a,b){a.memoizedState=b;});var w=a.adoptClassInstance,m=a.constructClassInstance,A=a.mountClassInstance,Ob=a.updateClassInstance;return{beginWork:function(a,b,c){if(0===b.expirationTime||b.expirationTime>c)return v(a,b);switch(b.tag){case 0:null!==a?E$1("155"):void 0;var d=b.type,e=b.pendingProps,r=ke(b);r=me(b,r);d=d(e,r);b.effectTag|=
	1;"object"===typeof d&&null!==d&&"function"===typeof d.render?(b.tag=2,e=qe(b),w(b,d),A(b,c),b=h(a,b,!0,e)):(b.tag=1,f(a,b,d),b.memoizedProps=e,b=b.child);return b;case 1:a:{e=b.type;c=b.pendingProps;d=b.memoizedProps;if(X.current)null===c&&(c=d);else if(null===c||d===c){b=q(a,b);break a}d=ke(b);d=me(b,d);e=e(c,d);b.effectTag|=1;f(a,b,e);b.memoizedProps=c;b=b.child;}return b;case 2:return e=qe(b),d=void 0,null===a?b.stateNode?E$1("153"):(m(b,b.pendingProps),A(b,c),d=!0):d=Ob(a,b,c),h(a,b,d,e);case 3:return k(b),
	e=b.updateQueue,null!==e?(d=b.memoizedState,e=Je(a,b,e,null,null,c),d===e?(N(),b=q(a,b)):(d=e.element,r=b.stateNode,(null===a||null===a.child)&&r.hydrate&&L(b)?(b.effectTag|=2,b.child=cf(b,null,d,c)):(N(),f(a,b,d)),b.memoizedState=e,b=b.child)):(N(),b=q(a,b)),b;case 5:G(b);null===a&&J(b);e=b.type;var n=b.memoizedProps;d=b.pendingProps;null===d&&(d=n,null===d?E$1("154"):void 0);r=null!==a?a.memoizedProps:null;X.current||null!==d&&n!==d?(n=d.children,y(e,d)?n=null:r&&y(e,r)&&(b.effectTag|=16),g(a,b),
	2147483647!==c&&!u&&z(e,d)?(b.expirationTime=2147483647,b=null):(f(a,b,n),b.memoizedProps=d,b=b.child)):b=q(a,b);return b;case 6:return null===a&&J(b),a=b.pendingProps,null===a&&(a=b.memoizedProps),b.memoizedProps=a,null;case 8:b.tag=7;case 7:e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null===e?E$1("154"):void 0);else if(null===e||b.memoizedProps===e)e=b.memoizedProps;d=e.children;b.stateNode=null===a?cf(b,b.stateNode,d,c):bf(b,b.stateNode,d,c);b.memoizedProps=e;return b.stateNode;
	case 9:return null;case 4:a:{I(b,b.stateNode.containerInfo);e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null==e?E$1("154"):void 0);else if(null===e||b.memoizedProps===e){b=q(a,b);break a}null===a?b.child=bf(b,null,e,c):f(a,b,e);b.memoizedProps=e;b=b.child;}return b;case 10:a:{c=b.pendingProps;if(X.current)null===c&&(c=b.memoizedProps);else if(null===c||b.memoizedProps===c){b=q(a,b);break a}f(a,b,c);b.memoizedProps=c;b=b.child;}return b;default:E$1("156");}},beginFailedWork:function(a,b,
	c){switch(b.tag){case 2:qe(b);break;case 3:k(b);break;default:E$1("157");}b.effectTag|=64;null===a?b.child=null:b.child!==a.child&&(b.child=a.child);if(0===b.expirationTime||b.expirationTime>c)return v(a,b);b.firstEffect=null;b.lastEffect=null;b.child=null===a?cf(b,null,null,c):bf(b,a.child,null,c);2===b.tag&&(a=b.stateNode,b.memoizedProps=a.props,b.memoizedState=a.state);return b.child}}}
	function ef(a,b,c){function d(a){a.effectTag|=4;}var e=a.createInstance,f=a.createTextInstance,g=a.appendInitialChild,h=a.finalizeInitialChildren,k=a.prepareUpdate,q=a.persistence,v=b.getRootHostContainer,y=b.popHostContext,u=b.getHostContext,z=b.popHostContainer,G=c.prepareToHydrateHostInstance,I=c.prepareToHydrateHostTextInstance,L=c.popHydrationState,N=void 0,J=void 0,w=void 0;a.mutation?(N=function(){},J=function(a,b,c){(b.updateQueue=c)&&d(b);},w=function(a,b,c,e){c!==e&&d(b);}):q?E$1("235"):E$1("236");
	return{completeWork:function(a,b,c){var m=b.pendingProps;if(null===m)m=b.memoizedProps;else if(2147483647!==b.expirationTime||2147483647===c)b.pendingProps=null;switch(b.tag){case 1:return null;case 2:return ne(b),null;case 3:z(b);V$1(X,b);V$1(ie,b);m=b.stateNode;m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null);if(null===a||null===a.child)L(b),b.effectTag&=-3;N(b);return null;case 5:y(b);c=v();var A=b.type;if(null!==a&&null!=b.stateNode){var p=a.memoizedProps,q=b.stateNode,x=u();q=
	k(q,A,p,m,c,x);J(a,b,q,A,p,m,c);a.ref!==b.ref&&(b.effectTag|=128);}else{if(!m)return null===b.stateNode?E$1("166"):void 0,null;a=u();if(L(b))G(b,c,a)&&d(b);else{a=e(A,m,c,a,b);a:for(p=b.child;null!==p;){if(5===p.tag||6===p.tag)g(a,p.stateNode);else if(4!==p.tag&&null!==p.child){p.child["return"]=p;p=p.child;continue}if(p===b)break;for(;null===p.sibling;){if(null===p["return"]||p["return"]===b)break a;p=p["return"];}p.sibling["return"]=p["return"];p=p.sibling;}h(a,A,m,c)&&d(b);b.stateNode=a;}null!==b.ref&&
	(b.effectTag|=128);}return null;case 6:if(a&&null!=b.stateNode)w(a,b,a.memoizedProps,m);else{if("string"!==typeof m)return null===b.stateNode?E$1("166"):void 0,null;a=v();c=u();L(b)?I(b)&&d(b):b.stateNode=f(m,a,c,b);}return null;case 7:(m=b.memoizedProps)?void 0:E$1("165");b.tag=8;A=[];a:for((p=b.stateNode)&&(p["return"]=b);null!==p;){if(5===p.tag||6===p.tag||4===p.tag)E$1("247");else if(9===p.tag)A.push(p.type);else if(null!==p.child){p.child["return"]=p;p=p.child;continue}for(;null===p.sibling;){if(null===
	p["return"]||p["return"]===b)break a;p=p["return"];}p.sibling["return"]=p["return"];p=p.sibling;}p=m.handler;m=p(m.props,A);b.child=bf(b,null!==a?a.child:null,m,c);return b.child;case 8:return b.tag=7,null;case 9:return null;case 10:return null;case 4:return z(b),N(b),null;case 0:E$1("167");default:E$1("156");}}}}
	function ff(a,b){function c(a){var c=a.ref;if(null!==c)try{c(null);}catch(A){b(a,A);}}function d(a){"function"===typeof Ee&&Ee(a);switch(a.tag){case 2:c(a);var d=a.stateNode;if("function"===typeof d.componentWillUnmount)try{d.props=a.memoizedProps,d.state=a.memoizedState,d.componentWillUnmount();}catch(A){b(a,A);}break;case 5:c(a);break;case 7:e(a.stateNode);break;case 4:k&&g(a);}}function e(a){for(var b=a;;)if(d(b),null===b.child||k&&4===b.tag){if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||
	b["return"]===a)return;b=b["return"];}b.sibling["return"]=b["return"];b=b.sibling;}else b.child["return"]=b,b=b.child;}function f(a){return 5===a.tag||3===a.tag||4===a.tag}function g(a){for(var b=a,c=!1,f=void 0,g=void 0;;){if(!c){c=b["return"];a:for(;;){null===c?E$1("160"):void 0;switch(c.tag){case 5:f=c.stateNode;g=!1;break a;case 3:f=c.stateNode.containerInfo;g=!0;break a;case 4:f=c.stateNode.containerInfo;g=!0;break a}c=c["return"];}c=!0;}if(5===b.tag||6===b.tag)e(b),g?J(f,b.stateNode):N(f,b.stateNode);
	else if(4===b.tag?f=b.stateNode.containerInfo:d(b),null!==b.child){b.child["return"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"];4===b.tag&&(c=!1);}b.sibling["return"]=b["return"];b=b.sibling;}}var h=a.getPublicInstance,k=a.mutation;a=a.persistence;k||(a?E$1("235"):E$1("236"));var q=k.commitMount,v=k.commitUpdate,y=k.resetTextContent,u=k.commitTextUpdate,z=k.appendChild,G=k.appendChildToContainer,I=k.insertBefore,L=k.insertInContainerBefore,
	N=k.removeChild,J=k.removeChildFromContainer;return{commitResetTextContent:function(a){y(a.stateNode);},commitPlacement:function(a){a:{for(var b=a["return"];null!==b;){if(f(b)){var c=b;break a}b=b["return"];}E$1("160");c=void 0;}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:E$1("161");}c.effectTag&16&&(y(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c["return"]||f(c["return"])){c=
	null;break a}c=c["return"];}c.sibling["return"]=c["return"];for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;else c.child["return"]=c,c=c.child;}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)c?d?L(b,e.stateNode,c):I(b,e.stateNode,c):d?G(b,e.stateNode):z(b,e.stateNode);else if(4!==e.tag&&null!==e.child){e.child["return"]=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e["return"]||e["return"]===
	a)return;e=e["return"];}e.sibling["return"]=e["return"];e=e.sibling;}},commitDeletion:function(a){g(a);a["return"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate["return"]=null);},commitWork:function(a,b){switch(b.tag){case 2:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&v(c,f,e,a,d,b);}break;case 6:null===b.stateNode?E$1("162"):void 0;c=b.memoizedProps;u(b.stateNode,null!==a?a.memoizedProps:
	c,c);break;case 3:break;default:E$1("163");}},commitLifeCycles:function(a,b){switch(b.tag){case 2:var c=b.stateNode;if(b.effectTag&4)if(null===a)c.props=b.memoizedProps,c.state=b.memoizedState,c.componentDidMount();else{var d=a.memoizedProps;a=a.memoizedState;c.props=b.memoizedProps;c.state=b.memoizedState;c.componentDidUpdate(d,a);}b=b.updateQueue;null!==b&&Ke(b,c);break;case 3:c=b.updateQueue;null!==c&&Ke(c,null!==b.child?b.child.stateNode:null);break;case 5:c=b.stateNode;null===a&&b.effectTag&4&&q(c,
	b.type,b.memoizedProps,b);break;case 6:break;case 4:break;default:E$1("163");}},commitAttachRef:function(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:b(h(c));break;default:b(c);}}},commitDetachRef:function(a){a=a.ref;null!==a&&a(null);}}}var gf={};
	function hf(a){function b(a){a===gf?E$1("174"):void 0;return a}var c=a.getChildHostContext,d=a.getRootHostContext,e={current:gf},f={current:gf},g={current:gf};return{getHostContext:function(){return b(e.current)},getRootHostContainer:function(){return b(g.current)},popHostContainer:function(a){V$1(e,a);V$1(f,a);V$1(g,a);},popHostContext:function(a){f.current===a&&(V$1(e,a),V$1(f,a));},pushHostContainer:function(a,b){W$1(g,b,a);b=d(b);W$1(f,a,a);W$1(e,b,a);},pushHostContext:function(a){var d=b(g.current),h=b(e.current);
	d=c(h,a.type,d);h!==d&&(W$1(f,a,a),W$1(e,d,a));},resetHostContainer:function(){e.current=gf;g.current=gf;}}}
	function jf(a){function b(a,b){var c=new Y(5,null,0);c.type="DELETED";c.stateNode=b;c["return"]=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c;}function c(a,b){switch(a.tag){case 5:return b=f(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=g(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;default:return!1}}function d(a){for(a=a["return"];null!==a&&5!==a.tag&&3!==a.tag;)a=a["return"];y=a;}var e=a.shouldSetTextContent;
	a=a.hydration;if(!a)return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){E$1("175");},prepareToHydrateHostTextInstance:function(){E$1("176");},popHydrationState:function(){return!1}};var f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,q=a.hydrateInstance,v=a.hydrateTextInstance,y=null,u=null,z=!1;return{enterHydrationState:function(a){u=
	k(a.stateNode.containerInfo);y=a;return z=!0},resetHydrationState:function(){u=y=null;z=!1;},tryToClaimNextHydratableInstance:function(a){if(z){var d=u;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=2;z=!1;y=a;return}b(y,u);}y=a;u=k(d);}else a.effectTag|=2,z=!1,y=a;}},prepareToHydrateHostInstance:function(a,b,c){b=q(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return v(a.stateNode,a.memoizedProps,a)},popHydrationState:function(a){if(a!==
	y)return!1;if(!z)return d(a),z=!0,!1;var c=a.type;if(5!==a.tag||"head"!==c&&"body"!==c&&!e(c,a.memoizedProps))for(c=u;c;)b(a,c),c=h(c);d(a);u=y?h(a.stateNode):null;return!0}}}
	function kf(a){function b(a){Qb=ja=!0;var b=a.stateNode;b.current===a?E$1("177"):void 0;b.isReadyForCommit=!1;id.current=null;if(1<a.effectTag)if(null!==a.lastEffect){a.lastEffect.nextEffect=a;var c=a.firstEffect;}else c=a;else c=a.firstEffect;yg();for(t=c;null!==t;){var d=!1,e=void 0;try{for(;null!==t;){var f=t.effectTag;f&16&&zg(t);if(f&128){var g=t.alternate;null!==g&&Ag(g);}switch(f&-242){case 2:Ne(t);t.effectTag&=-3;break;case 6:Ne(t);t.effectTag&=-3;Oe(t.alternate,t);break;case 4:Oe(t.alternate,
	t);break;case 8:Sc=!0,Bg(t),Sc=!1;}t=t.nextEffect;}}catch(Tc){d=!0,e=Tc;}d&&(null===t?E$1("178"):void 0,h(t,e),null!==t&&(t=t.nextEffect));}Cg();b.current=a;for(t=c;null!==t;){c=!1;d=void 0;try{for(;null!==t;){var k=t.effectTag;k&36&&Dg(t.alternate,t);k&128&&Eg(t);if(k&64)switch(e=t,f=void 0,null!==R&&(f=R.get(e),R["delete"](e),null==f&&null!==e.alternate&&(e=e.alternate,f=R.get(e),R["delete"](e))),null==f?E$1("184"):void 0,e.tag){case 2:e.stateNode.componentDidCatch(f.error,{componentStack:f.componentStack});
	break;case 3:null===ca&&(ca=f.error);break;default:E$1("157");}var Qc=t.nextEffect;t.nextEffect=null;t=Qc;}}catch(Tc){c=!0,d=Tc;}c&&(null===t?E$1("178"):void 0,h(t,d),null!==t&&(t=t.nextEffect));}ja=Qb=!1;"function"===typeof De&&De(a.stateNode);ha&&(ha.forEach(G),ha=null);null!==ca&&(a=ca,ca=null,Ob(a));b=b.current.expirationTime;0===b&&(qa=R=null);return b}function c(a){for(;;){var b=Fg(a.alternate,a,H),c=a["return"],d=a.sibling;var e=a;if(2147483647===H||2147483647!==e.expirationTime){if(2!==e.tag&&3!==
	e.tag)var f=0;else f=e.updateQueue,f=null===f?0:f.expirationTime;for(var g=e.child;null!==g;)0!==g.expirationTime&&(0===f||f>g.expirationTime)&&(f=g.expirationTime),g=g.sibling;e.expirationTime=f;}if(null!==b)return b;null!==c&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;
	if(null!==c)a=c;else{a.stateNode.isReadyForCommit=!0;break}}return null}function d(a){var b=rg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function e(a){var b=Gg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function f(a){if(null!==R){if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=k(F)?e(F):d(F);else for(;null!==F&&!A();)F=k(F)?e(F):d(F);}else if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=d(F);else for(;null!==F&&!A();)F=d(F);}function g(a,b){ja?E$1("243"):void 0;ja=!0;a.isReadyForCommit=
	!1;if(a!==ra||b!==H||null===F){for(;-1<he;)ge[he]=null,he--;je=require$$11;ie.current=require$$11;X.current=!1;x();ra=a;H=b;F=se(ra.current,null,b);}var c=!1,d=null;try{f(b);}catch(Rc){c=!0,d=Rc;}for(;c;){if(eb){ca=d;break}var g=F;if(null===g)eb=!0;else{var k=h(g,d);null===k?E$1("183"):void 0;if(!eb){try{c=k;d=b;for(k=c;null!==g;){switch(g.tag){case 2:ne(g);break;case 5:qg(g);break;case 3:p(g);break;case 4:p(g);}if(g===k||g.alternate===k)break;g=g["return"];}F=e(c);f(d);}catch(Rc){c=!0;d=Rc;continue}break}}}b=ca;eb=ja=!1;ca=
	null;null!==b&&Ob(b);return a.isReadyForCommit?a.current.alternate:null}function h(a,b){var c=id.current=null,d=!1,e=!1,f=null;if(3===a.tag)c=a,q(a)&&(eb=!0);else for(var g=a["return"];null!==g&&null===c;){2===g.tag?"function"===typeof g.stateNode.componentDidCatch&&(d=!0,f=jd(g),c=g,e=!0):3===g.tag&&(c=g);if(q(g)){if(Sc||null!==ha&&(ha.has(g)||null!==g.alternate&&ha.has(g.alternate)))return null;c=null;e=!1;}g=g["return"];}if(null!==c){null===qa&&(qa=new Set);qa.add(c);var h="";g=a;do{a:switch(g.tag){case 0:case 1:case 2:case 5:var k=
	g._debugOwner,Qc=g._debugSource;var m=jd(g);var n=null;k&&(n=jd(k));k=Qc;m="\n    in "+(m||"Unknown")+(k?" (at "+k.fileName.replace(/^.*[\\\/]/,"")+":"+k.lineNumber+")":n?" (created by "+n+")":"");break a;default:m="";}h+=m;g=g["return"];}while(g);g=h;a=jd(a);null===R&&(R=new Map);b={componentName:a,componentStack:g,error:b,errorBoundary:d?c.stateNode:null,errorBoundaryFound:d,errorBoundaryName:f,willRetry:e};R.set(c,b);try{var p=b.error;p&&p.suppressReactErrorLogging||console.error(p);}catch(Vc){Vc&&
	Vc.suppressReactErrorLogging||console.error(Vc);}Qb?(null===ha&&(ha=new Set),ha.add(c)):G(c);return c}null===ca&&(ca=b);return null}function k(a){return null!==R&&(R.has(a)||null!==a.alternate&&R.has(a.alternate))}function q(a){return null!==qa&&(qa.has(a)||null!==a.alternate&&qa.has(a.alternate))}function v(){return 20*(((I()+100)/20|0)+1)}function y(a){return 0!==ka?ka:ja?Qb?1:H:!Hg||a.internalContextTag&1?v():1}function u(a,b){return z(a,b,!1)}function z(a,b){for(;null!==a;){if(0===a.expirationTime||
	a.expirationTime>b)a.expirationTime=b;null!==a.alternate&&(0===a.alternate.expirationTime||a.alternate.expirationTime>b)&&(a.alternate.expirationTime=b);if(null===a["return"])if(3===a.tag){var c=a.stateNode;!ja&&c===ra&&b<H&&(F=ra=null,H=0);var d=c,e=b;Rb>Ig&&E$1("185");if(null===d.nextScheduledRoot)d.remainingExpirationTime=e,null===O?(sa=O=d,d.nextScheduledRoot=d):(O=O.nextScheduledRoot=d,O.nextScheduledRoot=sa);else{var f=d.remainingExpirationTime;if(0===f||e<f)d.remainingExpirationTime=e;}Fa||(la?
	Sb&&(ma=d,na=1,m(ma,na)):1===e?w(1,null):L(e));!ja&&c===ra&&b<H&&(F=ra=null,H=0);}else break;a=a["return"];}}function G(a){z(a,1,!0);}function I(){return Uc=((Wc()-Pe)/10|0)+2}function L(a){if(0!==Tb){if(a>Tb)return;Jg(Xc);}var b=Wc()-Pe;Tb=a;Xc=Kg(J,{timeout:10*(a-2)-b});}function N(){var a=0,b=null;if(null!==O)for(var c=O,d=sa;null!==d;){var e=d.remainingExpirationTime;if(0===e){null===c||null===O?E$1("244"):void 0;if(d===d.nextScheduledRoot){sa=O=d.nextScheduledRoot=null;break}else if(d===sa)sa=e=d.nextScheduledRoot,
	O.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===O){O=c;O.nextScheduledRoot=sa;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot;}else{if(0===a||e<a)a=e,b=d;if(d===O)break;c=d;d=d.nextScheduledRoot;}}c=ma;null!==c&&c===b?Rb++:Rb=0;ma=b;na=a;}function J(a){w(0,a);}function w(a,b){fb=b;for(N();null!==ma&&0!==na&&(0===a||na<=a)&&!Yc;)m(ma,na),N();null!==fb&&(Tb=0,Xc=-1);0!==na&&L(na);fb=null;Yc=!1;Rb=0;if(Ub)throw a=Zc,Zc=
	null,Ub=!1,a;}function m(a,c){Fa?E$1("245"):void 0;Fa=!0;if(c<=I()){var d=a.finishedWork;null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(a.remainingExpirationTime=b(d)));}else d=a.finishedWork,null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(A()?a.finishedWork=d:a.remainingExpirationTime=b(d)));Fa=!1;}function A(){return null===fb||fb.timeRemaining()>Lg?!1:Yc=!0}function Ob(a){null===ma?E$1("246"):
	void 0;ma.remainingExpirationTime=0;Ub||(Ub=!0,Zc=a);}var r=hf(a),n=jf(a),p=r.popHostContainer,qg=r.popHostContext,x=r.resetHostContainer,Me=df(a,r,n,u,y),rg=Me.beginWork,Gg=Me.beginFailedWork,Fg=ef(a,r,n).completeWork;r=ff(a,h);var zg=r.commitResetTextContent,Ne=r.commitPlacement,Bg=r.commitDeletion,Oe=r.commitWork,Dg=r.commitLifeCycles,Eg=r.commitAttachRef,Ag=r.commitDetachRef,Wc=a.now,Kg=a.scheduleDeferredCallback,Jg=a.cancelDeferredCallback,Hg=a.useSyncScheduling,yg=a.prepareForCommit,Cg=a.resetAfterCommit,
	Pe=Wc(),Uc=2,ka=0,ja=!1,F=null,ra=null,H=0,t=null,R=null,qa=null,ha=null,ca=null,eb=!1,Qb=!1,Sc=!1,sa=null,O=null,Tb=0,Xc=-1,Fa=!1,ma=null,na=0,Yc=!1,Ub=!1,Zc=null,fb=null,la=!1,Sb=!1,Ig=1E3,Rb=0,Lg=1;return{computeAsyncExpiration:v,computeExpirationForFiber:y,scheduleWork:u,batchedUpdates:function(a,b){var c=la;la=!0;try{return a(b)}finally{(la=c)||Fa||w(1,null);}},unbatchedUpdates:function(a){if(la&&!Sb){Sb=!0;try{return a()}finally{Sb=!1;}}return a()},flushSync:function(a){var b=la;la=!0;try{a:{var c=
	ka;ka=1;try{var d=a();break a}finally{ka=c;}d=void 0;}return d}finally{la=b,Fa?E$1("187"):void 0,w(1,null);}},deferredUpdates:function(a){var b=ka;ka=v();try{return a()}finally{ka=b;}}}}
	function lf(a){function b(a){a=od(a);return null===a?null:a.stateNode}var c=a.getPublicInstance;a=kf(a);var d=a.computeAsyncExpiration,e=a.computeExpirationForFiber,f=a.scheduleWork;return{createContainer:function(a,b){var c=new Y(3,null,0);a={current:c,containerInfo:a,pendingChildren:null,remainingExpirationTime:0,isReadyForCommit:!1,finishedWork:null,context:null,pendingContext:null,hydrate:b,nextScheduledRoot:null};return c.stateNode=a},updateContainer:function(a,b,c,q){var g=b.current;if(c){c=
	c._reactInternalFiber;var h;b:{2===kd(c)&&2===c.tag?void 0:E$1("170");for(h=c;3!==h.tag;){if(le(h)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}(h=h["return"])?void 0:E$1("171");}h=h.stateNode.context;}c=le(c)?pe(c,h):h;}else c=require$$11;null===b.context?b.context=c:b.pendingContext=c;b=q;b=void 0===b?null:b;q=null!=a&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent?d():e(g);He(g,{expirationTime:q,partialState:{element:a},callback:b,isReplace:!1,isForced:!1,
	nextCallback:null,next:null});f(g,q);},batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return c(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:b,findHostInstanceWithNoPortals:function(a){a=pd(a);return null===a?null:a.stateNode},injectIntoDevTools:function(a){var c=a.findFiberByHostInstance;return Ce(assign({},
	a,{findHostInstanceByFiber:function(a){return b(a)},findFiberByHostInstance:function(a){return c?c(a):null}}))}}}var mf=Object.freeze({default:lf}),nf=mf&&lf||mf,of=nf["default"]?nf["default"]:nf;function pf(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Ue,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}var qf="object"===typeof performance&&"function"===typeof performance.now,rf=void 0;rf=qf?function(){return performance.now()}:function(){return Date.now()};
	var sf=void 0,tf=void 0;
	if(require$$3.canUseDOM)if("function"!==typeof requestIdleCallback||"function"!==typeof cancelIdleCallback){var uf=null,vf=!1,wf=-1,xf=!1,yf=0,zf=33,Af=33,Bf;Bf=qf?{didTimeout:!1,timeRemaining:function(){var a=yf-performance.now();return 0<a?a:0}}:{didTimeout:!1,timeRemaining:function(){var a=yf-Date.now();return 0<a?a:0}};var Cf="__reactIdleCallback$"+Math.random().toString(36).slice(2);window.addEventListener("message",function(a){if(a.source===window&&a.data===Cf){vf=!1;a=rf();if(0>=yf-a)if(-1!==wf&&wf<=
	a)Bf.didTimeout=!0;else{xf||(xf=!0,requestAnimationFrame(Df));return}else Bf.didTimeout=!1;wf=-1;a=uf;uf=null;null!==a&&a(Bf);}},!1);var Df=function(a){xf=!1;var b=a-yf+Af;b<Af&&zf<Af?(8>b&&(b=8),Af=b<zf?zf:b):zf=b;yf=a+Af;vf||(vf=!0,window.postMessage(Cf,"*"));};sf=function(a,b){uf=a;null!=b&&"number"===typeof b.timeout&&(wf=rf()+b.timeout);xf||(xf=!0,requestAnimationFrame(Df));return 0};tf=function(){uf=null;vf=!1;wf=-1;};}else sf=window.requestIdleCallback,tf=window.cancelIdleCallback;else sf=function(a){return setTimeout(function(){a({timeRemaining:function(){return Infinity}});})},
	tf=function(a){clearTimeout(a);};var Ef=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Ff={},Gf={};
	function Hf(a){if(Gf.hasOwnProperty(a))return!0;if(Ff.hasOwnProperty(a))return!1;if(Ef.test(a))return Gf[a]=!0;Ff[a]=!0;return!1}
	function If(a,b,c){var d=wa(b);if(d&&va(b,c)){var e=d.mutationMethod;e?e(a,c):null==c||d.hasBooleanValue&&!c||d.hasNumericValue&&isNaN(c)||d.hasPositiveNumericValue&&1>c||d.hasOverloadedBooleanValue&&!1===c?Jf(a,b):d.mustUseProperty?a[d.propertyName]=c:(b=d.attributeName,(e=d.attributeNamespace)?a.setAttributeNS(e,b,""+c):d.hasBooleanValue||d.hasOverloadedBooleanValue&&!0===c?a.setAttribute(b,""):a.setAttribute(b,""+c));}else Kf(a,b,va(b,c)?c:null);}
	function Kf(a,b,c){Hf(b)&&(null==c?a.removeAttribute(b):a.setAttribute(b,""+c));}function Jf(a,b){var c=wa(b);c?(b=c.mutationMethod)?b(a,void 0):c.mustUseProperty?a[c.propertyName]=c.hasBooleanValue?!1:"":a.removeAttribute(c.attributeName):a.removeAttribute(b);}
	function Lf(a,b){var c=b.value,d=b.checked;return assign({type:void 0,step:void 0,min:void 0,max:void 0},b,{defaultChecked:void 0,defaultValue:void 0,value:null!=c?c:a._wrapperState.initialValue,checked:null!=d?d:a._wrapperState.initialChecked})}function Mf(a,b){var c=b.defaultValue;a._wrapperState={initialChecked:null!=b.checked?b.checked:b.defaultChecked,initialValue:null!=b.value?b.value:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}
	function Nf(a,b){b=b.checked;null!=b&&If(a,"checked",b);}function Of(a,b){Nf(a,b);var c=b.value;if(null!=c)if(0===c&&""===a.value)a.value="0";else if("number"===b.type){if(b=parseFloat(a.value)||0,c!=b||c==b&&a.value!=c)a.value=""+c;}else a.value!==""+c&&(a.value=""+c);else null==b.value&&null!=b.defaultValue&&a.defaultValue!==""+b.defaultValue&&(a.defaultValue=""+b.defaultValue),null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
	function Pf(a,b){switch(b.type){case "submit":case "reset":break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":a.value="";a.value=a.defaultValue;break;default:a.value=a.value;}b=a.name;""!==b&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;""!==b&&(a.name=b);}function Qf(a){var b="";react.Children.forEach(a,function(a){null==a||"string"!==typeof a&&"number"!==typeof a||(b+=a);});return b}
	function Rf(a,b){a=assign({children:void 0},b);if(b=Qf(b.children))a.children=b;return a}function Sf(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0);}else{c=""+c;b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=!0);}}
	function Tf(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple};}function Uf(a,b){null!=b.dangerouslySetInnerHTML?E$1("91"):void 0;return assign({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Vf(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?E$1("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:E$1("93"),b=b[0]),c=""+b),null==c&&(c=""));a._wrapperState={initialValue:""+c};}
	function Wf(a,b){var c=b.value;null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue);}function Xf(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b);}var Yf={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
	function Zf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function $f(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Zf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
	var ag=void 0,bg=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if(a.namespaceURI!==Yf.svg||"innerHTML"in a)a.innerHTML=b;else{ag=ag||document.createElement("div");ag.innerHTML="\x3csvg\x3e"+b+"\x3c/svg\x3e";for(b=ag.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild);}});
	function cg(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}
	var dg={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,
	stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},eg=["Webkit","ms","Moz","O"];Object.keys(dg).forEach(function(a){eg.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);dg[b]=dg[a];});});
	function fg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--");var e=c;var f=b[c];e=null==f||"boolean"===typeof f||""===f?"":d||"number"!==typeof f||0===f||dg.hasOwnProperty(e)&&dg[e]?(""+f).trim():f+"px";"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;}}var gg=assign({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
	function hg(a,b,c){b&&(gg[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?E$1("137",a,c()):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?E$1("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:E$1("61")),null!=b.style&&"object"!==typeof b.style?E$1("62",c()):void 0);}
	function ig(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var jg=Yf.html,kg=emptyFunction$2.thatReturns("");
	function lg(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Hd(a);b=Sa[b];for(var d=0;d<b.length;d++){var e=b[d];c.hasOwnProperty(e)&&c[e]||("topScroll"===e?wd("topScroll","scroll",a):"topFocus"===e||"topBlur"===e?(wd("topFocus","focus",a),wd("topBlur","blur",a),c.topBlur=!0,c.topFocus=!0):"topCancel"===e?(yc("cancel",!0)&&wd("topCancel","cancel",a),c.topCancel=!0):"topClose"===e?(yc("close",!0)&&wd("topClose","close",a),c.topClose=!0):Dd.hasOwnProperty(e)&&U$1(e,Dd[e],a),c[e]=!0);}}
	var mg={topAbort:"abort",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topLoadedData:"loadeddata",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topSeeked:"seeked",topSeeking:"seeking",topStalled:"stalled",topSuspend:"suspend",topTimeUpdate:"timeupdate",topVolumeChange:"volumechange",
	topWaiting:"waiting"};function ng(a,b,c,d){c=9===c.nodeType?c:c.ownerDocument;d===jg&&(d=Zf(a));d===jg?"script"===a?(a=c.createElement("div"),a.innerHTML="\x3cscript\x3e\x3c/script\x3e",a=a.removeChild(a.firstChild)):a="string"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a}function og(a,b){return(9===b.nodeType?b:b.ownerDocument).createTextNode(a)}
	function pg(a,b,c,d){var e=ig(b,c);switch(b){case "iframe":case "object":U$1("topLoad","load",a);var f=c;break;case "video":case "audio":for(f in mg)mg.hasOwnProperty(f)&&U$1(f,mg[f],a);f=c;break;case "source":U$1("topError","error",a);f=c;break;case "img":case "image":U$1("topError","error",a);U$1("topLoad","load",a);f=c;break;case "form":U$1("topReset","reset",a);U$1("topSubmit","submit",a);f=c;break;case "details":U$1("topToggle","toggle",a);f=c;break;case "input":Mf(a,c);f=Lf(a,c);U$1("topInvalid","invalid",a);
	lg(d,"onChange");break;case "option":f=Rf(a,c);break;case "select":Tf(a,c);f=assign({},c,{value:void 0});U$1("topInvalid","invalid",a);lg(d,"onChange");break;case "textarea":Vf(a,c);f=Uf(a,c);U$1("topInvalid","invalid",a);lg(d,"onChange");break;default:f=c;}hg(b,f,kg);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];"style"===h?fg(a,k,kg):"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,null!=k&&bg(a,k)):"children"===h?"string"===typeof k?("textarea"!==b||""!==k)&&cg(a,k):"number"===typeof k&&cg(a,
	""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(Ra.hasOwnProperty(h)?null!=k&&lg(d,h):e?Kf(a,h,k):null!=k&&If(a,h,k));}switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "option":null!=c.value&&a.setAttribute("value",c.value);break;case "select":a.multiple=!!c.multiple;b=c.value;null!=b?Sf(a,!!c.multiple,b,!1):null!=c.defaultValue&&Sf(a,!!c.multiple,c.defaultValue,!0);break;default:"function"===typeof f.onClick&&(a.onclick=
	emptyFunction$2);}}
	function sg(a,b,c,d,e){var f=null;switch(b){case "input":c=Lf(a,c);d=Lf(a,d);f=[];break;case "option":c=Rf(a,c);d=Rf(a,d);f=[];break;case "select":c=assign({},c,{value:void 0});d=assign({},d,{value:void 0});f=[];break;case "textarea":c=Uf(a,c);d=Uf(a,d);f=[];break;default:"function"!==typeof c.onClick&&"function"===typeof d.onClick&&(a.onclick=emptyFunction$2);}hg(b,d,kg);var g,h;a=null;for(g in c)if(!d.hasOwnProperty(g)&&c.hasOwnProperty(g)&&null!=c[g])if("style"===g)for(h in b=c[g],b)b.hasOwnProperty(h)&&(a||(a={}),a[h]=
	"");else"dangerouslySetInnerHTML"!==g&&"children"!==g&&"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&"autoFocus"!==g&&(Ra.hasOwnProperty(g)?f||(f=[]):(f=f||[]).push(g,null));for(g in d){var k=d[g];b=null!=c?c[g]:void 0;if(d.hasOwnProperty(g)&&k!==b&&(null!=k||null!=b))if("style"===g)if(b){for(h in b)!b.hasOwnProperty(h)||k&&k.hasOwnProperty(h)||(a||(a={}),a[h]="");for(h in k)k.hasOwnProperty(h)&&b[h]!==k[h]&&(a||(a={}),a[h]=k[h]);}else a||(f||(f=[]),f.push(g,a)),a=k;else"dangerouslySetInnerHTML"===
	g?(k=k?k.__html:void 0,b=b?b.__html:void 0,null!=k&&b!==k&&(f=f||[]).push(g,""+k)):"children"===g?b===k||"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(g,""+k):"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&(Ra.hasOwnProperty(g)?(null!=k&&lg(e,g),f||b===k||(f=[])):(f=f||[]).push(g,k));}a&&(f=f||[]).push("style",a);return f}
	function tg(a,b,c,d,e){"input"===c&&"radio"===e.type&&null!=e.name&&Nf(a,e);ig(c,d);d=ig(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?fg(a,h,kg):"dangerouslySetInnerHTML"===g?bg(a,h):"children"===g?cg(a,h):d?null!=h?Kf(a,g,h):a.removeAttribute(g):null!=h?If(a,g,h):Jf(a,g);}switch(c){case "input":Of(a,e);break;case "textarea":Wf(a,e);break;case "select":a._wrapperState.initialValue=void 0,b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?Sf(a,
	!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?Sf(a,!!e.multiple,e.defaultValue,!0):Sf(a,!!e.multiple,e.multiple?[]:"",!1));}}
	function ug(a,b,c,d,e){switch(b){case "iframe":case "object":U$1("topLoad","load",a);break;case "video":case "audio":for(var f in mg)mg.hasOwnProperty(f)&&U$1(f,mg[f],a);break;case "source":U$1("topError","error",a);break;case "img":case "image":U$1("topError","error",a);U$1("topLoad","load",a);break;case "form":U$1("topReset","reset",a);U$1("topSubmit","submit",a);break;case "details":U$1("topToggle","toggle",a);break;case "input":Mf(a,c);U$1("topInvalid","invalid",a);lg(e,"onChange");break;case "select":Tf(a,c);
	U$1("topInvalid","invalid",a);lg(e,"onChange");break;case "textarea":Vf(a,c),U$1("topInvalid","invalid",a),lg(e,"onChange");}hg(b,c,kg);d=null;for(var g in c)c.hasOwnProperty(g)&&(f=c[g],"children"===g?"string"===typeof f?a.textContent!==f&&(d=["children",f]):"number"===typeof f&&a.textContent!==""+f&&(d=["children",""+f]):Ra.hasOwnProperty(g)&&null!=f&&lg(e,g));switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "select":case "option":break;default:"function"===typeof c.onClick&&
	(a.onclick=emptyFunction$2);}return d}function vg(a,b){return a.nodeValue!==b}
	var wg=Object.freeze({createElement:ng,createTextNode:og,setInitialProperties:pg,diffProperties:sg,updateProperties:tg,diffHydratedProperties:ug,diffHydratedText:vg,warnForUnmatchedText:function(){},warnForDeletedHydratableElement:function(){},warnForDeletedHydratableText:function(){},warnForInsertedHydratedElement:function(){},warnForInsertedHydratedText:function(){},restoreControlledState:function(a,b,c){switch(b){case "input":Of(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=
	c.parentNode;c=c.querySelectorAll("input[name\x3d"+JSON.stringify(""+b)+'][type\x3d"radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=rb(d);e?void 0:E$1("90");Cc(d);Of(d,e);}}}break;case "textarea":Wf(a,c);break;case "select":b=c.value,null!=b&&Sf(a,!!c.multiple,b,!1);}}});nc.injectFiberControlledHostComponent(wg);var xg=null,Mg=null;function Ng(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}
	function Og(a){a=a?9===a.nodeType?a.documentElement:a.firstChild:null;return!(!a||1!==a.nodeType||!a.hasAttribute("data-reactroot"))}
	var Z=of({getRootHostContext:function(a){var b=a.nodeType;switch(b){case 9:case 11:a=(a=a.documentElement)?a.namespaceURI:$f(null,"");break;default:b=8===b?a.parentNode:a,a=b.namespaceURI||null,b=b.tagName,a=$f(a,b);}return a},getChildHostContext:function(a,b){return $f(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){xg=td;var a=require$$7();if(Kd(a)){if("selectionStart"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{var c=window.getSelection&&window.getSelection();
	if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType;}catch(z){b=null;break a}var f=0,g=-1,h=-1,k=0,q=0,v=a,y=null;b:for(;;){for(var u;;){v!==b||0!==d&&3!==v.nodeType||(g=f+d);v!==e||0!==c&&3!==v.nodeType||(h=f+c);3===v.nodeType&&(f+=v.nodeValue.length);if(null===(u=v.firstChild))break;y=v;v=u;}for(;;){if(v===a)break b;y===b&&++k===d&&(g=f);y===e&&++q===c&&(h=f);if(null!==(u=v.nextSibling))break;v=y;y=v.parentNode;}v=u;}b=-1===g||-1===h?null:
	{start:g,end:h};}else b=null;}b=b||{start:0,end:0};}else b=null;Mg={focusedElem:a,selectionRange:b};ud(!1);},resetAfterCommit:function(){var a=Mg,b=require$$7(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&require$$9(document.documentElement,c)){if(Kd(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(window.getSelection){b=window.getSelection();var e=c[Eb()].length;a=Math.min(d.start,e);d=void 0===d.end?a:Math.min(d.end,e);!b.extend&&a>
	d&&(e=d,d=a,a=e);e=Jd(c,a);var f=Jd(c,d);if(e&&f&&(1!==b.rangeCount||b.anchorNode!==e.node||b.anchorOffset!==e.offset||b.focusNode!==f.node||b.focusOffset!==f.offset)){var g=document.createRange();g.setStart(e.node,e.offset);b.removeAllRanges();a>d?(b.addRange(g),b.extend(f.node,f.offset)):(g.setEnd(f.node,f.offset),b.addRange(g));}}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});require$$10(c);for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=
	a.top;}Mg=null;ud(xg);xg=null;},createInstance:function(a,b,c,d,e){a=ng(a,b,c,d);a[Q$1]=e;a[ob]=b;return a},appendInitialChild:function(a,b){a.appendChild(b);},finalizeInitialChildren:function(a,b,c,d){pg(a,b,c,d);a:{switch(b){case "button":case "input":case "select":case "textarea":a=!!c.autoFocus;break a}a=!1;}return a},prepareUpdate:function(a,b,c,d,e){return sg(a,b,c,d,e)},shouldSetTextContent:function(a,b){return"textarea"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===
	typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&"string"===typeof b.dangerouslySetInnerHTML.__html},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=og(a,b);a[Q$1]=d;return a},now:rf,mutation:{commitMount:function(a){a.focus();},commitUpdate:function(a,b,c,d,e){a[ob]=e;tg(a,b,c,d,e);},resetTextContent:function(a){a.textContent="";},commitTextUpdate:function(a,b,c){a.nodeValue=c;},appendChild:function(a,b){a.appendChild(b);},appendChildToContainer:function(a,
	b){8===a.nodeType?a.parentNode.insertBefore(b,a):a.appendChild(b);},insertBefore:function(a,b,c){a.insertBefore(b,c);},insertInContainerBefore:function(a,b,c){8===a.nodeType?a.parentNode.insertBefore(b,c):a.insertBefore(b,c);},removeChild:function(a,b){a.removeChild(b);},removeChildFromContainer:function(a,b){8===a.nodeType?a.parentNode.removeChild(b):a.removeChild(b);}},hydration:{canHydrateInstance:function(a,b){return 1!==a.nodeType||b.toLowerCase()!==a.nodeName.toLowerCase()?null:a},canHydrateTextInstance:function(a,
	b){return""===b||3!==a.nodeType?null:a},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){a[Q$1]=f;a[ob]=c;return ug(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){a[Q$1]=c;return vg(a,b)},didNotMatchHydratedContainerTextInstance:function(){},didNotMatchHydratedTextInstance:function(){},
	didNotHydrateContainerInstance:function(){},didNotHydrateInstance:function(){},didNotFindHydratableContainerInstance:function(){},didNotFindHydratableContainerTextInstance:function(){},didNotFindHydratableInstance:function(){},didNotFindHydratableTextInstance:function(){}},scheduleDeferredCallback:sf,cancelDeferredCallback:tf,useSyncScheduling:!0});rc=Z.batchedUpdates;
	function Pg(a,b,c,d,e){Ng(c)?void 0:E$1("200");var f=c._reactRootContainer;if(f)Z.updateContainer(b,f,a,e);else{d=d||Og(c);if(!d)for(f=void 0;f=c.lastChild;)c.removeChild(f);var g=Z.createContainer(c,d);f=c._reactRootContainer=g;Z.unbatchedUpdates(function(){Z.updateContainer(b,g,a,e);});}return Z.getPublicRootInstance(f)}function Qg(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Ng(b)?void 0:E$1("200");return pf(a,b,null,c)}
	var Sg={createPortal:Qg,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(b)return Z.findHostInstance(b);"function"===typeof a.render?E$1("188"):E$1("213",Object.keys(a));},hydrate:function(a,b,c){return Pg(null,a,b,!0,c)},render:function(a,b,c){return Pg(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?E$1("38"):void 0;return Pg(a,b,c,!1,d)},unmountComponentAtNode:function(a){Ng(a)?void 0:
	E$1("40");return a._reactRootContainer?(Z.unbatchedUpdates(function(){Pg(null,null,a,!1,function(){a._reactRootContainer=null;});}),!0):!1},unstable_createPortal:Qg,unstable_batchedUpdates:tc,unstable_deferredUpdates:Z.deferredUpdates,flushSync:Z.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:mb,EventPluginRegistry:Va,EventPropagators:Cb,ReactControlledComponent:qc,ReactDOMComponentTree:sb,ReactDOMEventListener:xd}};
	Z.injectIntoDevTools({findFiberByHostInstance:pb,bundleType:0,version:"16.2.0",rendererPackageName:"react-dom"});var Tg=Object.freeze({default:Sg}),Ug=Tg&&Sg||Tg;var reactDom_production_min=Ug["default"]?Ug["default"]:Ug;

	var reactDom_production_min$1 = /*#__PURE__*/Object.freeze({
		default: reactDom_production_min,
		__moduleExports: reactDom_production_min
	});

	var reactDom_development = createCommonjsModule(function (module) {
	});

	var require$$0$2 = ( reactDom_production_min$1 && reactDom_production_min ) || reactDom_production_min$1;

	var reactDom = createCommonjsModule(function (module) {

	function checkDCE() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
	  ) {
	    return;
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}

	{
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE();
	  module.exports = require$$0$2;
	}
	});
	var reactDom_1 = reactDom.ReactDOM;

	var factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === require$$2) {
	      // It is still safe when called from React.
	      return;
	    }
	    require$$0(
	      false,
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	  }  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim
	  };

	  ReactPropTypes.checkPropTypes = emptyFunction$2;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	var factoryWithThrowingShims$1 = /*#__PURE__*/Object.freeze({
		default: factoryWithThrowingShims,
		__moduleExports: factoryWithThrowingShims
	});

	var require$$1$3 = ( factoryWithThrowingShims$1 && factoryWithThrowingShims ) || factoryWithThrowingShims$1;

	var propTypes = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	{
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = require$$1$3();
	}
	});

	var subscriptionShape = propTypes.shape({
	  trySubscribe: propTypes.func.isRequired,
	  tryUnsubscribe: propTypes.func.isRequired,
	  notifyNestedSubs: propTypes.func.isRequired,
	  isSubscribed: propTypes.func.isRequired
	});

	var storeShape = propTypes.shape({
	  subscribe: propTypes.func.isRequired,
	  dispatch: propTypes.func.isRequired,
	  getState: propTypes.func.isRequired
	});

	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function createProvider() {
	  var _Provider$childContex;

	  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
	  var subKey = arguments[1];

	  var subscriptionKey = subKey || storeKey + 'Subscription';

	  var Provider = function (_Component) {
	    _inherits(Provider, _Component);

	    Provider.prototype.getChildContext = function getChildContext() {
	      var _ref;

	      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
	    };

	    function Provider(props, context) {
	      _classCallCheck(this, Provider);

	      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

	      _this[storeKey] = props.store;
	      return _this;
	    }

	    Provider.prototype.render = function render() {
	      return react_2.only(this.props.children);
	    };

	    return Provider;
	  }(react_3);

	  Provider.propTypes = {
	    store: storeShape.isRequired,
	    children: propTypes.element.isRequired
	  };
	  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = storeShape.isRequired, _Provider$childContex[subscriptionKey] = subscriptionShape, _Provider$childContex);

	  return Provider;
	}

	var Provider = createProvider();

	var hoistNonReactStatics = createCommonjsModule(function (module, exports) {
	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	(function (global, factory) {
	    module.exports = factory();
	}(commonjsGlobal, (function () {
	    
	    var REACT_STATICS = {
	        childContextTypes: true,
	        contextTypes: true,
	        defaultProps: true,
	        displayName: true,
	        getDefaultProps: true,
	        getDerivedStateFromProps: true,
	        mixins: true,
	        propTypes: true,
	        type: true
	    };
	    
	    var KNOWN_STATICS = {
	        name: true,
	        length: true,
	        prototype: true,
	        caller: true,
	        callee: true,
	        arguments: true,
	        arity: true
	    };
	    
	    var defineProperty = Object.defineProperty;
	    var getOwnPropertyNames = Object.getOwnPropertyNames;
	    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	    var getPrototypeOf = Object.getPrototypeOf;
	    var objectPrototype = getPrototypeOf && getPrototypeOf(Object);
	    
	    return function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
	        if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	            
	            if (objectPrototype) {
	                var inheritedComponent = getPrototypeOf(sourceComponent);
	                if (inheritedComponent && inheritedComponent !== objectPrototype) {
	                    hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
	                }
	            }
	            
	            var keys = getOwnPropertyNames(sourceComponent);
	            
	            if (getOwnPropertySymbols) {
	                keys = keys.concat(getOwnPropertySymbols(sourceComponent));
	            }
	            
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
	                    var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
	                    try { // Avoid failures from read-only properties
	                        defineProperty(targetComponent, key, descriptor);
	                    } catch (e) {}
	                }
	            }
	            
	            return targetComponent;
	        }
	        
	        return targetComponent;
	    };
	})));
	});

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var NODE_ENV = "production";

	var invariant$3 = function(condition, format, a, b, c, d, e, f) {
	  if (NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	var invariant_1$1 = invariant$3;

	function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// encapsulates the subscription logic for connecting a component to the redux store, as
	// well as nesting subscriptions of descendant components, so that we can ensure the
	// ancestor components re-render before descendants

	var CLEARED = null;
	var nullListeners = {
	  notify: function notify() {}
	};

	function createListenerCollection() {
	  // the current/next pattern is copied from redux's createStore code.
	  // TODO: refactor+expose that code to be reusable here?
	  var current = [];
	  var next = [];

	  return {
	    clear: function clear() {
	      next = CLEARED;
	      current = CLEARED;
	    },
	    notify: function notify() {
	      var listeners = current = next;
	      for (var i = 0; i < listeners.length; i++) {
	        listeners[i]();
	      }
	    },
	    get: function get() {
	      return next;
	    },
	    subscribe: function subscribe(listener) {
	      var isSubscribed = true;
	      if (next === current) next = current.slice();
	      next.push(listener);

	      return function unsubscribe() {
	        if (!isSubscribed || current === CLEARED) return;
	        isSubscribed = false;

	        if (next === current) next = current.slice();
	        next.splice(next.indexOf(listener), 1);
	      };
	    }
	  };
	}

	var Subscription = function () {
	  function Subscription(store, parentSub, onStateChange) {
	    _classCallCheck$1(this, Subscription);

	    this.store = store;
	    this.parentSub = parentSub;
	    this.onStateChange = onStateChange;
	    this.unsubscribe = null;
	    this.listeners = nullListeners;
	  }

	  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
	    this.trySubscribe();
	    return this.listeners.subscribe(listener);
	  };

	  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
	    this.listeners.notify();
	  };

	  Subscription.prototype.isSubscribed = function isSubscribed() {
	    return Boolean(this.unsubscribe);
	  };

	  Subscription.prototype.trySubscribe = function trySubscribe() {
	    if (!this.unsubscribe) {
	      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

	      this.listeners = createListenerCollection();
	    }
	  };

	  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
	    if (this.unsubscribe) {
	      this.unsubscribe();
	      this.unsubscribe = null;
	      this.listeners.clear();
	      this.listeners = nullListeners;
	    }
	  };

	  return Subscription;
	}();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var hotReloadingVersion = 0;
	var dummyState = {};
	function noop() {}
	function makeSelectorStateful(sourceSelector, store) {
	  // wrap the selector in an object that tracks its results between runs.
	  var selector = {
	    run: function runComponentSelector(props) {
	      try {
	        var nextProps = sourceSelector(store.getState(), props);
	        if (nextProps !== selector.props || selector.error) {
	          selector.shouldComponentUpdate = true;
	          selector.props = nextProps;
	          selector.error = null;
	        }
	      } catch (error) {
	        selector.shouldComponentUpdate = true;
	        selector.error = error;
	      }
	    }
	  };

	  return selector;
	}

	function connectAdvanced(
	/*
	  selectorFactory is a func that is responsible for returning the selector function used to
	  compute new props from state, props, and dispatch. For example:
	     export default connectAdvanced((dispatch, options) => (state, props) => ({
	      thing: state.things[props.thingId],
	      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
	    }))(YourComponent)
	   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
	  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
	  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
	   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
	  props. Do not use connectAdvanced directly without memoizing results between calls to your
	  selector, otherwise the Connect component will re-render on every state or props change.
	*/
	selectorFactory) {
	  var _contextTypes, _childContextTypes;

	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$getDisplayName = _ref.getDisplayName,
	      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
	    return 'ConnectAdvanced(' + name + ')';
	  } : _ref$getDisplayName,
	      _ref$methodName = _ref.methodName,
	      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
	      _ref$renderCountProp = _ref.renderCountProp,
	      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
	      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
	      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
	      _ref$storeKey = _ref.storeKey,
	      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
	      _ref$withRef = _ref.withRef,
	      withRef = _ref$withRef === undefined ? false : _ref$withRef,
	      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

	  var subscriptionKey = storeKey + 'Subscription';
	  var version = hotReloadingVersion++;

	  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = storeShape, _contextTypes[subscriptionKey] = subscriptionShape, _contextTypes);
	  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = subscriptionShape, _childContextTypes);

	  return function wrapWithConnect(WrappedComponent) {
	    invariant_1$1(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + (methodName + '. Instead received ' + JSON.stringify(WrappedComponent)));

	    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

	    var displayName = getDisplayName(wrappedComponentName);

	    var selectorFactoryOptions = _extends({}, connectOptions, {
	      getDisplayName: getDisplayName,
	      methodName: methodName,
	      renderCountProp: renderCountProp,
	      shouldHandleStateChanges: shouldHandleStateChanges,
	      storeKey: storeKey,
	      withRef: withRef,
	      displayName: displayName,
	      wrappedComponentName: wrappedComponentName,
	      WrappedComponent: WrappedComponent
	    });

	    var Connect = function (_Component) {
	      _inherits$1(Connect, _Component);

	      function Connect(props, context) {
	        _classCallCheck$2(this, Connect);

	        var _this = _possibleConstructorReturn$1(this, _Component.call(this, props, context));

	        _this.version = version;
	        _this.state = {};
	        _this.renderCount = 0;
	        _this.store = props[storeKey] || context[storeKey];
	        _this.propsMode = Boolean(props[storeKey]);
	        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

	        invariant_1$1(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

	        _this.initSelector();
	        _this.initSubscription();
	        return _this;
	      }

	      Connect.prototype.getChildContext = function getChildContext() {
	        var _ref2;

	        // If this component received store from props, its subscription should be transparent
	        // to any descendants receiving store+subscription from context; it passes along
	        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
	        // Connect to control ordering of notifications to flow top-down.
	        var subscription = this.propsMode ? null : this.subscription;
	        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
	      };

	      Connect.prototype.componentDidMount = function componentDidMount() {
	        if (!shouldHandleStateChanges) return;

	        // componentWillMount fires during server side rendering, but componentDidMount and
	        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
	        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
	        // To handle the case where a child component may have triggered a state change by
	        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
	        // re-render.
	        this.subscription.trySubscribe();
	        this.selector.run(this.props);
	        if (this.selector.shouldComponentUpdate) this.forceUpdate();
	      };

	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        this.selector.run(nextProps);
	      };

	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return this.selector.shouldComponentUpdate;
	      };

	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        if (this.subscription) this.subscription.tryUnsubscribe();
	        this.subscription = null;
	        this.notifyNestedSubs = noop;
	        this.store = null;
	        this.selector.run = noop;
	        this.selector.shouldComponentUpdate = false;
	      };

	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        invariant_1$1(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
	        return this.wrappedInstance;
	      };

	      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
	        this.wrappedInstance = ref;
	      };

	      Connect.prototype.initSelector = function initSelector() {
	        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
	        this.selector = makeSelectorStateful(sourceSelector, this.store);
	        this.selector.run(this.props);
	      };

	      Connect.prototype.initSubscription = function initSubscription() {
	        if (!shouldHandleStateChanges) return;

	        // parentSub's source should match where store came from: props vs. context. A component
	        // connected to the store via props shouldn't use subscription from context, or vice versa.
	        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
	        this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this));

	        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
	        // the middle of the notification loop, where `this.subscription` will then be null. An
	        // extra null check every change can be avoided by copying the method onto `this` and then
	        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
	        // listeners logic is changed to not call listeners that have been unsubscribed in the
	        // middle of the notification loop.
	        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
	      };

	      Connect.prototype.onStateChange = function onStateChange() {
	        this.selector.run(this.props);

	        if (!this.selector.shouldComponentUpdate) {
	          this.notifyNestedSubs();
	        } else {
	          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
	          this.setState(dummyState);
	        }
	      };

	      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
	        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
	        // needs to notify nested subs. Once called, it unimplements itself until further state
	        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
	        // a boolean check every time avoids an extra method call most of the time, resulting
	        // in some perf boost.
	        this.componentDidUpdate = undefined;
	        this.notifyNestedSubs();
	      };

	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return Boolean(this.subscription) && this.subscription.isSubscribed();
	      };

	      Connect.prototype.addExtraProps = function addExtraProps(props) {
	        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
	        // make a shallow copy so that fields added don't leak to the original selector.
	        // this is especially important for 'ref' since that's a reference back to the component
	        // instance. a singleton memoized selector would then be holding a reference to the
	        // instance, preventing the instance from being garbage collected, and that would be bad
	        var withExtras = _extends({}, props);
	        if (withRef) withExtras.ref = this.setWrappedInstance;
	        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
	        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
	        return withExtras;
	      };

	      Connect.prototype.render = function render() {
	        var selector = this.selector;
	        selector.shouldComponentUpdate = false;

	        if (selector.error) {
	          throw selector.error;
	        } else {
	          return react_4(WrappedComponent, this.addExtraProps(selector.props));
	        }
	      };

	      return Connect;
	    }(react_3);

	    Connect.WrappedComponent = WrappedComponent;
	    Connect.displayName = displayName;
	    Connect.childContextTypes = childContextTypes;
	    Connect.contextTypes = contextTypes;
	    Connect.propTypes = contextTypes;

	    return hoistNonReactStatics(Connect, WrappedComponent);
	  };
	}

	var hasOwn = Object.prototype.hasOwnProperty;

	function is$1(x, y) {
	  if (x === y) {
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    return x !== x && y !== y;
	  }
	}

	function shallowEqual$2(objA, objB) {
	  if (is$1(objA, objB)) return true;

	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) return false;

	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || !is$1(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }

	  return true;
	}

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Built-in value references. */
	var Symbol$1 = root.Symbol;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$2.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$2.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$3.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;

		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}

		return result;
	}

	/* global window */

	var root$1;

	if (typeof self !== 'undefined') {
	  root$1 = self;
	} else if (typeof window !== 'undefined') {
	  root$1 = window;
	} else if (typeof global !== 'undefined') {
	  root$1 = global;
	} else if (typeof module !== 'undefined') {
	  root$1 = module;
	} else {
	  root$1 = Function('return this')();
	}

	var result = symbolObservablePonyfill(root$1);

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = {
	  INIT: '@@redux/INIT'

	  /**
	   * Creates a Redux store that holds the state tree.
	   * The only way to change the data in the store is to call `dispatch()` on it.
	   *
	   * There should only be a single store in your app. To specify how different
	   * parts of the state tree respond to actions, you may combine several reducers
	   * into a single reducer function by using `combineReducers`.
	   *
	   * @param {Function} reducer A function that returns the next state tree, given
	   * the current state tree and the action to handle.
	   *
	   * @param {any} [preloadedState] The initial state. You may optionally specify it
	   * to hydrate the state from the server in universal apps, or to restore a
	   * previously serialized user session.
	   * If you use `combineReducers` to produce the root reducer function, this must be
	   * an object with the same shape as `combineReducers` keys.
	   *
	   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
	   * to enhance the store with third-party capabilities such as middleware,
	   * time travel, persistence, etc. The only store enhancer that ships with Redux
	   * is `applyMiddleware()`.
	   *
	   * @returns {Store} A Redux store that lets you read the state, dispatch actions
	   * and subscribe to changes.
	   */
	};function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;

	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }

	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }

	    return enhancer(createStore)(reducer, preloadedState);
	  }

	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }

	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;

	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }

	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }

	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }

	    var isSubscribed = true;

	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);

	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }

	      isSubscribed = false;

	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }

	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing what changed. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!isPlainObject(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }

	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }

	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }

	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }

	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      var listener = listeners[i];
	      listener();
	    }

	    return action;
	  }

	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }

	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }

	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/tc39/proposal-observable
	   */
	  function observable() {
	    var _ref;

	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }

	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }

	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[result] = function () {
	      return this;
	    }, _ref;
	  }

	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });

	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[result] = observable, _ref2;
	}

	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */

	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
	}

	function assertReducerShape(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: ActionTypes.INIT });

	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
	    }

	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
	    }
	  });
	}

	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];

	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);

	  var shapeAssertionError = void 0;
	  try {
	    assertReducerShape(finalReducers);
	  } catch (e) {
	    shapeAssertionError = e;
	  }

	  return function combination() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];

	    if (shapeAssertionError) {
	      throw shapeAssertionError;
	    }

	    var hasChanged = false;
	    var nextState = {};
	    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
	      var _key = finalReducerKeys[_i];
	      var reducer = finalReducers[_key];
	      var previousStateForKey = state[_key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(_key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[_key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}

	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}

	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }

	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }

	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */

	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }

	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }

	  if (funcs.length === 1) {
	    return funcs[0];
	  }

	  return funcs.reduce(function (a, b) {
	    return function () {
	      return a(b.apply(undefined, arguments));
	    };
	  });
	}

	var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }

	  return function (createStore) {
	    return function (reducer, preloadedState, enhancer) {
	      var store = createStore(reducer, preloadedState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];

	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = compose.apply(undefined, chain)(store.dispatch);

	      return _extends$1({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

	function wrapMapToPropsConstant(getConstant) {
	  return function initConstantSelector(dispatch, options) {
	    var constant = getConstant(dispatch, options);

	    function constantSelector() {
	      return constant;
	    }
	    constantSelector.dependsOnOwnProps = false;
	    return constantSelector;
	  };
	}

	// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
	// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
	// whether mapToProps needs to be invoked when props have changed.
	// 
	// A length of one signals that mapToProps does not depend on props from the parent component.
	// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
	// therefore not reporting its length accurately..
	function getDependsOnOwnProps(mapToProps) {
	  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
	}

	// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
	// this function wraps mapToProps in a proxy function which does several things:
	// 
	//  * Detects whether the mapToProps function being called depends on props, which
	//    is used by selectorFactory to decide if it should reinvoke on props changes.
	//    
	//  * On first call, handles mapToProps if returns another function, and treats that
	//    new function as the true mapToProps for subsequent calls.
	//    
	//  * On first call, verifies the first result is a plain object, in order to warn
	//    the developer that their mapToProps function is not returning a valid result.
	//    
	function wrapMapToPropsFunc(mapToProps, methodName) {
	  return function initProxySelector(dispatch, _ref) {
	    var displayName = _ref.displayName;

	    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
	      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
	    };

	    // allow detectFactoryAndVerify to get ownProps
	    proxy.dependsOnOwnProps = true;

	    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
	      proxy.mapToProps = mapToProps;
	      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
	      var props = proxy(stateOrDispatch, ownProps);

	      if (typeof props === 'function') {
	        proxy.mapToProps = props;
	        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
	        props = proxy(stateOrDispatch, ownProps);
	      }

	      return props;
	    };

	    return proxy;
	  };
	}

	function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
	  return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : undefined;
	}

	function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
	  return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {
	    return { dispatch: dispatch };
	  }) : undefined;
	}

	function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
	  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(function (dispatch) {
	    return bindActionCreators(mapDispatchToProps, dispatch);
	  }) : undefined;
	}

	var defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

	function whenMapStateToPropsIsFunction(mapStateToProps) {
	  return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : undefined;
	}

	function whenMapStateToPropsIsMissing(mapStateToProps) {
	  return !mapStateToProps ? wrapMapToPropsConstant(function () {
	    return {};
	  }) : undefined;
	}

	var defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

	var _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function defaultMergeProps(stateProps, dispatchProps, ownProps) {
	  return _extends$2({}, ownProps, stateProps, dispatchProps);
	}

	function wrapMergePropsFunc(mergeProps) {
	  return function initMergePropsProxy(dispatch, _ref) {
	    var displayName = _ref.displayName,
	        pure = _ref.pure,
	        areMergedPropsEqual = _ref.areMergedPropsEqual;

	    var hasRunOnce = false;
	    var mergedProps = void 0;

	    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
	      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

	      if (hasRunOnce) {
	        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
	      } else {
	        hasRunOnce = true;
	        mergedProps = nextMergedProps;
	      }

	      return mergedProps;
	    };
	  };
	}

	function whenMergePropsIsFunction(mergeProps) {
	  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
	}

	function whenMergePropsIsOmitted(mergeProps) {
	  return !mergeProps ? function () {
	    return defaultMergeProps;
	  } : undefined;
	}

	var defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];

	function _objectWithoutProperties$1(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
	  return function impureFinalPropsSelector(state, ownProps) {
	    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
	  };
	}

	function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
	  var areStatesEqual = _ref.areStatesEqual,
	      areOwnPropsEqual = _ref.areOwnPropsEqual,
	      areStatePropsEqual = _ref.areStatePropsEqual;

	  var hasRunAtLeastOnce = false;
	  var state = void 0;
	  var ownProps = void 0;
	  var stateProps = void 0;
	  var dispatchProps = void 0;
	  var mergedProps = void 0;

	  function handleFirstCall(firstState, firstOwnProps) {
	    state = firstState;
	    ownProps = firstOwnProps;
	    stateProps = mapStateToProps(state, ownProps);
	    dispatchProps = mapDispatchToProps(dispatch, ownProps);
	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    hasRunAtLeastOnce = true;
	    return mergedProps;
	  }

	  function handleNewPropsAndNewState() {
	    stateProps = mapStateToProps(state, ownProps);

	    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    return mergedProps;
	  }

	  function handleNewProps() {
	    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

	    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    return mergedProps;
	  }

	  function handleNewState() {
	    var nextStateProps = mapStateToProps(state, ownProps);
	    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
	    stateProps = nextStateProps;

	    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

	    return mergedProps;
	  }

	  function handleSubsequentCalls(nextState, nextOwnProps) {
	    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
	    var stateChanged = !areStatesEqual(nextState, state);
	    state = nextState;
	    ownProps = nextOwnProps;

	    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
	    if (propsChanged) return handleNewProps();
	    if (stateChanged) return handleNewState();
	    return mergedProps;
	  }

	  return function pureFinalPropsSelector(nextState, nextOwnProps) {
	    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
	  };
	}

	// TODO: Add more comments

	// If pure is true, the selector returned by selectorFactory will memoize its results,
	// allowing connectAdvanced's shouldComponentUpdate to return false if final
	// props have not changed. If false, the selector will always return a new
	// object and shouldComponentUpdate will always return true.

	function finalPropsSelectorFactory(dispatch, _ref2) {
	  var initMapStateToProps = _ref2.initMapStateToProps,
	      initMapDispatchToProps = _ref2.initMapDispatchToProps,
	      initMergeProps = _ref2.initMergeProps,
	      options = _objectWithoutProperties$1(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

	  var mapStateToProps = initMapStateToProps(dispatch, options);
	  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
	  var mergeProps = initMergeProps(dispatch, options);

	  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

	  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
	}

	var _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _objectWithoutProperties$2(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	/*
	  connect is a facade over connectAdvanced. It turns its args into a compatible
	  selectorFactory, which has the signature:

	    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
	  
	  connect passes its args to connectAdvanced as options, which will in turn pass them to
	  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

	  selectorFactory returns a final props selector from its mapStateToProps,
	  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
	  mergePropsFactories, and pure args.

	  The resulting final props selector is called by the Connect component instance whenever
	  it receives new props or store state.
	 */

	function match(arg, factories, name) {
	  for (var i = factories.length - 1; i >= 0; i--) {
	    var result = factories[i](arg);
	    if (result) return result;
	  }

	  return function (dispatch, options) {
	    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
	  };
	}

	function strictEqual(a, b) {
	  return a === b;
	}

	// createConnect with default args builds the 'official' connect behavior. Calling it with
	// different options opens up some testing and extensibility scenarios
	function createConnect() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref$connectHOC = _ref.connectHOC,
	      connectHOC = _ref$connectHOC === undefined ? connectAdvanced : _ref$connectHOC,
	      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
	      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? defaultMapStateToPropsFactories : _ref$mapStateToPropsF,
	      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
	      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? defaultMapDispatchToPropsFactories : _ref$mapDispatchToPro,
	      _ref$mergePropsFactor = _ref.mergePropsFactories,
	      mergePropsFactories = _ref$mergePropsFactor === undefined ? defaultMergePropsFactories : _ref$mergePropsFactor,
	      _ref$selectorFactory = _ref.selectorFactory,
	      selectorFactory = _ref$selectorFactory === undefined ? finalPropsSelectorFactory : _ref$selectorFactory;

	  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
	        _ref2$pure = _ref2.pure,
	        pure = _ref2$pure === undefined ? true : _ref2$pure,
	        _ref2$areStatesEqual = _ref2.areStatesEqual,
	        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
	        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
	        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? shallowEqual$2 : _ref2$areOwnPropsEqua,
	        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
	        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? shallowEqual$2 : _ref2$areStatePropsEq,
	        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
	        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? shallowEqual$2 : _ref2$areMergedPropsE,
	        extraOptions = _objectWithoutProperties$2(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

	    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
	    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
	    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

	    return connectHOC(selectorFactory, _extends$3({
	      // used in error messages
	      methodName: 'connect',

	      // used to compute Connect's displayName from the wrapped component's displayName.
	      getDisplayName: function getDisplayName(name) {
	        return 'Connect(' + name + ')';
	      },

	      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
	      shouldHandleStateChanges: Boolean(mapStateToProps),

	      // passed through to selectorFactory
	      initMapStateToProps: initMapStateToProps,
	      initMapDispatchToProps: initMapDispatchToProps,
	      initMergeProps: initMergeProps,
	      pure: pure,
	      areStatesEqual: areStatesEqual,
	      areOwnPropsEqual: areOwnPropsEqual,
	      areStatePropsEqual: areStatePropsEqual,
	      areMergedPropsEqual: areMergedPropsEqual

	    }, extraOptions));
	  };
	}

	var connect = createConnect();

	var reduxLogger = createCommonjsModule(function (module, exports) {
	!function(e,t){t(exports);}(commonjsGlobal,function(e){function t(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}});}function r(e,t){Object.defineProperty(this,"kind",{value:e,enumerable:!0}),t&&t.length&&Object.defineProperty(this,"path",{value:t,enumerable:!0});}function n(e,t,r){n.super_.call(this,"E",e),Object.defineProperty(this,"lhs",{value:t,enumerable:!0}),Object.defineProperty(this,"rhs",{value:r,enumerable:!0});}function o(e,t){o.super_.call(this,"N",e),Object.defineProperty(this,"rhs",{value:t,enumerable:!0});}function i(e,t){i.super_.call(this,"D",e),Object.defineProperty(this,"lhs",{value:t,enumerable:!0});}function a(e,t,r){a.super_.call(this,"A",e),Object.defineProperty(this,"index",{value:t,enumerable:!0}),Object.defineProperty(this,"item",{value:r,enumerable:!0});}function f(e,t,r){var n=e.slice((r||t)+1||e.length);return e.length=t<0?e.length+t:t,e.push.apply(e,n),e}function u(e){var t="undefined"==typeof e?"undefined":N(e);return"object"!==t?t:e===Math?"math":null===e?"null":Array.isArray(e)?"array":"[object Date]"===Object.prototype.toString.call(e)?"date":"function"==typeof e.toString&&/^\/.*\//.test(e.toString())?"regexp":"object"}function l(e,t,r,c,s,d,p){s=s||[],p=p||[];var g=s.slice(0);if("undefined"!=typeof d){if(c){if("function"==typeof c&&c(g,d))return;if("object"===("undefined"==typeof c?"undefined":N(c))){if(c.prefilter&&c.prefilter(g,d))return;if(c.normalize){var h=c.normalize(g,d,e,t);h&&(e=h[0],t=h[1]);}}}g.push(d);}"regexp"===u(e)&&"regexp"===u(t)&&(e=e.toString(),t=t.toString());var y="undefined"==typeof e?"undefined":N(e),v="undefined"==typeof t?"undefined":N(t),b="undefined"!==y||p&&p[p.length-1].lhs&&p[p.length-1].lhs.hasOwnProperty(d),m="undefined"!==v||p&&p[p.length-1].rhs&&p[p.length-1].rhs.hasOwnProperty(d);if(!b&&m)r(new o(g,t));else if(!m&&b)r(new i(g,e));else if(u(e)!==u(t))r(new n(g,e,t));else if("date"===u(e)&&e-t!==0)r(new n(g,e,t));else if("object"===y&&null!==e&&null!==t)if(p.filter(function(t){return t.lhs===e}).length)e!==t&&r(new n(g,e,t));else{if(p.push({lhs:e,rhs:t}),Array.isArray(e)){var w;e.length;for(w=0;w<e.length;w++)w>=t.length?r(new a(g,w,new i(void 0,e[w]))):l(e[w],t[w],r,c,g,w,p);for(;w<t.length;)r(new a(g,w,new o(void 0,t[w++])));}else{var x=Object.keys(e),S=Object.keys(t);x.forEach(function(n,o){var i=S.indexOf(n);i>=0?(l(e[n],t[n],r,c,g,n,p),S=f(S,i)):l(e[n],void 0,r,c,g,n,p);}),S.forEach(function(e){l(void 0,t[e],r,c,g,e,p);});}p.length=p.length-1;}else e!==t&&("number"===y&&isNaN(e)&&isNaN(t)||r(new n(g,e,t)));}function c(e,t,r,n){return n=n||[],l(e,t,function(e){e&&n.push(e);},r),n.length?n:void 0}function s(e,t,r){if(r.path&&r.path.length){var n,o=e[t],i=r.path.length-1;for(n=0;n<i;n++)o=o[r.path[n]];switch(r.kind){case"A":s(o[r.path[n]],r.index,r.item);break;case"D":delete o[r.path[n]];break;case"E":case"N":o[r.path[n]]=r.rhs;}}else switch(r.kind){case"A":s(e[t],r.index,r.item);break;case"D":e=f(e,t);break;case"E":case"N":e[t]=r.rhs;}return e}function d(e,t,r){if(e&&t&&r&&r.kind){for(var n=e,o=-1,i=r.path?r.path.length-1:0;++o<i;)"undefined"==typeof n[r.path[o]]&&(n[r.path[o]]="number"==typeof r.path[o]?[]:{}),n=n[r.path[o]];switch(r.kind){case"A":s(r.path?n[r.path[o]]:n,r.index,r.item);break;case"D":delete n[r.path[o]];break;case"E":case"N":n[r.path[o]]=r.rhs;}}}function p(e,t,r){if(r.path&&r.path.length){var n,o=e[t],i=r.path.length-1;for(n=0;n<i;n++)o=o[r.path[n]];switch(r.kind){case"A":p(o[r.path[n]],r.index,r.item);break;case"D":o[r.path[n]]=r.lhs;break;case"E":o[r.path[n]]=r.lhs;break;case"N":delete o[r.path[n]];}}else switch(r.kind){case"A":p(e[t],r.index,r.item);break;case"D":e[t]=r.lhs;break;case"E":e[t]=r.lhs;break;case"N":e=f(e,t);}return e}function g(e,t,r){if(e&&t&&r&&r.kind){var n,o,i=e;for(o=r.path.length-1,n=0;n<o;n++)"undefined"==typeof i[r.path[n]]&&(i[r.path[n]]={}),i=i[r.path[n]];switch(r.kind){case"A":p(i[r.path[n]],r.index,r.item);break;case"D":i[r.path[n]]=r.lhs;break;case"E":i[r.path[n]]=r.lhs;break;case"N":delete i[r.path[n]];}}}function h(e,t,r){if(e&&t){var n=function(n){r&&!r(e,t,n)||d(e,t,n);};l(e,t,n);}}function y(e){return"color: "+F[e].color+"; font-weight: bold"}function v(e){var t=e.kind,r=e.path,n=e.lhs,o=e.rhs,i=e.index,a=e.item;switch(t){case"E":return[r.join("."),n,"",o];case"N":return[r.join("."),o];case"D":return[r.join(".")];case"A":return[r.join(".")+"["+i+"]",a];default:return[]}}function b(e,t,r,n){var o=c(e,t);try{n?r.groupCollapsed("diff"):r.group("diff");}catch(e){r.log("diff");}o?o.forEach(function(e){var t=e.kind,n=v(e);r.log.apply(r,["%c "+F[t].text,y(t)].concat(P(n)));}):r.log(" no diff ");try{r.groupEnd();}catch(e){r.log(" diff end  ");}}function m(e,t,r,n){switch("undefined"==typeof e?"undefined":N(e)){case"object":return"function"==typeof e[n]?e[n].apply(e,P(r)):e[n];case"function":return e(t);default:return e}}function w(e){var t=e.timestamp,r=e.duration;return function(e,n,o){var i=["action"];return i.push("%c"+String(e.type)),t&&i.push("%c@ "+n),r&&i.push("%c(in "+o.toFixed(2)+" ms)"),i.join(" ")}}function x(e,t){var r=t.logger,n=t.actionTransformer,o=t.titleFormatter,i=void 0===o?w(t):o,a=t.collapsed,f=t.colors,u=t.level,l=t.diff,c="undefined"==typeof t.titleFormatter;e.forEach(function(o,s){var d=o.started,p=o.startedTime,g=o.action,h=o.prevState,y=o.error,v=o.took,w=o.nextState,x=e[s+1];x&&(w=x.prevState,v=x.started-d);var S=n(g),k="function"==typeof a?a(function(){return w},g,o):a,j=D(p),E=f.title?"color: "+f.title(S)+";":"",A=["color: gray; font-weight: lighter;"];A.push(E),t.timestamp&&A.push("color: gray; font-weight: lighter;"),t.duration&&A.push("color: gray; font-weight: lighter;");var O=i(S,j,v);try{k?f.title&&c?r.groupCollapsed.apply(r,["%c "+O].concat(A)):r.groupCollapsed(O):f.title&&c?r.group.apply(r,["%c "+O].concat(A)):r.group(O);}catch(e){r.log(O);}var N=m(u,S,[h],"prevState"),P=m(u,S,[S],"action"),C=m(u,S,[y,h],"error"),F=m(u,S,[w],"nextState");if(N)if(f.prevState){var L="color: "+f.prevState(h)+"; font-weight: bold";r[N]("%c prev state",L,h);}else r[N]("prev state",h);if(P)if(f.action){var T="color: "+f.action(S)+"; font-weight: bold";r[P]("%c action    ",T,S);}else r[P]("action    ",S);if(y&&C)if(f.error){var M="color: "+f.error(y,h)+"; font-weight: bold;";r[C]("%c error     ",M,y);}else r[C]("error     ",y);if(F)if(f.nextState){var _="color: "+f.nextState(w)+"; font-weight: bold";r[F]("%c next state",_,w);}else r[F]("next state",w);l&&b(h,w,r,k);try{r.groupEnd();}catch(e){r.log(" log end ");}});}function S(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=Object.assign({},L,e),r=t.logger,n=t.stateTransformer,o=t.errorTransformer,i=t.predicate,a=t.logErrors,f=t.diffPredicate;if("undefined"==typeof r)return function(){return function(e){return function(t){return e(t)}}};if(e.getState&&e.dispatch)return console.error("[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n// Logger with default options\nimport { logger } from 'redux-logger'\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n// Or you can create your own logger with custom options http://bit.ly/redux-logger-options\nimport createLogger from 'redux-logger'\nconst logger = createLogger({\n  // ...options\n});\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n"),function(){return function(e){return function(t){return e(t)}}};var u=[];return function(e){var r=e.getState;return function(e){return function(l){if("function"==typeof i&&!i(r,l))return e(l);var c={};u.push(c),c.started=O.now(),c.startedTime=new Date,c.prevState=n(r()),c.action=l;var s=void 0;if(a)try{s=e(l);}catch(e){c.error=o(e);}else s=e(l);c.took=O.now()-c.started,c.nextState=n(r());var d=t.diff&&"function"==typeof f?f(r,l):t.diff;if(x(u,Object.assign({},t,{diff:d})),u.length=0,c.error)throw c.error;return s}}}}var k,j,E=function(e,t){return new Array(t+1).join(e)},A=function(e,t){return E("0",t-e.toString().length)+e},D=function(e){return A(e.getHours(),2)+":"+A(e.getMinutes(),2)+":"+A(e.getSeconds(),2)+"."+A(e.getMilliseconds(),3)},O="undefined"!=typeof performance&&null!==performance&&"function"==typeof performance.now?performance:Date,N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},P=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},C=[];k="object"===("undefined"==typeof commonjsGlobal?"undefined":N(commonjsGlobal))&&commonjsGlobal?commonjsGlobal:"undefined"!=typeof window?window:{},j=k.DeepDiff,j&&C.push(function(){"undefined"!=typeof j&&k.DeepDiff===c&&(k.DeepDiff=j,j=void 0);}),t(n,r),t(o,r),t(i,r),t(a,r),Object.defineProperties(c,{diff:{value:c,enumerable:!0},observableDiff:{value:l,enumerable:!0},applyDiff:{value:h,enumerable:!0},applyChange:{value:d,enumerable:!0},revertChange:{value:g,enumerable:!0},isConflict:{value:function(){return"undefined"!=typeof j},enumerable:!0},noConflict:{value:function(){return C&&(C.forEach(function(e){e();}),C=null),c},enumerable:!0}});var F={E:{color:"#2196F3",text:"CHANGED:"},N:{color:"#4CAF50",text:"ADDED:"},D:{color:"#F44336",text:"DELETED:"},A:{color:"#2196F3",text:"ARRAY:"}},L={level:"log",logger:console,logErrors:!0,collapsed:void 0,predicate:void 0,duration:!1,timestamp:!0,stateTransformer:function(e){return e},actionTransformer:function(e){return e},errorTransformer:function(e){return e},colors:{title:function(){return"inherit"},prevState:function(){return"#9E9E9E"},action:function(){return"#03A9F4"},nextState:function(){return"#4CAF50"},error:function(){return"#F20404"}},diff:!1,diffPredicate:void 0,transformer:void 0},T=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.dispatch,r=e.getState;return"function"==typeof t||"function"==typeof r?S()({dispatch:t,getState:r}):void console.error("\n[redux-logger v3] BREAKING CHANGE\n[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.\n[redux-logger v3] Change\n[redux-logger v3] import createLogger from 'redux-logger'\n[redux-logger v3] to\n[redux-logger v3] import { createLogger } from 'redux-logger'\n")};e.defaults=L,e.createLogger=S,e.logger=T,e.default=T,Object.defineProperty(e,"__esModule",{value:!0});});
	});

	var logger = unwrapExports(reduxLogger);

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var defineProperty = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

	var _extends$4 = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};

	var JVReducers = {
		'ADD_JV_FORM_ELEMENT': function ADD_JV_FORM_ELEMENT(state, action) {
			return state.map(function (queue) {
				if (queue.id == action.queueId) {
					return _extends$4({}, queue, { jvStopValues: [].concat(toConsumableArray(queue.jvStopValues.splice(0, action.index + 1)), [{ start: 0, end: 0, scanRate: 0.1 }], toConsumableArray(queue.jvStopValues.splice(0))) });
				}
				return queue;
			});
		},

		'REMOVE_JV_FORM_ELEMENT': function REMOVE_JV_FORM_ELEMENT(state, action) {
			return state.map(function (queue) {
				if (queue.id == action.queueId) {
					return _extends$4({}, queue, { jvStopValues: queue.jvStopValues.filter(function (val, index) {
							return index !== action.index;
						}) });
				}
				return queue;
			});
		},

		'CHANGE_JV_FORM_ELEMENT': function CHANGE_JV_FORM_ELEMENT(state, action) {

			return state.map(function (queue) {

				if (queue.id !== action.queueId) {
					return queue;
				}

				return _extends$4({}, queue, { jvStopValues: queue.jvStopValues.map(function (element, index) {

						var copyElement = Object.assign({}, element);

						if (index !== action.index) {
							return copyElement;
						}

						switch (action.fieldName) {
							case 'fromV':
								copyElement.start = action.newValue;
								break;

							case 'toV':
								copyElement.end = action.newValue;
								break;

							case 'scanRate':
								copyElement.scanRate = action.newValue;
								break;
						}

						return copyElement;
					}) });
			});
		}
	};

	var MPPTReducers = {

		MPPT_CHANGE_DURATION: function MPPT_CHANGE_DURATION(state, action) {
			return state.map(function (queue) {
				if (queue.id == action.index) {
					return Object.assign({}, queue, { duration: action.value });
				}
				return queue;
			});
		},

		MPPT_CHANGE_DURATION_UNIT: function MPPT_CHANGE_DURATION_UNIT(state, action) {
			return state.map(function (queue) {
				if (queue.id == action.index) {
					return Object.assign({}, queue, { durationUnit: action.value });
				}
				return queue;
			});
		},

		MPPT_CHANGE_STEP_SIZE: function MPPT_CHANGE_STEP_SIZE(state, action) {
			return state.map(function (queue) {
				if (queue.id == action.index) {
					return Object.assign({}, queue, { stepSize: action.value });
				}
				return queue;
			});
		}
	};

	var QueueReducers = _extends$4({}, MPPTReducers, JVReducers);

	var ChannelsViewDataReducers = {

		CHANNELS_VIEWDATA_TOGGLE: function CHANNELS_VIEWDATA_TOGGLE(state, action) {

			if (action.force !== undefined) {

				if (action.force) {

					if (state.indexOf(action.chanId) > -1) {
						return state;
					} else {
						return [].concat(toConsumableArray(state), [action.chanId]);
					}
				} else {

					if (state.indexOf(action.chanId) > -1) {
						return state.filter(function (el) {
							return el !== action.chanId;
						});
					} else {
						return state;
					}
				}
			}

			if (state.indexOf(action.chanId) > -1) {

				return [].concat(toConsumableArray(state.splice(0, state.indexOf(action.chanId))), toConsumableArray(state.splice(1)));
			} else {

				return [].concat(toConsumableArray(state), [action.chanId]);
			}
		}
	};

	var JVViewDataReducers = {

		JV_VIEWDATA_TOGGLE: function JV_VIEWDATA_TOGGLE(state, action) {

			if (action.force !== undefined) {

				if (action.force) {

					if (state.indexOf(action.jvId) > -1) {
						return state;
					} else {
						return [].concat(toConsumableArray(state), [action.jvId]);
					}
				} else {

					if (state.indexOf(action.jvId) > -1) {
						return state.filter(function (el) {
							return el !== action.jvId;
						});
					} else {
						return state;
					}
				}
			}

			if (state.indexOf(action.jvId) > -1) {

				return state.filter(function (jv) {
					return jv !== action.jvId;
				});
			} else {

				return [].concat(toConsumableArray(state), [action.jvId]);
			}
		}
	};

	var ViewDataReducer = {

		DATA_RECEIVED: function DATA_RECEIVED(state, action) {
			var copiedState = [].concat(toConsumableArray(state));

			copiedState[action.queueId] = [].concat(toConsumableArray(copiedState[action.queueId] || []), [action.data]);
			return copiedState;
		}
	};

	var allChannels = [{ chanId: 1 }, { chanId: 2 }, { chanId: 3 }, { chanId: 4 }, { chanId: 5 }, { chanId: 6 }, { chanId: 7 }, { chanId: 8 }, { chanId: 9 }, { chanId: 10 }];

	var changeItemInArray = function changeItemInArray(haystack, key, keyValue, field, fieldValue) {

		if (haystack.filter(function (haystackEl) {
			return haystackEl[key] == keyValue;
		}).length == 0) {

			haystack = [].concat(toConsumableArray(haystack), [defineProperty({}, key, keyValue)]);
			return haystack;
		}

		return haystack.map(function (haystackEl) {

			if (haystackEl[key] !== keyValue) {
				return haystackEl;
			}

			haystackEl[field] = fieldValue;
			return haystackEl;
		});
	};

	var ChannelsReducers = {

		CHANNELS_LIST_CHANGE: function CHANNELS_LIST_CHANGE(state, action) {

			return changeItemInArray(state, 'chanId', action.chanId, action.field, action.value);
		},

		CHANNELS_CHANGE_STATE: function CHANNELS_CHANGE_STATE(state, action) {

			return state.map(function (queue) {
				if (queue.id == action.index) {
					return Object.assign({}, queue, { state: action.newState });
				}
				return queue;
			});
		}
	};

	var ReducedAppState = combineReducers({

		param1Name: function param1Name(state, action) {

			if (state === undefined) {
				return null;
			}

			if (action.type == 'CHANGE_PARAM_NAME' && action.paramId == 1) {
				return action.newValue;
			}

			return state;
		},

		param2Name: function param2Name(state, action) {

			if (state === undefined) {
				return null;
			}

			if (action.type == 'CHANGE_PARAM_NAME' && action.paramId == 2) {
				return action.newValue;
			}

			return state;
		},

		channelsView: function channelsView(state, action) {

			if (state === undefined) {
				return false;
			}

			if (action.type == 'CHANNELS_VIEWCONFIG_TOGGLE') {
				return !state;
			}

			return state;
		}

	});

	var measurementActions = [{
		type: 'JV',
		name: 'J(V) curve',
		defaults: {
			jvStopValues: [{ start: 0, end: 1, scanRate: 0.2 }]

		}
	}, {
		type: 'MPPT',
		name: 'MPP tracking',
		defaults: {
			duration: 15,
			durationUnit: 60,
			stepSize: 1
		}
	}, {
		type: 'TCPControl',
		name: 'TCP/IP request',
		defaults: {}
	}];

	var QUEUE_ADD_ELEMENT = 'QUEUE_ADD_ELEMENT';
	var QUEUE_REMOVE_ELEMENT = 'QUEUE_REMOVE_SELECTED_ELEMENT';
	var QUEUE_REMOVE_ELEMENT_SAFE = 'QUEUE_REMOVE_SELECTED_ELEMENT_SAFE';
	var QUEUE_SELECT_ELEMENT = 'QUEUE_SELECT_ELEMENT';

	function queueAddElement(id, type, name, defaults$$1) {
		return {
			type: QUEUE_ADD_ELEMENT,
			newElement: _extends$4({
				id: id,
				type: type,
				name: name
			}, defaults$$1)
		};
	}

	function queueRemoveElement(preset, index) {
		return {
			type: QUEUE_REMOVE_ELEMENT,
			preset: preset,
			index: index
		};
	}

	function queueRemoveElementSafe(preset, index) {
		return {
			type: QUEUE_REMOVE_ELEMENT_SAFE,
			preset: preset,
			index: index
		};
	}

	function queueSelectElement(index) {
		return {
			type: QUEUE_SELECT_ELEMENT,
			index: index
		};
	}

	function createReducer(initialState, handlers) {

		return function reducer() {
			var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
			var action = arguments[1];


			if (handlers.hasOwnProperty(action.type)) {

				return handlers[action.type](state, action);
			} else {

				return state;
			}
		};
	}

	function queueAddElement$1(state, action) {
		var stateCopy = [].concat(toConsumableArray(state));
		stateCopy.push(Object.assign({}, action.newElement, { removableSafe: false }));
		return stateCopy;
	}

	function queueRemoveElement$1(state, action) {
		return [].concat(toConsumableArray(state)).filter(function (el) {
			return el.id !== action.id;
		});
	}

	function queueRemoveElementSafe$1(state, action) {

		return [].concat(toConsumableArray(state)).map(function (el) {

			if (el.id == action.id) {
				return Object.assign({}, el, { removableSafe: true });
			}

			return el;
		});
	}

	var app = combineReducers({

		queue: createReducer([_extends$4({}, measurementActions[0], measurementActions[0].defaults)], _extends$4({
			QUEUE_ADD_ELEMENT: queueAddElement$1,
			QUEUE_REMOVE_ELEMENT: queueRemoveElement$1,
			QUEUE_REMOVE_ELEMENT_SAFE: queueRemoveElementSafe$1
		}, QueueReducers)),

		currentQueueElement: createReducer(null, {
			QUEUE_SELECT_ELEMENT: function QUEUE_SELECT_ELEMENT$$1(state, action) {
				return action.index;
			}
		}),

		sunIntensity: createReducer(100, {
			SUN_CHANGE_INTENSITY: function SUN_CHANGE_INTENSITY(state, action) {
				return action.newValue;
			}
		}),

		channels: createReducer(allChannels.map(function (chan) {
			return { chanId: chan.chanId, name: '', param1: '', param2: '', area: 0.1 };
		}), ChannelsReducers),

		viewData: combineReducers({
			channels: createReducer([], ChannelsViewDataReducers),
			jvs: createReducer([], JVViewDataReducers),
			data: createReducer([], ViewDataReducer)
		}),

		appState: ReducedAppState

	});

	var changeSunIntensity = function changeSunIntensity(newValue) {

		return {
			type: 'SUN_CHANGE_INTENSITY',
			newValue: newValue
		};
	};

	var ChangeParamName = function ChangeParamName(paramId, paramValue) {

		return {
			type: 'CHANGE_PARAM_NAME',
			paramId: paramId,
			newValue: paramValue
		};
	};

	var Queue = function Queue(_ref) {
		var queueElements = _ref.queueElements,
		    selectedElement = _ref.selectedElement,
		    selectElement = _ref.selectElement,
		    removeElement = _ref.removeElement,
		    removeElementConfirm = _ref.removeElementConfirm,
		    addElement = _ref.addElement,
		    changeAddElementType = _ref.changeAddElementType,
		    upElement = _ref.upElement,
		    downElement = _ref.downElement,
		    sunIntensity = _ref.sunIntensity,
		    changeSunIntensity = _ref.changeSunIntensity;


		//let this = this;

		return react.createElement(
			'div',
			null,
			react.createElement(
				'ul',
				{ className: 'list-group' },
				queueElements.map(function (element, index) {
					return react.createElement(
						'li',
						{ onClick: function onClick() {
								return selectElement(index);
							}, className: 'list-group-item ' + (selectedElement == index ? 'active' : '') },
						index + 1,
						'. ',
						element.name,
						react.createElement(
							'div',
							{ className: 'pull-right btn-group' },
							react.createElement(
								'button',
								{ className: 'btn btn-sm btn-default', disabled: index == 0, onClick: upElement },
								react.createElement('span', { className: 'glyphicon glyphicon-arrow-up' })
							),
							react.createElement(
								'button',
								{ className: 'btn btn-sm btn-default', disabled: index == queueElements.length - 1, onClick: downElement },
								react.createElement('span', { className: 'glyphicon glyphicon-arrow-down' })
							),
							element.removableSafe ? react.createElement(
								'button',
								{ className: 'btn btn-sm btn-primary', onClick: removeElementConfirm },
								'Confirm deletion'
							) : react.createElement(
								'button',
								{ className: 'btn btn-sm btn-danger', onClick: removeElement },
								react.createElement('span', { className: 'glyphicon glyphicon-remove' })
							)
						)
					);
				})
			),
			react.createElement(
				'div',
				{ className: '' },
				'Add an action:',
				react.createElement(
					'div',
					{ className: 'input-group' },
					react.createElement(
						'select',
						{ className: 'form-control', onChange: changeAddElementType },
						react.createElement(
							'option',
							{ value: 'null' },
							'Select an action'
						),
						measurementActions.map(function (action) {
							return react.createElement(
								'option',
								{ value: action.type },
								action.name
							);
						})
					),
					react.createElement(
						'span',
						{ 'class': 'input-group-btn' },
						react.createElement(
							'button',
							{ className: 'btn btn-primary', onClick: addElement },
							'+ Add'
						)
					)
				)
			),
			react.createElement(
				'div',
				{ className: '' },
				'Sun intensity:',
				react.createElement(
					'div',
					{ className: 'input-group' },
					react.createElement('input', { type: 'number', value: sunIntensity, className: 'form-control', onChange: changeSunIntensity }),
					react.createElement(
						'span',
						{ className: 'input-group-addon' },
						' mW cm',
						react.createElement(
							'sup',
							null,
							'-2'
						)
					)
				)
			)
		);
	};

	Queue.propTypes = {

		queueElements: propTypes.arrayOf(propTypes.shape({ name: propTypes.string.isRequired })),
		selectedElement: propTypes.number,
		selectElement: propTypes.func.isRequired,
		removeElement: propTypes.func.isRequired,
		removeElementConfirm: propTypes.func.isRequired,
		addElement: propTypes.func.isRequired,
		changeAddElementType: propTypes.func.isRequired,
		upElement: propTypes.func.isRequired,
		downElement: propTypes.func.isRequired,
		changeSunIntensity: propTypes.func.isRequired,
		sunIntensity: propTypes.number.isRequired
	};

	var elementType = null;

	var mapDispatchToProps = function mapDispatchToProps(dispatch) {

		return {

			removeElementConfirm: function removeElementConfirm(id) {
				dispatch(queueRemoveElement(id));
			},

			removeElement: function removeElement(id) {
				dispatch(queueRemoveElementSafe(id));
			},

			addElement: function addElement() {
				if (elementType !== null) {
					var details = measurementActions.filter(function (el) {
						return el.type == elementType;
					})[0];
					dispatch(queueAddElement(Date.now(), elementType, details.name, details.defaults));
				}
			},
			upElement: function upElement() {},

			downElement: function downElement() {},

			selectElement: function selectElement(id) {
				dispatch(queueSelectElement(id));
			},

			changeSunIntensity: function changeSunIntensity$$1(val) {
				dispatch(changeSunIntensity(val));
			}
		};
	};

	var mapStateToProps = function mapStateToProps(state) {

		return {
			queueElements: state.queue,
			selectedElement: state.currentQueueElement,

			changeAddElementType: function changeAddElementType(e) {
				elementType = e.target.value;
			},

			sunIntensity: state.sunIntensity
		};
	};

	var QueueWrapper = connect(mapStateToProps, mapDispatchToProps)(Queue);

	var MPPT_CHANGE_DURATION = 'MPPT_CHANGE_DURATION';
	var MPPT_CHANGE_DURATION_UNIT = 'MPPT_CHANGE_DURATION_UNIT';
	var MPPT_CHANGE_STEP_SIZE = 'MPPT_CHANGE_STEP_SIZE';

	function MPPTChangeDuration(value, index) {
		return {
			type: MPPT_CHANGE_DURATION,
			index: index,
			value: value
		};
	}

	function MPPTChangeDurationUnit(value, index) {
		return {
			type: MPPT_CHANGE_DURATION_UNIT,
			index: index,
			value: value
		};
	}

	function MPPTChangeStepSize(value, index) {
		return {
			type: MPPT_CHANGE_STEP_SIZE,
			index: index,
			value: value
		};
	}

	var MPPTForm = function MPPTForm(_ref) {
		var duration = _ref.duration,
		    durationUnit = _ref.durationUnit,
		    stepSize = _ref.stepSize,
		    id = _ref.id,
		    changeDuration = _ref.changeDuration,
		    changeDurationUnit = _ref.changeDurationUnit,
		    changeStepSize = _ref.changeStepSize;


		return react.createElement(
			'form',
			{ className: 'form-horizontal' },
			react.createElement(
				'div',
				{ className: 'form-group' },
				react.createElement(
					'div',
					{ className: 'col-sm-3' },
					react.createElement(
						'label',
						null,
						'Duration'
					)
				),
				react.createElement(
					'div',
					{ className: 'col-sm-9' },
					react.createElement(
						'div',
						{ className: 'input-group' },
						react.createElement('input', { name: 'duration', type: 'number', className: 'form-control', value: duration, onChange: function onChange(e) {
								return changeDuration(e.target.value, id);
							} }),
						react.createElement(
							'div',
							{ className: 'input-group-btn' },
							react.createElement(
								'button',
								{ type: 'button', className: 'btn btn-default dropdown-toggle', 'data-toggle': 'dropdown', 'aria-haspopup': 'true', 'aria-expanded': 'false' },
								durationUnit == '1' ? 'Seconds' : durationUnit == '60' ? 'Minutes' : 'Hours',
								' ',
								react.createElement('span', { 'class': 'caret' })
							),
							react.createElement(
								'ul',
								{ 'class': 'dropdown-menu dropdown-menu-right' },
								react.createElement(
									'li',
									{ value: '1', onClick: function onClick(e) {
											changeDurationUnit(1, id);
										} },
									react.createElement(
										'a',
										{ href: '#' },
										'Seconds'
									)
								),
								react.createElement(
									'li',
									{ value: '60', onClick: function onClick(e) {
											changeDurationUnit(60, id);
										} },
									react.createElement(
										'a',
										{ href: '#' },
										'Minutes'
									)
								),
								react.createElement(
									'li',
									{ value: '3600', onClick: function onClick(e) {
											changeDurationUnit(3600, id);
										} },
									react.createElement(
										'a',
										{ href: '#' },
										'Hours'
									)
								)
							)
						)
					)
				)
			),
			react.createElement(
				'div',
				{ className: 'form-group' },
				react.createElement(
					'div',
					{ className: 'col-sm-3' },
					react.createElement(
						'label',
						null,
						'Step size'
					)
				),
				react.createElement(
					'div',
					{ className: 'col-sm-9' },
					react.createElement(
						'select',
						{ name: 'durationUnit', className: 'form-control', value: stepSize, onChange: function onChange(e) {
								return changeStepSize(e.target.value, id);
							} },
						react.createElement(
							'option',
							{ value: '1' },
							'1 mV'
						),
						react.createElement(
							'option',
							{ value: '2' },
							'2 mV'
						),
						react.createElement(
							'option',
							{ value: '3' },
							'3 mV'
						)
					)
				)
			)
		);
	};

	MPPTForm.propTypes = {
		duration: propTypes.number.isRequired,
		durationUnit: propTypes.number.isRequired,
		id: propTypes.number.isRequired,
		stepSize: propTypes.number.isRequired,
		changeDuration: propTypes.func.isRequired,
		changeDurationUnit: propTypes.func.isRequired,
		changeStepSize: propTypes.func.isRequired
	};

	var mapDispatchToProps$1 = function mapDispatchToProps(dispatch) {

		return {

			changeDuration: function changeDuration(newDuration, queueId) {
				dispatch(MPPTChangeDuration(newDuration, queueId));
			},

			changeDurationUnit: function changeDurationUnit(newDurationUnit, queueId) {
				dispatch(MPPTChangeDurationUnit(newDurationUnit, queueId));
			},

			changeStepSize: function changeStepSize(newStepSize, queueId) {
				dispatch(MPPTChangeStepSize(newStepSize, queueId));
			}
		};
	};

	var mapStateToProps$1 = function mapStateToProps(state) {
		return {};
	};

	var MPPTWrapper = connect(mapStateToProps$1, mapDispatchToProps$1)(MPPTForm);

	function ChannelsChangeChan(chanId, field, value) {
		return {
			type: 'CHANNELS_LIST_CHANGE',
			chanId: chanId,
			field: field,
			value: value
		};
	}

	function ChannelsToggleViewData(chanId, force) {
		return {
			type: 'CHANNELS_VIEWDATA_TOGGLE',
			chanId: chanId,
			force: force
		};
	}
	function ChannelsToggleViewConfig() {
		return {
			type: 'CHANNELS_VIEWCONFIG_TOGGLE'
		};
	}

	var ChannelControl = function ChannelControl(_ref) {
		var id = _ref.id,
		    channels = _ref.channels,
		    state = _ref.state,
		    changeChannel = _ref.changeChannel,
		    changeChannelState = _ref.changeChannelState,
		    channelsAvailable = _ref.channelsAvailable,
		    _ref$param1Name = _ref.param1Name,
		    param1Name = _ref$param1Name === undefined ? "Param 1" : _ref$param1Name,
		    _ref$param2Name = _ref.param2Name,
		    param2Name = _ref$param2Name === undefined ? "Param 2" : _ref$param2Name,
		    changeParam1Name = _ref.changeParam1Name,
		    changeParam2Name = _ref.changeParam2Name,
		    buttonView = _ref.buttonView,
		    viewState = _ref.viewState,
		    toggleViewState = _ref.toggleViewState;


		return react.createElement(
			'div',
			null,
			buttonView && react.createElement(
				'button',
				{ className: 'btn btn-default', onClick: toggleViewState },
				viewState ? 'Hide channel configuration' : 'View channel configuration'
			),
			react.createElement(
				'form',
				{ className: "form" + (viewState ? ' visible' : ' hidden') },
				react.createElement(
					'div',
					{ className: 'form-group' },
					react.createElement(
						'div',
						{ className: 'col-sm-3' },
						react.createElement(
							'div',
							{ className: 'form-group' },
							react.createElement(
								'label',
								null,
								'Parameter 1'
							),
							react.createElement('input', { className: 'form-control', value: param1Name, onChange: changeParam1Name })
						),
						react.createElement(
							'div',
							{ className: 'form-group' },
							react.createElement(
								'label',
								null,
								'Parameter 2'
							),
							react.createElement('input', { className: 'form-control', value: param2Name, onChange: changeParam2Name })
						)
					),
					react.createElement(
						'div',
						{ className: 'col-sm-9' },
						react.createElement(
							'table',
							null,
							react.createElement(
								'tr',
								null,
								react.createElement('th', null),
								react.createElement(
									'th',
									null,
									'Sample name'
								),
								react.createElement(
									'th',
									null,
									'Sample ID'
								),
								react.createElement(
									'th',
									null,
									'Active area (cm',
									react.createElement(
										'sup',
										null,
										'2'
									),
									')'
								),
								react.createElement(
									'th',
									null,
									param1Name || "Parameter 1"
								),
								react.createElement(
									'th',
									null,
									param2Name || "Parameter 2"
								)
							),
							channels.map(function (chan) {
								return react.createElement(
									'tr',
									null,
									react.createElement(
										'td',
										null,
										react.createElement(
											'div',
											{ className: 'checkbox' },
											react.createElement('input', { type: 'checkbox', checked: chan.active, onClick: function onClick(e) {
													return changeChannel(chan.chanId, 'active', e.target.checked);
												} })
										)
									),
									react.createElement(
										'td',
										null,
										react.createElement('input', { className: 'form-control', type: 'text', onChange: function onChange(e) {
												return changeChannel(chan.chanId, 'name', e.target.value);
											}, value: chan.name })
									),
									react.createElement(
										'td',
										null,
										react.createElement('input', { className: 'form-control', type: 'text', onChange: function onChange(e) {
												return changeChannel(chan.chanId, 'id', e.target.value);
											}, value: chan.id })
									),
									react.createElement(
										'td',
										null,
										react.createElement(
											'div',
											{ className: 'input-group' },
											react.createElement('input', { type: 'number', className: 'form-control', onChange: function onChange(e) {
													return changeChannel(chan.chanId, 'area', parseFloat(e.target.value));
												}, value: chan.area }),
											react.createElement(
												'span',
												{ className: 'input-group-addon' },
												'cm',
												react.createElement(
													'sup',
													null,
													'2'
												)
											)
										)
									),
									react.createElement(
										'td',
										null,
										react.createElement('input', { className: 'form-control', type: 'text', onChange: function onChange(e) {
												return changeChannel(chan.chanId, 'param1', e.target.value);
											}, value: chan.param1 })
									),
									react.createElement(
										'td',
										null,
										react.createElement('input', { className: 'form-control', type: 'text', onChange: function onChange(e) {
												return changeChannel(chan.chanId, 'param2', e.target.value);
											}, value: chan.param2 })
									)
								);
							})
						)
					)
				)
			)
		);
	};

	ChannelControl.propTypes = {
		id: propTypes.number.isRequired,
		channels: propTypes.array.isRequired,
		state: propTypes.number.isRequired,
		changeChannel: propTypes.func.isRequired,
		changeChannelState: propTypes.func.isRequired,
		param1Name: propTypes.string,
		param2Name: propTypes.string
	};

	var mapDispatchToProps$2 = function mapDispatchToProps(dispatch) {

		return {

			changeChannel: function changeChannel(chanId, field, value) {
				dispatch(ChannelsChangeChan(chanId, field, value));
			},

			toggleViewState: function toggleViewState() {
				dispatch(ChannelsToggleViewConfig());
			},

			changeParam1Name: function changeParam1Name(e) {
				dispatch(ChangeParamName(1, e.target.value));
			},

			changeParam2Name: function changeParam2Name(e) {
				dispatch(ChangeParamName(2, e.target.value));
			}
		};
	};

	var mapStateToProps$2 = function mapStateToProps(state, ownProps) {
		return {
			channelsAvailable: allChannels,
			channels: state.channels,
			param1Name: state.appState.param1Name,
			param2Name: state.appState.param2Name,
			buttonView: ownProps.buttonView,
			viewState: state.appState.channelsView
		};
	};

	var ChanControlWrapper = connect(mapStateToProps$2, mapDispatchToProps$2)(ChannelControl);

	var ADD_JV_FORM_ELEMENT = 'ADD_JV_FORM_ELEMENT';
	var REMOVE_JV_FORM_ELEMENT = 'REMOVE_JV_FORM_ELEMENT';
	var CHANGE_JV_FORM_ELEMENT = 'CHANGE_JV_FORM_ELEMENT';

	function AddJVElement(index, queueId) {
		return {
			type: ADD_JV_FORM_ELEMENT,
			index: index,
			queueId: queueId
		};
	}

	function RemoveJVElement(index, queueId) {
		return {
			type: REMOVE_JV_FORM_ELEMENT,
			index: index,
			queueId: queueId
		};
	}

	function ChangeJVElement(index, fieldName, newValue, queueId) {
		return {
			type: CHANGE_JV_FORM_ELEMENT,
			fieldName: fieldName,
			newValue: newValue,
			index: index,
			queueId: queueId
		};
	}

	function JVToggleViewData(jvId, force) {
		return {
			type: 'JV_VIEWDATA_TOGGLE',
			jvId: jvId,
			force: force
		};
	}

	var JVFromToElement = function JVFromToElement(_ref) {
		var onChange = _ref.onChange,
		    id = _ref.id,
		    fromV = _ref.fromV,
		    toV = _ref.toV,
		    scanRate = _ref.scanRate,
		    addElement = _ref.addElement,
		    removeElement = _ref.removeElement;
		return react.createElement(
			'div',
			{ className: 'row top-buffer' },
			react.createElement(
				'div',
				{ className: 'col-sm-3' },
				react.createElement(
					'div',
					{ className: 'input-group' },
					react.createElement('input', { className: 'form-control', value: fromV, name: 'fromV', onChange: onChange }),
					react.createElement(
						'span',
						{ className: 'input-group-addon' },
						' V '
					)
				)
			),
			react.createElement(
				'div',
				{ className: 'col-sm-3' },
				react.createElement(
					'div',
					{ className: 'input-group' },
					react.createElement('input', { className: 'form-control', value: toV, name: 'toV', onChange: onChange }),
					react.createElement(
						'span',
						{ className: 'input-group-addon' },
						' V '
					)
				)
			),
			react.createElement(
				'div',
				{ className: 'col-sm-3' },
				react.createElement(
					'div',
					{ className: 'input-group' },
					react.createElement('input', { className: 'form-control', value: scanRate, name: 'scanRate', onChange: onChange }),
					react.createElement(
						'span',
						{ className: 'input-group-addon' },
						' V/s '
					)
				)
			),
			react.createElement(
				'div',
				{ className: 'col-sm-3' },
				react.createElement(
					'div',
					{ className: 'btn-group' },
					react.createElement(
						'button',
						{ className: 'btn btn-default', type: 'button', onClick: addElement },
						'+'
					),
					id > 0 ? react.createElement(
						'button',
						{ className: 'btn btn-default', type: 'button', onClick: removeElement },
						'-'
					) : null
				)
			)
		);
	};

	JVFromToElement.propTypes = {
		onChange: propTypes.func.isRequired,
		id: propTypes.number.isRequired,
		fromV: propTypes.number.isRequired,
		toV: propTypes.number.isRequired,
		scanRate: propTypes.number.isRequired,
		addElement: propTypes.func.isRequired,
		removeElement: propTypes.func.isRequired
	};

	var JVForm = function JVForm(_ref) {
		var jvStopValues = _ref.jvStopValues,
		    changeElement = _ref.changeElement,
		    _addElement = _ref.addElement,
		    _removeElement = _ref.removeElement,
		    id = _ref.id;


		return react.createElement(
			'form',
			{ className: '' },
			react.createElement(
				'div',
				{ className: 'row top-buffer' },
				react.createElement(
					'div',
					{ className: 'col-sm-3' },
					react.createElement(
						'label',
						null,
						'Starting voltage'
					)
				),
				react.createElement(
					'div',
					{ className: 'col-sm-3' },
					react.createElement(
						'label',
						null,
						'Ending voltage'
					)
				),
				react.createElement(
					'div',
					{ className: 'col-sm-3' },
					react.createElement(
						'label',
						null,
						'Scan rate'
					)
				)
			),
			jvStopValues.map(function (fromTo, index) {

				return react.createElement(JVFromToElement, {
					key: index,
					id: index,
					fromV: fromTo.start,
					toV: fromTo.end,
					scanRate: fromTo.scanRate,
					addElement: function addElement() {
						return _addElement(index, id);
					},
					removeElement: function removeElement() {
						return _removeElement(index, id);
					},
					onChange: function onChange(e) {
						changeElement(index, e.target.name, e.target.value, id);
					}
				});
			})
		);
	};

	JVForm.propTypes = {
		jvStopValues: propTypes.arrayOf(propTypes.shape({
			start: propTypes.number,
			end: propTypes.number,
			scanRate: propTypes.number
		}).isRequired).isRequired,
		onChange: propTypes.func.isRequired,
		removeFromTo: propTypes.func.isRequired,
		addFromTo: propTypes.func.isRequired
	};

	var mapDispatchToProps$3 = function mapDispatchToProps(dispatch) {

		return {

			addElement: function addElement(id, queueId) {
				dispatch(AddJVElement(id, queueId));
			},

			removeElement: function removeElement(id, queueId) {
				dispatch(RemoveJVElement(id, queueId));
			},

			changeElement: function changeElement(id, name, newValue, queueId) {
				dispatch(ChangeJVElement(id, name, newValue, queueId));
			}

		};
	};

	var mapStateToProps$3 = function mapStateToProps(state) {

		return {};
	};

	var JVWrapper = connect(mapStateToProps$3, mapDispatchToProps$3)(JVForm);

	var mapStateToProps$4 = function mapStateToProps(state) {
		return {
			queueElement: state.queue[state.currentQueueElement]
		};
	};

	var QueueConfigElement = function QueueConfigElement(_ref) {
		var dispatch = _ref.dispatch,
		    queueElement = _ref.queueElement;


		if (!queueElement) {
			return null;
		}

		return react.createElement(
			'div',
			{ className: 'col-sm-8' },
			function () {

				switch (queueElement.type) {

					case 'JV':
						return react.createElement(JVWrapper, queueElement);
						break;

					case 'MPPT':
						return react.createElement(MPPTWrapper, queueElement);
						break;

				}
			}()
		);
	};

	var QueueConfigElement$1 = connect(mapStateToProps$4)(QueueConfigElement);

	var jsgraph = createCommonjsModule(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
		module.exports = factory();
	})(typeof self !== 'undefined' ? self : commonjsGlobal, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId]) {
	/******/ 			return installedModules[moduleId].exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			i: moduleId,
	/******/ 			l: false,
	/******/ 			exports: {}
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.l = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// define getter function for harmony exports
	/******/ 	__webpack_require__.d = function(exports, name, getter) {
	/******/ 		if(!__webpack_require__.o(exports, name)) {
	/******/ 			Object.defineProperty(exports, name, {
	/******/ 				configurable: false,
	/******/ 				enumerable: true,
	/******/ 				get: getter
	/******/ 			});
	/******/ 		}
	/******/ 	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/ 	__webpack_require__.n = function(module) {
	/******/ 		var getter = module && module.__esModule ?
	/******/ 			function getDefault() { return module['default']; } :
	/******/ 			function getModuleExports() { return module; };
	/******/ 		__webpack_require__.d(getter, 'a', getter);
	/******/ 		return getter;
	/******/ 	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(__webpack_require__.s = 144);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var core = __webpack_require__(22);
	var hide = __webpack_require__(13);
	var redefine = __webpack_require__(14);
	var ctx = __webpack_require__(19);
	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if (target) redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;


	/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(4);
	module.exports = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};


	/***/ }),
	/* 2 */
	/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


	/***/ }),
	/* 3 */
	/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};


	/***/ }),
	/* 4 */
	/***/ (function(module, exports) {

	module.exports = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};


	/***/ }),
	/* 5 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.setAttributeTo = setAttributeTo;
	  exports.mapEventEmission = mapEventEmission;
	  exports.guid = guid;
	  exports.throwError = throwError;
	  exports.warn = warn;
	  exports.isNumeric = isNumeric;
	  exports.hue2rgb = hue2rgb;
	  exports.hslToRgb = hslToRgb;
	  exports.saveDomAttributes = saveDomAttributes;
	  exports.hasSavedAttribute = hasSavedAttribute;
	  exports.overwriteDomAttribute = overwriteDomAttribute;
	  exports.restoreDomAttributes = restoreDomAttributes;
	  exports.debounce = debounce;
	  exports.SVGParser = SVGParser;
	  exports.reverseArray = reverseArray;
	  exports.getOffset = getOffset;
	  exports.setCSS = setCSS;
	  exports.ajaxGet = ajaxGet;
	  exports.extend = extend;
	  exports.mix = mix;
	  exports.emptyDom = emptyDom;

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  /**
	   * Easy set attribute method to apply to a SVG Element the attributes listed. Optional namespacing
	   * @param {SVGElement} to - The SVG element to apply the attributes to
	   * @param {Object<String,Any>} attr - A key/value hashmap of attributes
	   * @param {String} [ ns = undefined ] - The namespace to use (with <code>setAttributeNS</code>). Default if without namespacing
	   */
	  function setAttributeTo(to, params, ns) {
	    var i;

	    if (ns) {
	      for (i in params) {
	        to.setAttributeNS(ns, i, params[i]);
	      }
	    } else {
	      for (i in params) {
	        to.setAttribute(i, params[i]);
	      }
	    }
	  }

	  /**
	   * Maps old-style events defined within the creation (i.e. <code>{ onMouseOver: function() }</code>) to modern event listening <code>.on("mouseover")</code>
	   * The function will read any object and select the ones starting with "on"
	   * @params {Object} options - An option object to read the events from
	   * @param {Object} source - The source object to which the options belong
	   * @example util.mapEventEmission( this.options, this );
	   */
	  function mapEventEmission(options, source) {

	    if (!source) {
	      source = this;
	    }

	    var eventName;

	    for (var i in options) {

	      // Starts with onXXX
	      if (i.indexOf('on') == 0 && typeof options[i] == 'function') {
	        eventName = i.substring(2);
	        eventName = eventName.substring(0, 1).toLowerCase() + eventName.substring(1);

	        if (source.on) {

	          (function (j) {

	            source.on(eventName, function () {
	              options[j].apply(source, arguments);
	            });
	          })(i);
	        }
	      }
	    }
	  }

	  /**
	   * @link http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
	   * @return {String} a random id
	   */
	  function guid() {
	    //
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	      var r = Math.random() * 16 | 0,
	          v = c == 'x' ? r : r & 0x3 | 0x8;
	      return v.toString(16);
	    });
	  }

	  function throwError(message) {
	    console.error(message);
	  }

	  function warn(message) {
	    console.warn(message);
	  }

	  /**
	   * Checks if a variable is a numeric or not
	   * @return {Boolean} <code>true</code> for a numeric value, false otherwise
	   */
	  function isNumeric(obj) {
	    return !Array.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
	  }

	  /**
	   * @see http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
	   * Converts an HSL color value to RGB. Conversion formula
	   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	   * Assumes h, s, and l are contained in the set [0, 1] and
	   * returns r, g, and b in the set [0, 255].
	   *
	   * @param   Number  h       The hue
	   * @param   Number  s       The saturation
	   * @param   Number  l       The lightness
	   * @return  Array           The RGB representation
	   */
	  function hue2rgb(p, q, t) {
	    if (t < 0) t += 1;
	    if (t > 1) t -= 1;
	    if (t < 1 / 6) return p + (q - p) * 6 * t;
	    if (t < 1 / 2) return q;
	    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	    return p;
	  }

	  function hslToRgb(h, s, l) {
	    var r, g, b;

	    if (s == 0) {
	      r = g = b = l; // achromatic
	    } else {

	      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	      var p = 2 * l - q;
	      r = hue2rgb(p, q, h + 1 / 3);
	      g = hue2rgb(p, q, h);
	      b = hue2rgb(p, q, h - 1 / 3);
	    }

	    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
	  }

	  function saveDomAttributes(to, attributes, identification) {

	    if (!to) return;

	    to._savedAttributesIds = to._savedAttributesIds || [];

	    if (to._savedAttributesIds.indexOf(identification) > -1) {
	      restoreDomAttributes(to, identification);
	    }

	    to._savedAttributes = to._savedAttributes || {};
	    to._attributes = to._attributes || {};
	    to._attributes[identification] = attributes;

	    to._savedAttributesIds.push(identification);

	    for (var i in attributes) {

	      if (!to._savedAttributes[i]) {
	        to._savedAttributes[i] = to.getAttribute(i);
	      }

	      to.setAttribute(i, attributes[i]);
	    }
	  }

	  function hasSavedAttribute(dom, attr) {
	    return dom._savedAttributes && dom._savedAttributes[attr] !== undefined;
	  }

	  function overwriteDomAttribute(dom, attribute, newValue) {
	    if (hasSavedAttribute(dom, attribute)) {
	      dom._savedAttributes[attribute] = newValue;
	    }
	  }

	  function restoreDomAttributes(to, identification) {

	    if (!to || !to._savedAttributesIds) {
	      return;
	    }

	    to._savedAttributesIds.splice(to._savedAttributesIds.indexOf(identification), 1);
	    delete to._attributes[identification];

	    var attrs = {};

	    for (var i in to._savedAttributes) {
	      attrs[i] = to._savedAttributes[i];
	    }

	    for (var i = 0, l = to._savedAttributesIds.length; i < l; i++) {

	      for (var j in to._attributes[to._savedAttributesIds[i]]) {
	        attrs[j] = to._attributes[to._savedAttributesIds[i]][j];
	      }
	    }

	    for (var j in attrs) {
	      to.setAttribute(j, attrs[j]);
	    }
	  }

	  // https://davidwalsh.name/function-debounce
	  function debounce(func, wait, immediate) {
	    var timeout;
	    return function () {
	      var context = this,
	          args = arguments;
	      var later = function later() {
	        timeout = null;
	        if (!immediate) func.apply(context, args);
	      };
	      var callNow = immediate && !timeout;
	      clearTimeout(timeout);
	      timeout = setTimeout(later, wait);
	      if (callNow) func.apply(context, args);
	    };
	  }

	  function SVGParser(svgString) {

	    var parser = new DOMParser();
	    var doc = parser.parseFromString(svgString, 'image/svg+xml');
	    // returns a SVGDocument, which also is a Document.

	    return doc;
	  }

	  // http://stackoverflow.com/questions/5276953/what-is-the-most-efficient-way-to-reverse-an-array-in-javascript
	  function reverseArray(array) {
	    var left = null;
	    var right = null;
	    var length = array.length;
	    for (left = 0, right = length - 1; left < right; left += 1, right -= 1) {
	      var temporary = array[left];
	      array[left] = array[right];
	      array[right] = temporary;
	    }
	    return array;
	  }

	  // jQuery.fn.offset
	  function getOffset(el) {
	    var rect = el.getBoundingClientRect();
	    return {
	      top: rect.top,
	      left: rect.left
	    };
	  }

	  // jQuery.fn.css
	  function setCSS(element, values) {
	    var style = element.style;
	    for (var i in values) {
	      style[i] = values[i];
	    }
	  }

	  function ajaxGet(options) {
	    return new Promise(function (resolve, reject) {
	      var request = new XMLHttpRequest();
	      request.open(options.type || 'GET', options.url, true);
	      if (options.json) request.setRequestHeader('Accept', 'application/json');
	      request.onload = function () {
	        if (request.status === 200) {
	          var response = request.responseText;
	          if (options.json) response = JSON.parse(response);
	          resolve(response);
	        } else {
	          reject(new Error('Request error: ' + request.status));
	        }
	      };
	      request.onerror = function () {
	        reject(new Error('Network error: ' + request.status));
	      };
	      request.send();
	    });
	  }

	  // https://raw.githubusercontent.com/justmoon/node-extend/888f153645115d1c6aa9a7e346e8e9cd9a83de9b/index.js
	  // Copyright (c) 2014 Stefan Thomas
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var toStr = Object.prototype.toString;

	  var isArray = function isArray(arr) {
	    if (typeof Array.isArray === 'function') {
	      return Array.isArray(arr);
	    }

	    return toStr.call(arr) === '[object Array]';
	  };

	  var isPlainObject = function isPlainObject(obj) {
	    if (!obj || toStr.call(obj) !== '[object Object]') {
	      return false;
	    }

	    var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	    // Not own constructor property must be Object
	    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
	      return false;
	    }

	    // Own properties are enumerated firstly, so to speed up,
	    // if last one is own, then all properties are own.
	    var key;
	    for (key in obj) {/**/}

	    return typeof key === 'undefined' || hasOwn.call(obj, key);
	  };

	  function extend() {
	    var options, name, src, copy, copyIsArray, clone;
	    var target = arguments[0];
	    var i = 1;
	    var length = arguments.length;
	    var deep = false;

	    // Handle a deep copy situation
	    if (typeof target === 'boolean') {
	      deep = target;
	      target = arguments[1] || {};
	      // skip the boolean and the target
	      i = 2;
	    } else if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object' && typeof target !== 'function' || target == null) {
	      target = {};
	    }

	    for (; i < length; ++i) {
	      options = arguments[i];
	      // Only deal with non-null/undefined values
	      if (options != null) {
	        // Extend the base object
	        for (name in options) {
	          src = target[name];
	          copy = options[name];

	          // Prevent never-ending loop
	          if (target !== copy) {
	            // Recurse if we're merging plain objects or arrays
	            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
	              if (copyIsArray) {
	                copyIsArray = false;
	                clone = src && isArray(src) ? src : [];
	              } else {
	                clone = src && isPlainObject(src) ? src : {};
	              }

	              // Never move original objects, clone them
	              target[name] = extend(deep, clone, copy);

	              // Don't bring in undefined values
	            } else if (typeof copy !== 'undefined') {
	              target[name] = copy;
	            }
	          }
	        }
	      }
	    }

	    // Return the modified object
	    return target;
	  }

	  exports.default = {};
	  exports.isArray = isArray;
	  exports.isPlainObject = isPlainObject;
	  function mix(baseClass, mixin) {

	    for (var prop in mixin) {

	      if (mixin.hasOwnProperty(prop)) {
	        baseClass.prototype[prop] = mixin[prop];
	      }
	    }
	  }

	  function emptyDom(dom) {
	    while (dom.firstChild) {
	      dom.removeChild(dom.firstChild);
	    }
	  }
	});

	/***/ }),
	/* 6 */
	/***/ (function(module, exports, __webpack_require__) {

	var store = __webpack_require__(58)('wks');
	var uid = __webpack_require__(35);
	var Symbol = __webpack_require__(2).Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;


	/***/ }),
	/* 7 */
	/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(3)(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});


	/***/ }),
	/* 8 */
	/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(1);
	var IE8_DOM_DEFINE = __webpack_require__(104);
	var toPrimitive = __webpack_require__(23);
	var dP = Object.defineProperty;

	exports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};


	/***/ }),
	/* 9 */
	/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(25);
	var min = Math.min;
	module.exports = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};


	/***/ }),
	/* 10 */
	/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(24);
	module.exports = function (it) {
	  return Object(defined(it));
	};


	/***/ }),
	/* 11 */
	/***/ (function(module, exports) {

	module.exports = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};


	/***/ }),
	/* 12 */
	/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};


	/***/ }),
	/* 13 */
	/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(8);
	var createDesc = __webpack_require__(34);
	module.exports = __webpack_require__(7) ? function (object, key, value) {
	  return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};


	/***/ }),
	/* 14 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var hide = __webpack_require__(13);
	var has = __webpack_require__(12);
	var SRC = __webpack_require__(35)('src');
	var TO_STRING = 'toString';
	var $toString = Function[TO_STRING];
	var TPL = ('' + $toString).split(TO_STRING);

	__webpack_require__(22).inspectSource = function (it) {
	  return $toString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) has(val, 'name') || hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});


	/***/ }),
	/* 15 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var fails = __webpack_require__(3);
	var defined = __webpack_require__(24);
	var quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function (string, tag, attribute, value) {
	  var S = String(defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function (NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};


	/***/ }),
	/* 16 */
	/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(52);
	var defined = __webpack_require__(24);
	module.exports = function (it) {
	  return IObject(defined(it));
	};


	/***/ }),
	/* 17 */
	/***/ (function(module, exports, __webpack_require__) {

	var pIE = __webpack_require__(53);
	var createDesc = __webpack_require__(34);
	var toIObject = __webpack_require__(16);
	var toPrimitive = __webpack_require__(23);
	var has = __webpack_require__(12);
	var IE8_DOM_DEFINE = __webpack_require__(104);
	var gOPD = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};


	/***/ }),
	/* 18 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = __webpack_require__(12);
	var toObject = __webpack_require__(10);
	var IE_PROTO = __webpack_require__(76)('IE_PROTO');
	var ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};


	/***/ }),
	/* 19 */
	/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(11);
	module.exports = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};


	/***/ }),
	/* 20 */
	/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = function (it) {
	  return toString.call(it).slice(8, -1);
	};


	/***/ }),
	/* 21 */
	/***/ (function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(3);

	module.exports = function (method, arg) {
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
	  });
	};


	/***/ }),
	/* 22 */
	/***/ (function(module, exports) {

	var core = module.exports = { version: '2.5.3' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


	/***/ }),
	/* 23 */
	/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(4);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};


	/***/ }),
	/* 24 */
	/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};


	/***/ }),
	/* 25 */
	/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};


	/***/ }),
	/* 26 */
	/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(0);
	var core = __webpack_require__(22);
	var fails = __webpack_require__(3);
	module.exports = function (KEY, exec) {
	  var fn = (core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
	};


	/***/ }),
	/* 27 */
	/***/ (function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx = __webpack_require__(19);
	var IObject = __webpack_require__(52);
	var toObject = __webpack_require__(10);
	var toLength = __webpack_require__(9);
	var asc = __webpack_require__(93);
	module.exports = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || asc;
	  return function ($this, callbackfn, that) {
	    var O = toObject($this);
	    var self = IObject(O);
	    var f = ctx(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) result[index] = res;   // map
	        else if (res) switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};


	/***/ }),
	/* 28 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(55), __webpack_require__(5), __webpack_require__(56)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphPosition, _graphUtil, _EventEmitter2) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphPosition2 = _interopRequireDefault(_graphPosition);

	  var util = _interopRequireWildcard(_graphUtil);

	  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var Shape = function (_EventEmitter) {
	    _inherits(Shape, _EventEmitter);

	    function Shape() {
	      _classCallCheck(this, Shape);

	      return _possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this));
	    }

	    /**
	     * Initializes the shape
	     * @param {Graph} graph - The graph containing the shape
	     * @param {Object} properties - The properties object (not copied)
	     * @return {Shape} The current shape
	     */


	    _createClass(Shape, [{
	      key: 'init',
	      value: function init(graph, properties) {

	        var self = this;

	        this.graph = graph;
	        this.properties = properties || {};
	        this.handles = [];
	        this.options = this.options || {};

	        this.group = document.createElementNS(this.graph.ns, 'g');

	        this.group.setAttribute('clip-path', 'url(#_clipplot' + graph._creation + ')');

	        this._selected = false;
	        this.createDom();

	        if (this._dom) {
	          this._dom.jsGraphIsShape = this;
	        }

	        this.group.jsGraphIsShape = this;

	        this.classes = [];
	        this.transforms = [];

	        if (this._data.masker) {

	          var maskPath = document.createElementNS(this.graph.ns, 'mask');
	          this.maskingId = Math.random();
	          maskPath.setAttribute('id', this.maskingId);

	          this.maskDomWrapper = document.createElementNS(this.graph.ns, 'rect');
	          this.maskDomWrapper.setAttribute('fill', 'white');
	          maskPath.appendChild(this.maskDomWrapper);

	          var maskDom = this._dom.cloneNode();
	          maskPath.appendChild(maskDom);

	          this.maskDom = maskDom;

	          this.graph.defs.appendChild(maskPath);
	        }

	        if (this.group) {

	          if (this._dom && !this.isHTML()) {
	            this.group.appendChild(this._dom);
	          }

	          this.group.addEventListener('mouseover', function (e) {

	            self.handleMouseOver(e);
	          });

	          this.group.addEventListener('mouseout', function (e) {

	            self.handleMouseOut(e);
	          });

	          this.group.addEventListener('mousedown', function (e) {

	            self.graph.focus();

	            self.handleMouseDown(e);
	          });

	          this.group.addEventListener('click', this.handleClick.bind(this));

	          this.group.addEventListener('dblclick', function (e) {

	            //e.preventDefault();
	            // e.stopPropagation();

	            self.handleDblClick(e);
	          });
	        }

	        //			this.group.appendChild(this.rectEvent);

	        this.initImpl();

	        this.graph.emit('shapeNew', this);

	        return this;
	      }
	    }, {
	      key: 'initImpl',
	      value: function initImpl() {}
	    }, {
	      key: 'getData',
	      value: function getData() {
	        return this._data;
	      }
	    }, {
	      key: 'getType',
	      value: function getType() {
	        return this.type;
	      }
	    }, {
	      key: 'kill',
	      value: function kill(keepDom) {

	        if (this._inDom && !keepDom) {
	          this.graph.removeShapeFromDom(this);
	        }

	        if (!keepDom) {
	          this.graph._removeShape(this);
	        }

	        this.graph.stopElementMoving(this);
	        this.graph.emit('shapeRemoved', this);
	        this.emit('removed', this);

	        this._inDom = false;
	      }
	    }, {
	      key: 'hide',
	      value: function hide() {

	        if (this.hidden) {
	          return this;
	        }

	        this.hidden = true;
	        if (!this.isHTML()) {
	          this.group.style.display = 'none';
	        } else {
	          this._dom.style.display = 'none';
	        }
	        return this;
	      }
	    }, {
	      key: 'isHidden',
	      value: function isHidden() {
	        return this.hidden;
	      }
	    }, {
	      key: 'isVisible',
	      value: function isVisible() {
	        return !this.hidden;
	      }
	    }, {
	      key: 'show',
	      value: function show() {

	        if (!this.hidden) {
	          return this;
	        }

	        this.hidden = false;
	        if (!this.isHTML()) {
	          this.group.style.display = 'initial';
	        } else {
	          this._dom.style.display = 'initial';
	        }

	        this.redraw();
	        return this;
	      }
	    }, {
	      key: 'addClass',
	      value: function addClass(className) {
	        this.classes = this.classes || [];
	        if (this.classes.indexOf(className) == -1) {
	          this.classes.push(className);
	        }
	        this.makeClasses();
	        return this;
	      }
	    }, {
	      key: 'removeClass',
	      value: function removeClass(className) {
	        this.classes.splice(this.classes.indexOf(className), 1);
	        this.makeClasses();
	        return this;
	      }
	    }, {
	      key: 'makeClasses',
	      value: function makeClasses() {

	        if (this._dom) {
	          this._dom.setAttribute('class', this.classes.join(' '));
	        }

	        return this;
	      }
	    }, {
	      key: 'changed',
	      value: function changed(event, parameters) {

	        if (event) {
	          this.graph.emit(event, this, parameters);
	          this.emit(event, this, parameters);
	        }

	        this.emit('changed', this, parameters);
	        this.graph.emit('shapeChanged', this, parameters);
	        return this;
	      }
	    }, {
	      key: 'setEventReceptacle',
	      value: function setEventReceptacle() {

	        if (!this.rectEvent) {
	          this.rectEvent = document.createElementNS(this.graph.ns, 'rect');
	          this.rectEvent.setAttribute('pointer-events', 'fill');
	          this.rectEvent.setAttribute('fill', 'transparent');
	          this.group.appendChild(this.rectEvent);
	          this.rectEvent.jsGraphIsShape = this;
	        }

	        var box = this.group.getBBox();
	        this.rectEvent.setAttribute('x', box.x);
	        this.rectEvent.setAttribute('y', box.y - 10);
	        this.rectEvent.setAttribute('width', box.width);
	        this.rectEvent.setAttribute('height', box.height + 20);
	      }
	    }, {
	      key: 'setSerie',
	      value: function setSerie(serie) {

	        if (!serie) {
	          return;
	        }

	        this.serie = serie;

	        if (!serie.getXAxis || !serie.getYAxis) {
	          console.error(serie);
	          throw 'Serie does not implement the getXAxis or getYAxis method';
	        }
	        this.xAxis = serie.getXAxis();
	        this.yAxis = serie.getYAxis();
	        return this;
	      }
	    }, {
	      key: 'getSerie',
	      value: function getSerie() {
	        return this.serie;
	      }
	    }, {
	      key: 'autoAxes',
	      value: function autoAxes() {

	        if (!this.xAxis) {
	          this.xAxis = this.graph.getXAxis();
	        }

	        if (!this.yAxis) {
	          this.yAxis = this.graph.getYAxis();
	        }

	        return this;
	      }
	    }, {
	      key: 'setXAxis',
	      value: function setXAxis(axis) {
	        this.xAxis = axis;
	        return this;
	      }
	    }, {
	      key: 'setYAxis',
	      value: function setYAxis(axis) {
	        this.yAxis = axis;
	      }
	    }, {
	      key: 'getXAxis',
	      value: function getXAxis() {

	        if (!this.xAxis) {
	          this.autoAxes();
	        }

	        return this.xAxis;
	      }
	    }, {
	      key: 'getYAxis',
	      value: function getYAxis() {

	        if (!this.yAxis) {
	          this.autoAxes();
	        }

	        return this.yAxis;
	      }
	    }, {
	      key: 'setLayer',
	      value: function setLayer(layer) {
	        this.setProp('layer', layer);
	        return this;
	      }
	    }, {
	      key: 'getLayer',
	      value: function getLayer() {
	        var layer = this.getProp('layer');

	        if (layer !== undefined) {
	          return layer;
	        }

	        return 1;
	      }
	    }, {
	      key: 'draw',
	      value: function draw(force, preventRedraw) {

	        if (!this._inDom || force) {

	          this.appendToDom();
	          this._inDom = true;
	        }

	        this.makeLabels();

	        if (!preventRedraw) {
	          this.redraw();
	        }

	        this.applyStyle();

	        return this;
	      }
	    }, {
	      key: 'redraw',
	      value: function redraw() {

	        if (this.hidden) {
	          return this;
	        }

	        this.position = this.applyPosition();

	        this.redrawImpl();
	        if (!this.position) {
	          this.updateLabels();
	          return this;
	        }

	        this.updateLabels();
	        this._applyTransforms();
	        return this;
	      }
	    }, {
	      key: 'redrawImpl',
	      value: function redrawImpl() {}
	    }, {
	      key: 'setProperties',
	      value: function setProperties(properties) {
	        this.properties = properties;

	        if (!Array.isArray(this.properties.position)) {
	          this.properties.position = [this.properties.position];
	        }
	        var self = this;
	        for (var i = 0, l = this.properties.position.length; i < l; i++) {

	          var pos = _graphPosition2.default.check(this.properties.position[i], function (relativeTo) {
	            return self.getRelativePosition(relativeTo);
	          });

	          this.properties.position[i] = pos;
	        }

	        this.emit('propertiesChanged');
	        return this;
	      }
	    }, {
	      key: 'getRelativePosition',
	      value: function getRelativePosition(relativePosition) {

	        var result;
	        if ((result = /position([0-9]*)/.exec(relativePosition)) !== null) {
	          return this.getPosition(result[1]);
	        } else if ((result = /labelPosition([0-9]*)/.exec(relativePosition)) !== null) {
	          return this.getLabelPosition(result[1]);
	        }
	      }
	    }, {
	      key: 'getProperties',
	      value: function getProperties(properties) {
	        return this.properties;
	      }
	    }, {
	      key: 'setProp',
	      value: function setProp(prop, val, index) {
	        this.properties = this.properties || {};
	        this.properties[prop] = this.properties[prop] || [];
	        this.properties[prop][index || 0] = val;
	        this.emit('propertyChanged', prop);
	        return this;
	      }
	    }, {
	      key: 'getProp',
	      value: function getProp(prop, index) {
	        return (this.properties[prop] || [])[index || 0];
	      }
	    }, {
	      key: 'getProps',
	      value: function getProps(prop, index) {
	        return this.properties[prop] || [];
	      }
	    }, {
	      key: 'addProp',
	      value: function addProp(prop, value) {
	        this.properties[prop] = this.properties[prop] || [];
	        this.properties[prop].push(value);
	      }
	    }, {
	      key: 'resetProp',
	      value: function resetProp(prop) {
	        this.properties[prop] = [];
	      }
	    }, {
	      key: 'setDom',
	      value: function setDom(prop, val, noForce) {
	        if (this._dom) {

	          if (!noForce || !util.hasSavedAttribute(this._dom, prop)) {
	            this._dom.setAttribute(prop, val);
	          }
	        }
	      }
	    }, {
	      key: 'setDomGroup',
	      value: function setDomGroup(prop, val) {
	        if (this.group) {
	          this.group.setAttribute(prop, val);
	        }
	      }
	    }, {
	      key: 'setStrokeColor',
	      value: function setStrokeColor(color) {
	        this.setProp('strokeColor', color);
	        this.overwriteSavedProp('stroke', color);
	        this.applySelectedStyle();
	        return this;
	      }
	    }, {
	      key: 'getStrokeColor',
	      value: function getStrokeColor() {
	        return this.getProp('strokeColor');
	      }
	    }, {
	      key: 'setFillColor',
	      value: function setFillColor(color) {

	        this.setProp('fillColor', color);
	        this.overwriteSavedProp('fill', color);
	        this.applySelectedStyle();
	        return this;
	      }
	    }, {
	      key: 'getFillColor',
	      value: function getFillColor() {
	        return this.getProp('fillColor');
	      }
	    }, {
	      key: 'setFillOpacity',
	      value: function setFillOpacity(opacity) {
	        this.setProp('fillOpacity', opacity);
	        this.overwriteSavedProp('fill-opacity', opacity);
	        this.applySelectedStyle();
	        return this;
	      }
	    }, {
	      key: 'setStrokeWidth',
	      value: function setStrokeWidth(width) {
	        this.setProp('strokeWidth', width);
	        this.overwriteSavedProp('stroke-width', width);
	        this.applySelectedStyle();
	        return this;
	      }
	    }, {
	      key: 'getStrokeWidth',
	      value: function getStrokeWidth() {
	        return this.getProp('strokeWidth');
	      }
	    }, {
	      key: 'setStrokeDasharray',
	      value: function setStrokeDasharray(dasharray) {
	        this.setProp('strokeDasharray', dasharray);
	        this.overwriteSavedProp('stroke-dasharray', dasharray);
	        this.applySelectedStyle();
	        return this;
	      }
	    }, {
	      key: 'setAttributes',
	      value: function setAttributes(attributes) {
	        this.setProp('attributes', attributes);
	        return this;
	      }
	    }, {
	      key: 'overwriteSavedProp',
	      value: function overwriteSavedProp(prop, newValue) {
	        util.overwriteDomAttribute(this._dom, prop, newValue);
	      }
	    }, {
	      key: 'addAttribute',
	      value: function addAttribute(attributeName, attributeValue) {
	        var added = {};
	        added[attributeName] = attributeValue;
	        this.addProp('attributes', added);
	        return this;
	      }
	    }, {
	      key: 'addTransform',
	      value: function addTransform(type, args) {
	        this.addProp('transforms', {
	          type: type,
	          arguments: Array.isArray(args) ? args : [args]
	        });
	        return this;
	      }
	    }, {
	      key: 'resetTransforms',
	      value: function resetTransforms() {
	        this.resetProp('transforms');
	        return this;
	      }
	    }, {
	      key: 'setLabelText',
	      value: function setLabelText(text) {
	        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	        this.setProp('labelText', text, index);
	        return this;
	      }
	    }, {
	      key: 'setLabelData',
	      value: function setLabelData(data, text) {
	        var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	        this.setProp('labelData', text, index);
	        return this;
	      }
	    }, {
	      key: 'getLabelText',
	      value: function getLabelText(text) {
	        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	        return this.getProp('labelText', index);
	      }
	    }, {
	      key: 'displayLabel',
	      value: function displayLabel() {
	        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	        this.setProp('labelVisible', true, index);
	        return this;
	      }
	    }, {
	      key: 'hideLabel',
	      value: function hideLabel() {
	        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	        this.setProp('labelVisible', false, index);
	        return this;
	      }
	    }, {
	      key: 'setLabelColor',
	      value: function setLabelColor(color) {
	        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	        this.setProp('labelColor', color, index);
	        return this;
	      }
	    }, {
	      key: 'setLabelFontSize',
	      value: function setLabelFontSize(size) {
	        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	        this.setProp('labelFontSize', size, index);
	        return this;
	      }
	    }, {
	      key: 'getLabelPosition',
	      value: function getLabelPosition() {
	        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	        return this.getProp('labelPosition', index);
	      }
	    }, {
	      key: 'setLabelPosition',
	      value: function setLabelPosition(position, index) {

	        var self;
	        var pos = _graphPosition2.default.check(position, function (relativeTo) {
	          return self.getRelativePosition(relativeTo);
	        });

	        this.setProp('labelPosition', pos, index || 0);
	        return this;
	      }
	    }, {
	      key: 'setLabelAngle',
	      value: function setLabelAngle(angle, index) {
	        this.setProp('labelAngle', angle, index || 0);
	        return this;
	      }
	    }, {
	      key: 'setLabelBaseline',
	      value: function setLabelBaseline(baseline, index) {
	        this.setProp('labelBaseline', baseline, index || 0);
	        return this;
	      }
	    }, {
	      key: 'setLabelAnchor',
	      value: function setLabelAnchor(anchor, index) {
	        this.setProp('labelAnchor', anchor, index || 0);
	        return this;
	      }
	    }, {
	      key: 'setLabelSize',
	      value: function setLabelSize(size, index) {
	        this.setProp('labelSize', size, index || 0);
	        return this;
	      }
	    }, {
	      key: 'setLabelStrokeColor',
	      value: function setLabelStrokeColor(color, index) {
	        this.setProp('labelStrokeColor', color, index || 0);
	        return this;
	      }
	    }, {
	      key: 'setLabelStrokeWidth',
	      value: function setLabelStrokeWidth(width, index) {
	        this.setProp('labelStrokeWidth', width, index || 0);
	        return this;
	      }
	    }, {
	      key: 'setLabelBackgroundColor',
	      value: function setLabelBackgroundColor(color, index) {
	        this.setProp('labelBackgroundColor', color, index || 0);
	        return this;
	      }
	    }, {
	      key: 'setLabelBackgroundOpacity',
	      value: function setLabelBackgroundOpacity(opacity, index) {
	        this.setProp('labelBackgroundOpacity', opacity, index || 0);
	        return this;
	      }
	    }, {
	      key: 'applyGenericStyle',
	      value: function applyGenericStyle() {

	        this.setDom('fill', this.getProp('fillColor'), true);
	        this.setDom('fill-opacity', this.getProp('fillOpacity'), true);
	        this.setDom('stroke', this.getProp('strokeColor'), true);
	        this.setDom('stroke-width', this.getProp('strokeWidth'), true);
	        this.setDom('stroke-dasharray', this.getProp('strokeDasharray'), true);

	        var attributes = this.getProps('attributes');
	        for (var j = 0, l = attributes.length; j < l; j++) {

	          for (var i in attributes[j]) {
	            this.setDom(i, typeof attributes[j][i] == 'function' ? attributes[j][i].call(this, i) : attributes[j][i], true);
	          }
	        }

	        this._applyTransforms();

	        return this;
	      }
	    }, {
	      key: 'applyStyle',
	      value: function applyStyle() {

	        return this.applyGenericStyle();
	      }
	    }, {
	      key: 'calculatePosition',
	      value: function calculatePosition(index) {

	        var position;

	        position = index instanceof _graphPosition2.default ? index : this.getPosition(index);

	        if (!position) {
	          return;
	        }

	        if (position && position.compute) {
	          return position.compute(this.graph, this.getXAxis(), this.getYAxis(), this.getSerie());
	        }

	        this.graph.throw();
	      }
	    }, {
	      key: 'getPosition',
	      value: function getPosition(index) {

	        var pos = this.getProp('position', index || 0);
	        this.setProp('position', pos = _graphPosition2.default.check(pos), index);
	        return pos;
	      }
	    }, {
	      key: 'setPosition',
	      value: function setPosition(position, index) {

	        var self = this;
	        var pos = _graphPosition2.default.check(position, function (relativeTo) {
	          return self.getRelativePosition(relativeTo);
	        });

	        return this.setProp('position', pos, index || 0);
	      }
	    }, {
	      key: 'sortPositions',
	      value: function sortPositions(sortFunction) {
	        this.getProps('position').sort(sortFunction);
	        return this;
	      }
	    }, {
	      key: '_applyTransforms',
	      value: function _applyTransforms() {

	        var transforms = this.getProp('transforms'),
	            transformString = '';

	        if (!transforms) {
	          return;
	        }
	        transforms = Array.isArray(transforms) ? transforms : [transforms];

	        if (transforms.length == 0) {
	          return;
	        }

	        for (var i = 0; i < transforms.length; i++) {

	          transformString += transforms[i].type + '(';

	          switch (transforms[i].type) {

	            case 'translate':

	              var transform = transforms[i].arguments[0].compute(this.graph, this.getXAxis(), this.getYAxis(), this.getSerie());

	              transformString += transform.x;
	              transformString += ', ';
	              transformString += transform.y;
	              break;

	            case 'rotate':

	              transformString += transforms[i].arguments[0];
	              transformString += ', ';

	              if (transforms[i].arguments.length == 1) {
	                var p = this.computePosition(0);
	                transformString += p.x + ', ' + p.y;
	              } else {

	                transformString += _graphPosition2.default.getDeltaPx(transforms[i].arguments[1], this.getXAxis()).replace('px', '');
	                transformString += ', ';
	                transformString += _graphPosition2.default.getDeltaPx(transforms[i].arguments[2], this.getYAxis()).replace('px', '');
	              }

	              break;
	          }

	          transformString += ') ';
	        }

	        this.setDomGroup('transform', transformString);
	        return this;
	      }
	    }, {
	      key: 'makeLabels',
	      value: function makeLabels() {
	        var _this2 = this;

	        this._labels = this._labels || [];
	        this._labelsBackground = this._labelsBackground || [];

	        this._labels.map(function (label) {
	          _this2.group.removeChild(label);
	        });

	        this._labelsBackground.map(function (bg) {
	          _this2.group.removeChild(bg);
	        });

	        this._labels = [];
	        this._labelsBackground[i] = [];

	        var i = 0;

	        while (this.getProp('labelText', i) !== undefined) {

	          if (!this._labels[i]) {

	            this._labels[i] = document.createElementNS(this.graph.ns, 'text');
	            this._labels[i].setAttribute('data-label-i', i);
	            this._labels[i].jsGraphIsShape = this;

	            this._labelsBackground[i] = document.createElementNS(this.graph.ns, 'rect');
	            this._labelsBackground[i].setAttribute('data-label-i', i);
	            this._labelsBackground[i].jsGraphIsShape = this;

	            this.group.appendChild(this._labelsBackground[i]);
	            this.group.appendChild(this._labels[i]);

	            this._labels[i].addEventListener('dblclick', function (e) {
	              e.stopPropagation();

	              _this2.labelDblClickListener(e);
	            });

	            this._labelsBackground[i].addEventListener('dblclick', function (e) {
	              e.stopPropagation();

	              _this2.labelDblClickListener(e);
	            });
	          }

	          i++;
	        }

	        this.updateLabels();

	        return this;
	      }
	    }, {
	      key: 'isLabelEditable',
	      value: function isLabelEditable(labelIndex) {
	        return this.getProp('labelEditable', labelIndex || 0);
	      }
	    }, {
	      key: 'updateLabels',
	      value: function updateLabels() {
	        this._labels = this._labels || [];

	        for (var i = 0, l = this._labels.length; i < l; i++) {
	          this._applyLabelData(i);
	        }
	      }
	    }, {
	      key: '_applyLabelData',
	      value: function _applyLabelData(labelIndex) {

	        labelIndex = labelIndex || 0;

	        /** Sets the position */

	        var visible = this.getProp('labelVisible', labelIndex);

	        if (visible === false) {
	          this._labels[labelIndex].setAttribute('display', 'none');
	          this._labelsBackground[labelIndex].setAttribute('display', 'none');
	          return;
	        } else {
	          this._labels[labelIndex].setAttribute('display', 'initial');
	          this._labelsBackground[labelIndex].setAttribute('display', 'initial');
	        }

	        var position = this.calculatePosition(_graphPosition2.default.check(this.getProp('labelPosition', labelIndex)));

	        if (isNaN(position.x) || isNaN(position.y) || position.y === false || position.x === false) {
	          /*console.warn( "Cannot compute positioning for labelIndex " + labelIndex + " with text " + this.getProp( "labelText", labelIndex ) );
	          console.log( this, this._labels );
	          console.trace();*/
	          return;
	        }

	        if (position.x != 'NaNpx' && !isNaN(position.x) && position.x !== 'NaN' && position.x !== false) {

	          this._labels[labelIndex].setAttribute('x', position.x);
	          this._labels[labelIndex].setAttribute('y', position.y);
	        }

	        /** Sets the angle */
	        var currAngle = this.getProp('labelAngle', labelIndex) || 0;
	        if (currAngle != 0) {

	          var x = this._labels[labelIndex].getAttribute('x'),
	              y = this._labels[labelIndex].getAttribute('y');

	          this._labels[labelIndex].setAttribute('transform', 'rotate(' + currAngle + ' ' + x + ' ' + y + ')');
	          //  this._labelsBackground[ labelIndex ].setAttribute( 'transform', 'rotate(' + currAngle + ' ' + x + ' ' + y + ')' );
	        }

	        var labelData = this.getProp('labelHTMLData', labelIndex) || {};

	        for (var i in labelData) {

	          this._labels[labelIndex].setAttribute(i, labelData[i]);
	          this._labelsBackground[labelIndex].setAttribute(i, labelData[i]);
	        }

	        /** Sets the baseline */
	        this._labels[labelIndex].setAttribute('dominant-baseline', this.getProp('labelBaseline', labelIndex) || 'no-change');

	        /** Sets the text */
	        this._labels[labelIndex].textContent = this.getProp('labelText', labelIndex);

	        /** Sets the color */
	        this._labels[labelIndex].setAttribute('fill', this.getProp('labelColor', labelIndex) || 'black');

	        /** Sets the size */
	        this._labels[labelIndex].setAttribute('font-size', this.getProp('labelSize', labelIndex) + 'px' || '12px');

	        /** Sets the anchor */
	        this._labels[labelIndex].setAttribute('text-anchor', this._getLabelAnchor(labelIndex));

	        /** Sets the stroke */
	        this._labels[labelIndex].setAttribute('stroke', this.getProp('labelStrokeColor', labelIndex) || 'black');

	        /** Sets the stroke */
	        this._labels[labelIndex].setAttribute('stroke-width', this.getProp('labelStrokeWidth', labelIndex) || 0 + 'px');

	        this._labels[labelIndex].setAttribute('stroke-location', 'outside');

	        var rect = this._labels[labelIndex].getBBox();

	        this._labelsBackground[labelIndex].setAttribute('x', rect.x);
	        this._labelsBackground[labelIndex].setAttribute('y', rect.y);
	        this._labelsBackground[labelIndex].setAttribute('width', rect.width);
	        this._labelsBackground[labelIndex].setAttribute('height', rect.height);

	        this._labelsBackground[labelIndex].setAttribute('fill', this.getProp('labelBackgroundColor') || 'transparent');
	        this._labelsBackground[labelIndex].setAttribute('fill-opacity', this.getProp('labelBackgroundOpacity') || 1);

	        return this;
	      }
	    }, {
	      key: 'emptyLabels',
	      value: function emptyLabels() {

	        for (var i = 0, l = this._labels.length; i < l; i++) {
	          /** Sets the baseline */
	          this._labels[i].textContent = '';
	        }

	        return this;
	      }
	    }, {
	      key: '_getLabelAnchor',
	      value: function _getLabelAnchor(labelIndex) {
	        var anchor = this.getProp('labelAnchor', labelIndex);
	        switch (anchor) {
	          case 'middle':
	          case 'start':
	          case 'end':
	            return anchor;
	            break;

	          case 'right':
	            return 'end';
	            break;

	          case 'left':
	            return 'start';
	            break;

	          default:
	            return 'start';
	            break;
	        }
	      }
	    }, {
	      key: 'isSelected',
	      value: function isSelected() {
	        return this._selectStatus || false;
	      }
	    }, {
	      key: 'hasHandles',
	      value: function hasHandles(setter) {

	        if (setter !== undefined) {
	          this.setProp('handles', setter);
	        }

	        return !!this.getProp('handles') || !!this.getProp('staticHandles');
	      }
	    }, {
	      key: 'addHandles',
	      value: function addHandles() {

	        if (this.isLocked()) {
	          return;
	        }

	        if (!this.handlesInDom) {

	          this.handlesInDom = true;

	          for (var i = 1; i < this.handles.length; i++) {

	            if (this.handles[i]) {
	              this.group.appendChild(this.handles[i]);
	            }
	          }
	        }

	        return this;
	      }
	    }, {
	      key: 'removeHandles',
	      value: function removeHandles() {

	        this.hideHandles();
	        this.handles = [];
	      }
	    }, {
	      key: 'hideHandles',
	      value: function hideHandles() {

	        if (!this.handlesInDom) {
	          return this;
	        }

	        for (var i = 1; i < this.handles.length; i++) {
	          this.group.removeChild(this.handles[i]);
	        }

	        this.handlesInDom = false;
	        return this;
	      }
	    }, {
	      key: 'areHandlesInDom',
	      value: function areHandlesInDom() {

	        return this.handlesInDom;
	      }
	    }, {
	      key: '_select',
	      value: function _select(mute) {

	        if (!this.isSelectable()) {
	          return false;
	        }

	        // Put on the stack
	        this.appendToDom();
	        //this.graph.appendShapeToDom( this ); // Put the shape on top of the stack !

	        this._selectStatus = true;

	        this.applySelectedStyle();

	        if (this.hasHandles() && !this.hasStaticHandles()) {

	          this.addHandles();
	          this.setHandles();
	        }

	        if (!mute) {
	          this.graph.emit('shapeSelected', this);
	        }
	      }
	    }, {
	      key: 'applySelectedStyle',
	      value: function applySelectedStyle() {

	        if (!this._selectStatus) {
	          return;
	        }

	        var style = this.getSelectStyle();
	        var style2 = {};
	        for (var i in style) {
	          if (typeof style[i] == 'function') {
	            style2[i] = style[i].call(this);
	          } else {
	            style2[i] = style[i];
	          }
	        }

	        util.saveDomAttributes(this._dom, style2, 'select');
	      }
	    }, {
	      key: '_unselect',
	      value: function _unselect(mute) {

	        this._selectStatus = false;

	        util.restoreDomAttributes(this._dom, 'select');

	        if (this.hasHandles() && !this.hasStaticHandles()) {
	          this.hideHandles();
	        }

	        if (!mute) {
	          this.graph.emit('shapeUnselected', this);
	        }
	      }
	    }, {
	      key: 'getSelectStyle',
	      value: function getSelectStyle() {
	        return this.selectStyle;
	      }
	    }, {
	      key: 'setSelectStyle',
	      value: function setSelectStyle(attr) {
	        this.selectStyle = attr;
	        this.applySelectedStyle(); // Maybe the shape is already selected
	        return this;
	      }
	    }, {
	      key: 'setStaticHandles',
	      value: function setStaticHandles(staticHandles) {
	        this.setProp('staticHandles', staticHandles);
	      }
	    }, {
	      key: 'hasStaticHandles',
	      value: function hasStaticHandles(staticHandles) {
	        return !!this.getProp('staticHandles');
	      }
	    }, {
	      key: '_createHandles',
	      value: function _createHandles(nb, type, attr, callbackEach) {
	        var _this3 = this;

	        if (this.handles && this.handles.length > 0) {
	          return;
	        }

	        for (var i = 1, l = nb; i <= l; i++) {

	          (function (j) {

	            var self = _this3;

	            var handle = document.createElementNS(self.graph.ns, type);
	            handle.jsGraphIsShape = true;

	            if (attr) {
	              for (var k in attr) {
	                handle.setAttribute(k, attr[k]);
	              }
	            }

	            handle.addEventListener('mousedown', function (e) {

	              if (self.isResizable()) {

	                e.preventDefault();
	                e.stopPropagation();

	                self.graph.emit('beforeShapeResize', self);
	                _this3.emit('beforeShapeResize');

	                if (!self.graph.prevent(false)) {

	                  self.resizing = true;
	                  self.handleSelected = j;
	                  self.handleMouseDown(e);
	                }
	              }
	            });

	            if (callbackEach) {
	              callbackEach(self.handles[j]);
	            }

	            self.handles[j] = handle;
	          }).call(this, i);
	        }

	        return this.handles;
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {

	        if (this.hasStaticHandles()) {
	          this.addHandles();
	          this.setHandles();
	        }
	      }
	    }, {
	      key: 'handleMouseDownImpl',
	      value: function handleMouseDownImpl() {}
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl() {}
	    }, {
	      key: 'handleMouseUpImpl',
	      value: function handleMouseUpImpl() {}
	    }, {
	      key: 'handleCreateImpl',
	      value: function handleCreateImpl() {}
	    }, {
	      key: 'handleMouseDown',
	      value: function handleMouseDown(e) {

	        //this.handleSelected = false;

	        if (this.isLocked()) {
	          return;
	        }

	        if (this.isMovable() || this.isResizable()) {

	          this.graph.elementMoving(this);
	        }

	        if (this.getProp('selectOnMouseDown')) {
	          this.graph.selectShape(this);
	        }

	        if (this.isMovable()) {
	          if (!this.resizing) {

	            this.graph.emit('beforeShapeMove', self);

	            if (!this.graph.prevent(false)) {

	              this.moving = true;
	              this.moved = false;
	            }
	          }
	        }

	        this._mouseCoords = this.graph._getXY(e);
	        return this.handleMouseDownImpl(e, this._mouseCoords);
	      }
	    }, {
	      key: 'handleClick',
	      value: function handleClick(e) {

	        this.graph.emit('shapeClicked', this);
	        this.emit('shapeClicked');

	        if (!this.isSelectable()) {
	          return false;
	        }

	        if (!e.shiftKey) {
	          this.graph.unselectShapes();
	        }

	        if (this.getProp('selectOnClick')) {

	          this.graph.selectShape(this);
	        }
	      }
	    }, {
	      key: 'handleMouseMove',
	      value: function handleMouseMove(e) {
	        //console.log( this.resizinh, this.moving, this.isSelected(), this._mouseCoords );
	        if ((this.resizing || this.moving) && !this.isSelected()) {
	          this.graph.selectShape(this);
	        }

	        this.graph.emit('beforeShapeMouseMove', this);
	        this.emit('beforeShapeMouseMove');

	        if (this.graph.prevent(false) || !this._mouseCoords) {
	          return false;
	        }

	        this.moved = true;
	        var coords = this.graph._getXY(e);
	        var deltaX = this.getXAxis().getRelVal(coords.x - this._mouseCoords.x),
	            deltaY = this.getYAxis().getRelVal(coords.y - this._mouseCoords.y);

	        if (deltaX != 0 || deltaY !== 0) {
	          this.preventUnselect = true;
	        }

	        this._mouseCoords = coords;

	        var ret = this.handleMouseMoveImpl(e, deltaX, deltaY, coords.x - this._mouseCoords.x, coords.y - this._mouseCoords.y);

	        return ret;
	      }
	    }, {
	      key: 'handleMouseUp',
	      value: function handleMouseUp(e) {

	        if (this.moving && this.moved) {

	          this.graph.emit('shapeMoved', this);
	          this.emit('shapeMoved');
	        }

	        if (this.handleSelected || this.resize) {

	          this.graph.emit('shapeResized', this);
	          this.emit('shapeResized');
	        }

	        this.moving = false;
	        this.resizing = false;
	        this.handleSelected = false;
	        this.graph.elementMoving(false);

	        return this.handleMouseUpImpl(e);
	      }
	    }, {
	      key: 'handleDblClick',
	      value: function handleDblClick(e) {}
	    }, {
	      key: 'handleMouseOver',
	      value: function handleMouseOver() {

	        if (this.getProp('highlightOnMouseOver')) {

	          if (!this.moving && !this.resizing) {
	            this.highlight();
	          }
	        }

	        this.graph.emit('shapeMouseOver', this);
	      }
	    }, {
	      key: 'handleMouseOut',
	      value: function handleMouseOut() {

	        if (this.getProp('highlightOnMouseOver')) {
	          this.unHighlight();
	        }

	        this.graph.emit('shapeMouseOut', this);
	      }
	    }, {
	      key: 'lock',
	      value: function lock() {
	        this.setProp('locked', true);
	        return this;
	      }
	    }, {
	      key: 'unlock',
	      value: function unlock() {
	        this.setProp('locked', false);
	        return this;
	      }
	    }, {
	      key: 'isLocked',
	      value: function isLocked() {
	        return this.getProp('locked') || this.graph.shapesLocked;
	      }
	    }, {
	      key: 'movable',
	      value: function movable(bln) {
	        this.setProp('movable', true);
	      }
	    }, {
	      key: 'unmovable',
	      value: function unmovable() {
	        this.setProp('movable', false);
	        return false;
	      }
	    }, {
	      key: 'isMovable',
	      value: function isMovable() {
	        return this.getProp('movable');
	      }
	    }, {
	      key: 'resizable',
	      value: function resizable() {
	        this.setProp('resizable', true);
	      }
	    }, {
	      key: 'unresizable',
	      value: function unresizable() {
	        this.setProp('resizable', false);
	      }
	    }, {
	      key: 'isResizable',
	      value: function isResizable() {
	        return this.getProp('resizable');
	      }
	    }, {
	      key: 'selectable',
	      value: function selectable() {
	        this.setProp('selectable', true);
	      }
	    }, {
	      key: 'unselectable',
	      value: function unselectable() {
	        this.graph.unselectShape(this);
	        this.setProp('selectable', false);
	      }
	    }, {
	      key: 'isSelectable',
	      value: function isSelectable() {
	        return this.getProp('selectable');
	      }
	    }, {
	      key: 'highlight',
	      value: function highlight(attributes, saveDomName) {

	        if (!attributes) {
	          attributes = this.getHighlightAttributes();
	        }

	        if (!saveDomName) {
	          saveDomName = 'highlight';
	        }

	        util.saveDomAttributes(this._dom, attributes, saveDomName);
	        this.highlightImpl();
	        return this;
	      }
	    }, {
	      key: 'unHighlight',
	      value: function unHighlight(saveDomName) {

	        if (!saveDomName) {
	          saveDomName = 'highlight';
	        }

	        util.restoreDomAttributes(this._dom, saveDomName);
	        this.unHighlightImpl();
	        return this;
	      }
	    }, {
	      key: 'highlightImpl',
	      value: function highlightImpl() {}
	    }, {
	      key: 'unHighlightImpl',
	      value: function unHighlightImpl() {}
	    }, {
	      key: 'getHighlightAttributes',
	      value: function getHighlightAttributes() {
	        return this._highlightAttributes;
	      }
	    }, {
	      key: 'setHighlightAttributes',
	      value: function setHighlightAttributes(attributes) {
	        this._highlightAttributes = attributes;
	        return this;
	      }
	    }, {
	      key: 'getMaskingID',
	      value: function getMaskingID() {
	        return this.maskingId;
	      }
	    }, {
	      key: 'maskWith',
	      value: function maskWith(maskingShape) {

	        var maskingId = maskingShape.getMaskingID();

	        if (maskingId) {

	          this._dom.setAttribute('mask', 'url(#' + maskingId + ')');
	        } else {

	          this._dom.removeAttribute('mask');
	        }
	      }
	    }, {
	      key: 'updateMask',
	      value: function updateMask() {
	        return;
	        if (!this.maskDom) {
	          return; // eslint-disable-line no-useless-return
	        }

	        var position = {
	          x: 'min',
	          y: 'min'
	        };
	        var position2 = {
	          x: 'max',
	          y: 'max'
	        };

	        position = this._getPosition(position);
	        position2 = this._getPosition(position2);

	        this.maskDomWrapper.setAttribute('x', Math.min(position.x, position2.x));
	        this.maskDomWrapper.setAttribute('y', Math.min(position.y, position2.y));

	        this.maskDomWrapper.setAttribute('width', Math.abs(position2.x - position.x));
	        this.maskDomWrapper.setAttribute('height', Math.abs(position2.y - position.y));

	        for (var i = 0; i < this._dom.attributes.length; i++) {
	          this.maskDom.setAttribute(this._dom.attributes[i].name, this._dom.attributes[i].value);
	        }

	        this.maskDom.setAttribute('fill', 'black');

	        return this;
	      }
	    }, {
	      key: 'labelDblClickListener',
	      value: function labelDblClickListener(e) {

	        var i = parseInt(e.target.getAttribute('data-label-i'));

	        var self = this;

	        if (isNaN(i)) {
	          return;
	        }

	        if (!this.isLabelEditable(i)) {
	          return;
	        }

	        e.preventDefault();
	        e.stopPropagation();

	        var shapeLabel = document.createElement('input');
	        shapeLabel.setAttribute('type', 'text');
	        shapeLabel.setAttribute('value', self.getProp('labelText', i));

	        self.graph.wrapper.prepend(shapeLabel);
	        shapeLabel.select();

	        util.setCSS(shapeLabel, {
	          position: 'absolute',
	          marginTop: parseInt(e.target.getAttribute('y').replace('px', '')) + this.graph.getPaddingTop() - 10 + 'px',
	          marginLeft: parseInt(e.target.getAttribute('x').replace('px', '')) + this.graph.getPaddingLeft() - 50 + 'px',
	          textAlign: 'center',
	          width: '100px'
	        });

	        var previousValue = self.getLabelText(i);

	        var blurEvent = function blurEvent() {

	          self.setLabelText(shapeLabel.value, i);
	          self._labels[i].textContent = shapeLabel.value;

	          var nextValue = shapeLabel.value;

	          shapeLabel.remove();
	          shapeLabel.removeEventListener('blur', blurEvent);
	          shapeLabel = false;

	          self.changed('shapeLabelChanged', {
	            previousValue: previousValue,
	            nextValue: nextValue
	          });
	        };

	        shapeLabel.addEventListener('blur', blurEvent);

	        shapeLabel.addEventListener('keyup', function (e) {

	          if (e.keyCode === 13) {
	            blurEvent();
	          }
	        });
	        shapeLabel.addEventListener('keypress', function (e) {
	          e.stopPropagation();
	        });
	        shapeLabel.addEventListener('keydown', function (e) {
	          e.stopPropagation();
	        });
	        shapeLabel.focus();
	      }
	    }, {
	      key: 'appendToDom',
	      value: function appendToDom() {

	        if (this._forcedParentDom) {

	          this._forcedParentDom.appendChild(this.group);
	        } else {
	          this.graph.appendShapeToDom(this);
	        }
	        return this;
	      }
	    }, {
	      key: 'forceParentDom',
	      value: function forceParentDom(dom) {

	        this._forcedParentDom = dom;

	        return this;
	      }
	    }, {
	      key: 'isHTML',
	      value: function isHTML() {
	        return false;
	      }
	    }]);

	    return Shape;
	  }(_EventEmitter3.default);

	  /**
	   * @alias Shape#calculatePosition
	   */
	  Shape.prototype.computePosition = Shape.prototype.calculatePosition;

	  /**
	   * @alias Shape#displayLabel
	   */
	  Shape.prototype.showLabel = Shape.prototype.displayLabel;

	  /**
	   * @alias Shape#kill
	   */
	  Shape.prototype.remove = Shape.prototype.kill;

	  exports.default = Shape;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 29 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(56)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _EventEmitter2) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var Plugin = function (_EventEmitter) {
	    _inherits(Plugin, _EventEmitter);

	    _createClass(Plugin, null, [{
	      key: 'default',
	      value: function _default() {
	        return {};
	      }
	    }]);

	    function Plugin(options) {
	      _classCallCheck(this, Plugin);

	      var _this = _possibleConstructorReturn(this, (Plugin.__proto__ || Object.getPrototypeOf(Plugin)).apply(this, arguments));

	      _this.options = Object.assign({}, Plugin.default(), _this.constructor.default(), options);
	      return _this;
	    }

	    /**
	     * Init function called by jsGraph on load
	     */


	    _createClass(Plugin, [{
	      key: 'init',
	      value: function init(graph) {
	        this.graph = graph;
	      }
	    }, {
	      key: 'onMouseDown',
	      value: function onMouseDown() {}
	    }, {
	      key: 'onMouseUp',
	      value: function onMouseUp() {}
	    }, {
	      key: 'onMouseMove',
	      value: function onMouseMove() {}
	    }]);

	    return Plugin;
	  }(_EventEmitter3.default);

	  exports.default = Plugin;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 30 */
	/***/ (function(module, exports, __webpack_require__) {

	if (__webpack_require__(7)) {
	  var LIBRARY = __webpack_require__(36);
	  var global = __webpack_require__(2);
	  var fails = __webpack_require__(3);
	  var $export = __webpack_require__(0);
	  var $typed = __webpack_require__(68);
	  var $buffer = __webpack_require__(99);
	  var ctx = __webpack_require__(19);
	  var anInstance = __webpack_require__(42);
	  var propertyDesc = __webpack_require__(34);
	  var hide = __webpack_require__(13);
	  var redefineAll = __webpack_require__(44);
	  var toInteger = __webpack_require__(25);
	  var toLength = __webpack_require__(9);
	  var toIndex = __webpack_require__(130);
	  var toAbsoluteIndex = __webpack_require__(38);
	  var toPrimitive = __webpack_require__(23);
	  var has = __webpack_require__(12);
	  var classof = __webpack_require__(54);
	  var isObject = __webpack_require__(4);
	  var toObject = __webpack_require__(10);
	  var isArrayIter = __webpack_require__(90);
	  var create = __webpack_require__(39);
	  var getPrototypeOf = __webpack_require__(18);
	  var gOPN = __webpack_require__(40).f;
	  var getIterFn = __webpack_require__(92);
	  var uid = __webpack_require__(35);
	  var wks = __webpack_require__(6);
	  var createArrayMethod = __webpack_require__(27);
	  var createArrayIncludes = __webpack_require__(59);
	  var speciesConstructor = __webpack_require__(66);
	  var ArrayIterators = __webpack_require__(95);
	  var Iterators = __webpack_require__(49);
	  var $iterDetect = __webpack_require__(63);
	  var setSpecies = __webpack_require__(41);
	  var arrayFill = __webpack_require__(94);
	  var arrayCopyWithin = __webpack_require__(120);
	  var $DP = __webpack_require__(8);
	  var $GOPD = __webpack_require__(17);
	  var dP = $DP.f;
	  var gOPD = $GOPD.f;
	  var RangeError = global.RangeError;
	  var TypeError = global.TypeError;
	  var Uint8Array = global.Uint8Array;
	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var PROTOTYPE = 'prototype';
	  var ArrayProto = Array[PROTOTYPE];
	  var $ArrayBuffer = $buffer.ArrayBuffer;
	  var $DataView = $buffer.DataView;
	  var arrayForEach = createArrayMethod(0);
	  var arrayFilter = createArrayMethod(2);
	  var arraySome = createArrayMethod(3);
	  var arrayEvery = createArrayMethod(4);
	  var arrayFind = createArrayMethod(5);
	  var arrayFindIndex = createArrayMethod(6);
	  var arrayIncludes = createArrayIncludes(true);
	  var arrayIndexOf = createArrayIncludes(false);
	  var arrayValues = ArrayIterators.values;
	  var arrayKeys = ArrayIterators.keys;
	  var arrayEntries = ArrayIterators.entries;
	  var arrayLastIndexOf = ArrayProto.lastIndexOf;
	  var arrayReduce = ArrayProto.reduce;
	  var arrayReduceRight = ArrayProto.reduceRight;
	  var arrayJoin = ArrayProto.join;
	  var arraySort = ArrayProto.sort;
	  var arraySlice = ArrayProto.slice;
	  var arrayToString = ArrayProto.toString;
	  var arrayToLocaleString = ArrayProto.toLocaleString;
	  var ITERATOR = wks('iterator');
	  var TAG = wks('toStringTag');
	  var TYPED_CONSTRUCTOR = uid('typed_constructor');
	  var DEF_CONSTRUCTOR = uid('def_constructor');
	  var ALL_CONSTRUCTORS = $typed.CONSTR;
	  var TYPED_ARRAY = $typed.TYPED;
	  var VIEW = $typed.VIEW;
	  var WRONG_LENGTH = 'Wrong length!';

	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });

	  var LITTLE_ENDIAN = fails(function () {
	    // eslint-disable-next-line no-undef
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });

	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });

	  var toOffset = function (it, BYTES) {
	    var offset = toInteger(it);
	    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	    return offset;
	  };

	  var validate = function (it) {
	    if (isObject(it) && TYPED_ARRAY in it) return it;
	    throw TypeError(it + ' is not a typed array!');
	  };

	  var allocate = function (C, length) {
	    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };

	  var speciesFromList = function (O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };

	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = allocate(C, length);
	    while (length > index) result[index] = list[index++];
	    return result;
	  };

	  var addGetter = function (it, key, internal) {
	    dP(it, key, { get: function () { return this._d[internal]; } });
	  };

	  var $from = function from(source /* , mapfn, thisArg */) {
	    var O = toObject(source);
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var iterFn = getIterFn(O);
	    var i, length, values, result, step, iterator;
	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      } O = values;
	    }
	    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };

	  var $of = function of(/* ...items */) {
	    var index = 0;
	    var length = arguments.length;
	    var result = allocate(this, length);
	    while (length > index) result[index] = arguments[index++];
	    return result;
	  };

	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };

	  var proto = {
	    copyWithin: function copyWithin(target, start /* , end */) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /* , thisArg */) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /* , thisArg */) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /* , thisArg */) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /* , thisArg */) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /* , thisArg */) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /* , fromIndex */) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /* , fromIndex */) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) { // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /* , thisArg */) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this;
	      var length = validate(that).length;
	      var middle = Math.floor(length / 2);
	      var index = 0;
	      var value;
	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      } return that;
	    },
	    some: function some(callbackfn /* , thisArg */) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this);
	      var length = O.length;
	      var $begin = toAbsoluteIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
	      );
	    }
	  };

	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };

	  var $set = function set(arrayLike /* , offset */) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1);
	    var length = this.length;
	    var src = toObject(arrayLike);
	    var len = toLength(src.length);
	    var index = 0;
	    if (len + offset > length) throw RangeError(WRONG_LENGTH);
	    while (index < len) this[offset + index] = src[index++];
	  };

	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };

	  var isTAIndex = function (target, key) {
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ) {
	      target[key] = desc.value;
	      return target;
	    } return dP(target, key, desc);
	  };

	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }

	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });

	  if (fails(function () { arrayToString.call({}); })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }

	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function () { /* noop */ },
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function () { return this[TYPED_ARRAY]; }
	  });

	  // eslint-disable-next-line max-statements
	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + KEY;
	    var SETTER = 'set' + KEY;
	    var TypedArray = global[NAME];
	    var Base = TypedArray || {};
	    var TAC = TypedArray && getPrototypeOf(TypedArray);
	    var FORCED = !TypedArray || !$typed.ABV;
	    var O = {};
	    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function (that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function (that, index, value) {
	      var data = that._d;
	      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function (that, index) {
	      dP(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0;
	        var offset = 0;
	        var buffer, byteLength, length, klass;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!fails(function () {
	      TypedArray(1);
	    }) || !fails(function () {
	      new TypedArray(-1); // eslint-disable-line no-new
	    }) || !$iterDetect(function (iter) {
	      new TypedArray(); // eslint-disable-line no-new
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(1.5); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if (!isObject(data)) return new Base(toIndex(data));
	        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
	        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator = TypedArrayPrototype[ITERATOR];
	    var CORRECT_ITER_NAME = !!$nativeIterator
	      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	    var $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function () { return NAME; }
	      });
	    }

	    O[NAME] = TypedArray;

	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES
	    });

	    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
	      from: $from,
	      of: $of
	    });

	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	    $export($export.P, NAME, proto);

	    setSpecies(NAME);

	    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, { slice: $slice });

	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, { toLocaleString: $toLocaleString });

	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function () { /* empty */ };


	/***/ }),
	/* 31 */
	/***/ (function(module, exports, __webpack_require__) {

	var Map = __webpack_require__(125);
	var $export = __webpack_require__(0);
	var shared = __webpack_require__(58)('metadata');
	var store = shared.store || (shared.store = new (__webpack_require__(128))());

	var getOrCreateMetadataMap = function (target, targetKey, create) {
	  var targetMetadata = store.get(target);
	  if (!targetMetadata) {
	    if (!create) return undefined;
	    store.set(target, targetMetadata = new Map());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map());
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function (target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
	  return keys;
	};
	var toMetaKey = function (it) {
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function (O) {
	  $export($export.S, 'Reflect', O);
	};

	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};


	/***/ }),
	/* 32 */
	/***/ (function(module, exports, __webpack_require__) {

	var META = __webpack_require__(35)('meta');
	var isObject = __webpack_require__(4);
	var has = __webpack_require__(12);
	var setDesc = __webpack_require__(8).f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !__webpack_require__(3)(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};


	/***/ }),
	/* 33 */
	/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(6)('unscopables');
	var ArrayProto = Array.prototype;
	if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(13)(ArrayProto, UNSCOPABLES, {});
	module.exports = function (key) {
	  ArrayProto[UNSCOPABLES][key] = true;
	};


	/***/ }),
	/* 34 */
	/***/ (function(module, exports) {

	module.exports = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};


	/***/ }),
	/* 35 */
	/***/ (function(module, exports) {

	var id = 0;
	var px = Math.random();
	module.exports = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};


	/***/ }),
	/* 36 */
	/***/ (function(module, exports) {

	module.exports = false;


	/***/ }),
	/* 37 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = __webpack_require__(106);
	var enumBugKeys = __webpack_require__(77);

	module.exports = Object.keys || function keys(O) {
	  return $keys(O, enumBugKeys);
	};


	/***/ }),
	/* 38 */
	/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(25);
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};


	/***/ }),
	/* 39 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = __webpack_require__(1);
	var dPs = __webpack_require__(107);
	var enumBugKeys = __webpack_require__(77);
	var IE_PROTO = __webpack_require__(76)('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(74)('iframe');
	  var i = enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(78).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


	/***/ }),
	/* 40 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = __webpack_require__(106);
	var hiddenKeys = __webpack_require__(77).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};


	/***/ }),
	/* 41 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var dP = __webpack_require__(8);
	var DESCRIPTORS = __webpack_require__(7);
	var SPECIES = __webpack_require__(6)('species');

	module.exports = function (KEY) {
	  var C = global[KEY];
	  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};


	/***/ }),
	/* 42 */
	/***/ (function(module, exports) {

	module.exports = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};


	/***/ }),
	/* 43 */
	/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(19);
	var call = __webpack_require__(118);
	var isArrayIter = __webpack_require__(90);
	var anObject = __webpack_require__(1);
	var toLength = __webpack_require__(9);
	var getIterFn = __webpack_require__(92);
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
	  var f = ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = call(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;


	/***/ }),
	/* 44 */
	/***/ (function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(14);
	module.exports = function (target, src, safe) {
	  for (var key in src) redefine(target, key, src[key], safe);
	  return target;
	};


	/***/ }),
	/* 45 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(55), __webpack_require__(5), __webpack_require__(56), __webpack_require__(46)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphPosition, _graphUtil, _EventEmitter2, _waveform) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphPosition2 = _interopRequireDefault(_graphPosition);

	  var util = _interopRequireWildcard(_graphUtil);

	  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

	  var _waveform2 = _interopRequireDefault(_waveform);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var _slicedToArray = function () {
	    function sliceIterator(arr, i) {
	      var _arr = [];
	      var _n = true;
	      var _d = false;
	      var _e = undefined;

	      try {
	        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	          _arr.push(_s.value);

	          if (i && _arr.length === i) break;
	        }
	      } catch (err) {
	        _d = true;
	        _e = err;
	      } finally {
	        try {
	          if (!_n && _i["return"]) _i["return"]();
	        } finally {
	          if (_d) throw _e;
	        }
	      }

	      return _arr;
	    }

	    return function (arr, i) {
	      if (Array.isArray(arr)) {
	        return arr;
	      } else if (Symbol.iterator in Object(arr)) {
	        return sliceIterator(arr, i);
	      } else {
	        throw new TypeError("Invalid attempt to destructure non-iterable instance");
	      }
	    };
	  }();

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  /**
	   * Default graph parameters
	   * @name Graph~GraphOptionsDefault
	   * @name GraphOptions
	   * @object
	   * @static
	   * @memberof Graph
	   * @prop {String} title - Title of the graph
	   * @prop {Number} paddingTop - The top padding
	   * @prop {Number} paddingLeft - The left padding
	   * @prop {Number} paddingRight - The right padding
	   * @prop {Number} paddingBottom - The bottom padding
	   * @prop {(Number|Boolean)} padding - A common padding value for top, bottom, left and right
	   * @prop {Number} fontSize - The basic text size of the graphs
	   * @prop {Number} fontFamily - The basic font family. Should be installed on the computer of the user
	   * @prop {Object.<String,Object>} plugins - A list of plugins to import with their options
	   * @prop {Object.<String,Object>} pluginAction - The default key combination to access those actions
	   * @prop {Object.<String,Object>} mouseActions - Alias of pluginActions
	   * @prop {Object.<String,Object>} keyActions - Defines what happens when keys are pressed
	   * @prop {Object} wheel - Define the mouse wheel action
	   * @prop {Object} dblclick - Define the double click action
	   * @prop {Boolean} shapesUniqueSelection - true to allow only one shape to be selected at the time
	   * @prop {Boolean} shapesUnselectOnClick - true to unselect all shapes on click
	   */
	  var GraphOptionsDefault = {

	    title: '',

	    paddingTop: 30,
	    paddingBottom: 5,
	    paddingLeft: 20,
	    paddingRight: 20,

	    close: {
	      left: true,
	      right: true,
	      top: true,
	      bottom: true
	    },

	    closeColor: 'black',

	    fontSize: 12,
	    fontFamily: 'Myriad Pro, Helvetica, Arial',

	    plugins: {},
	    pluginAction: {},
	    mouseActions: [],
	    keyActions: [],
	    wheel: {},
	    dblclick: {},

	    shapesUnselectOnClick: true,
	    shapesUniqueSelection: true
	  };

	  var defaultScatterStyle = {
	    shape: 'circle',
	    r: 4
	  };

	  var _constructors = new Map();

	  /**
	   * Entry class of jsGraph that creates a new graph.
	   * @extends EventEmitter
	   * @tutorial basic
	   */

	  var Graph = function (_EventEmitter) {
	    _inherits(Graph, _EventEmitter);

	    /**
	     * Graph constructor
	     * @param {(HTMLElement|String)} [wrapper ] - The DOM Wrapper element its ```id``` property. If you do not use the wrapper during the graph creation, use it with the @link{Graph.setWrapper} method
	     * @param {GraphOptions} [ options ] - The options of the graph
	     * @param {Object} [ axis ] - The list of axes
	     * @param {Array} axis.left - The list of left axes
	     * @param {Array} axis.bottom - The list of bottom axes
	     * @param {Array} axis.top - The list of top axes
	     * @param {Array} axis.right - The list of right axes
	     * @example var graph = new Graph("someDomID");
	     * @example var graph = new Graph("someOtherDomID", { title: 'Graph title', paddingRight: 100 } );
	     */
	    function Graph(wrapper, options, axis) {
	      _classCallCheck(this, Graph);

	      var _this = _possibleConstructorReturn(this, (Graph.__proto__ || Object.getPrototypeOf(Graph)).call(this));

	      /*
	        The unique ID of the graph
	        @name Graph#uniqueid
	        @type String
	      */
	      _this._creation = util.guid();
	      _this._drawn = false;

	      if (wrapper === Object(wrapper) && !(wrapper instanceof HTMLElement)) {
	        // Wrapper is options
	        axis = options;
	        options = wrapper;
	        wrapper = null;
	      } else if (typeof wrapper == 'string') {
	        wrapper = document.getElementById(wrapper);
	      } else if (typeof wrapper.length == 'number') {
	        wrapper = wrapper[0];
	      }

	      /**
	       * @object
	       * @memberof Graph
	       * @name Graph#options
	       * @type GraphOptions
	       * @default {@link GraphOptionsDefault}
	       * Access directly the options of the graph using this public object.
	       * @example graph.options.mouseActions.push( {  } );
	       */
	      _this.options = util.extend({}, GraphOptionsDefault, options);
	      // Options declaration must be placed before the doDom operation

	      // doDom is a private method. We bind it to this thanks to ES6 features
	      doDom.bind(_this)();

	      if (wrapper) {
	        _this.setWrapper(wrapper);
	      }

	      _this.prevented = false;

	      _this.axis = {
	        left: [],
	        top: [],
	        bottom: [],
	        right: []
	      };

	      _this.shapes = [];
	      _this.shapesLocked = false;
	      _this.plugins = {};

	      for (var i in _this.options.pluginAction) {
	        _this.options.pluginAction.plugin = i;
	        _this.options.mouseActions.push(_this.options.pluginAction);
	      }

	      _this.selectedShapes = [];

	      _this.series = [];
	      //this._dom = wrapper;
	      _this._axesHaveChanged = true;

	      if (_this.options.hasOwnProperty('padding') && util.isNumeric(_this.options.padding)) {
	        _this.options.paddingTop = _this.options.paddingBottom = _this.options.paddingLeft = _this.options.paddingRight = _this.options.padding;
	      }

	      _this.currentAction = false;

	      _this.ns = Graph.ns;
	      _this.nsxlink = Graph.nsxlink;

	      // Load all axes
	      if (axis) {
	        for (var i in axis) {
	          for (var j = 0, l = axis[i].length; j < l; j++) {

	            switch (i) {

	              case 'top':
	                _this.getTopAxis(j, axis[i][j]);
	                break;
	              case 'left':
	                _this.getLeftAxis(j, axis[i][j]);
	                break;
	              case 'right':
	                _this.getRightAxis(j, axis[i][j]);
	                break;
	              case 'bottom':
	                _this.getBottomAxis(j, axis[i][j]);
	                break;

	              default:
	                // Do not do anything
	                break;
	            }
	          }
	        }
	      }

	      _this._pluginsInit();

	      return _this;
	    }

	    _createClass(Graph, [{
	      key: 'setWrapper',
	      value: function setWrapper(wrapper) {

	        if (!wrapper) {
	          throw new Error('The wrapper DOM element was not found.');
	        }

	        if (!wrapper.appendChild) {
	          throw new Error('The wrapper appears to be an invalid HTMLElement');
	        }

	        wrapper.style['-webkit-user-select'] = 'none';
	        wrapper.style['-moz-user-select'] = 'none';
	        wrapper.style['-o-user-select'] = 'none';
	        wrapper.style['-ms-user-select'] = 'none';
	        wrapper.style['user-select'] = 'none';

	        wrapper.style.position = 'relative';
	        wrapper.style.outline = 'none';

	        // Why would that be necessary ?
	        // wrapper.setAttribute( 'tabindex', 1 );

	        this.wrapper = wrapper;

	        // DOM

	        if (!this.height || !this.width) {
	          var wrapperStyle = getComputedStyle(wrapper);
	          var w = parseInt(wrapperStyle.width, 10);
	          var h = parseInt(wrapperStyle.height, 10);
	          this.setSize(w, h);
	          this._resize();
	        }

	        wrapper.appendChild(this.dom);

	        _registerEvents(this);
	      }
	    }, {
	      key: 'getDom',
	      value: function getDom() {
	        return this.dom;
	      }
	    }, {
	      key: 'getId',
	      value: function getId() {
	        return this._creation;
	      }
	    }, {
	      key: 'getWrapper',
	      value: function getWrapper() {
	        return this.wrapper;
	      }
	    }, {
	      key: 'setOption',
	      value: function setOption(name, val) {
	        this.options[name] = val;
	        return this;
	      }
	    }, {
	      key: 'setTitle',
	      value: function setTitle(title) {
	        this.options.title = title;
	        this.domTitle.textContent = title;
	      }
	    }, {
	      key: 'displayTitle',
	      value: function displayTitle() {
	        this.domTitle.setAttribute('display', 'inline');
	      }
	    }, {
	      key: 'hideTitle',
	      value: function hideTitle() {
	        this.domTitle.setAttribute('display', 'none');
	      }
	    }, {
	      key: 'hide',
	      value: function hide() {
	        if (this.dom.style.display !== 'none') {
	          this.dom.style.display = 'none';
	        }
	      }
	    }, {
	      key: 'show',
	      value: function show() {
	        if (this.dom.style.display == 'none') {
	          this.dom.style.display = 'initial';
	        }
	      }
	    }, {
	      key: 'redraw',
	      value: function redraw(onlyIfAxesHaveChanged, force) {

	        if (!this.width || !this.height) {
	          return;
	        }

	        if (!this.sizeSet) {
	          this._resize();
	          this.executeRedrawSlaves();
	          return true;
	        } else {

	          if (!onlyIfAxesHaveChanged || force || haveAxesChanged(this) || hasSizeChanged(this)) {
	            this.executeRedrawSlaves();
	            refreshDrawingZone(this);
	            return true;
	          }
	        }

	        this.executeRedrawSlaves(true);
	        return false;
	      }
	    }, {
	      key: 'executeRedrawSlaves',
	      value: function executeRedrawSlaves() {
	        this._pluginsExecute('preDraw');
	      }
	    }, {
	      key: 'draw',
	      value: function draw(force) {

	        this.drawn = true;
	        this.updateLegend(true);
	        this.drawSeries(this.redraw(true, force));

	        this._pluginsExecute('postDraw');
	      }
	    }, {
	      key: 'delayUpdate',
	      value: function delayUpdate() {
	        this._lockUpdate = true;
	        return this;
	      }
	    }, {
	      key: 'doUpdate',
	      value: function doUpdate() {
	        if (this.legend) {
	          this.legend.update();
	        }
	        this.draw();
	        if (this.legend) {
	          this.legend.update();
	        }
	        return this;
	      }
	    }, {
	      key: 'resumeUpdate',
	      value: function resumeUpdate() {
	        this._lockUpdate = false;
	        return this;
	      }
	    }, {
	      key: 'isDelayedUpdate',
	      value: function isDelayedUpdate() {
	        return this._lockUpdate;
	      }
	    }, {
	      key: 'setWidth',
	      value: function setWidth(width, skipResize) {
	        this.width = width;
	        if (!skipResize) {
	          this._resize();
	        }
	      }
	    }, {
	      key: 'setHeight',
	      value: function setHeight(height, skipResize) {
	        this.height = height;
	        if (!skipResize) {
	          this._resize();
	        }
	      }
	    }, {
	      key: 'resize',
	      value: function resize(w, h) {
	        if (w && h) {
	          this.setSize(w, h);
	        }

	        this._resize();
	        return this;
	      }
	    }, {
	      key: 'setSize',
	      value: function setSize(w, h) {
	        this.setWidth(w, true);
	        this.setHeight(h, true);
	        this.getDrawingHeight();
	        this.getDrawingWidth();
	      }
	    }, {
	      key: 'getWidth',
	      value: function getWidth() {
	        return this.width;
	      }
	    }, {
	      key: 'getHeight',
	      value: function getHeight() {
	        return this.height;
	      }
	    }, {
	      key: 'getPaddingTop',
	      value: function getPaddingTop() {
	        return this.options.paddingTop;
	      }
	    }, {
	      key: 'getPaddingLeft',
	      value: function getPaddingLeft() {
	        return this.options.paddingLeft;
	      }
	    }, {
	      key: 'getPaddingBottom',
	      value: function getPaddingBottom() {
	        return this.options.paddingBottom;
	      }
	    }, {
	      key: 'getPaddingRight',
	      value: function getPaddingRight() {
	        return this.options.paddingRight;
	      }
	    }, {
	      key: 'getDrawingHeight',
	      value: function getDrawingHeight(useCache) {
	        if (useCache && this.innerHeight) {
	          return this.innerHeight;
	        }
	        return this.innerHeight = this.height - this.options.paddingTop - this.options.paddingBottom;
	      }
	    }, {
	      key: 'getDrawingWidth',
	      value: function getDrawingWidth(useCache) {
	        if (useCache && this.innerWidth) {
	          return this.innerWidth;
	        }
	        return this.innerWidth = this.width - this.options.paddingLeft - this.options.paddingRight;
	      }
	    }, {
	      key: 'cacheOffset',
	      value: function cacheOffset() {
	        this.offsetCached = util.getOffset(this.wrapper);
	      }
	    }, {
	      key: 'uncacheOffset',
	      value: function uncacheOffset() {
	        this.offsetCached = false;
	      }
	    }, {
	      key: 'getXAxis',
	      value: function getXAxis(index, options) {
	        if (this.axis.top.length > 0 && this.axis.bottom.length == 0) {
	          return this.getTopAxis(index, options);
	        }

	        return this.getBottomAxis(index, options);
	      }
	    }, {
	      key: 'getYAxis',
	      value: function getYAxis(index, options) {

	        if (this.axis.right.length > 0 && this.axis.left.length == 0) {
	          return this.getRightAxis(index, options);
	        }

	        return this.getLeftAxis(index, options);
	      }
	    }, {
	      key: 'getTopAxis',
	      value: function getTopAxis(index, options) {
	        return _getAxis(this, index, options, 'top');
	      }
	    }, {
	      key: 'getBottomAxis',
	      value: function getBottomAxis(index, options) {
	        return _getAxis(this, index, options, 'bottom');
	      }
	    }, {
	      key: 'getLeftAxis',
	      value: function getLeftAxis(index, options) {
	        return _getAxis(this, index, options, 'left');
	      }
	    }, {
	      key: 'getRightAxis',
	      value: function getRightAxis(index, options) {
	        return _getAxis(this, index, options, 'right');
	      }
	    }, {
	      key: 'setXAxis',
	      value: function setXAxis(axis, index) {
	        this.setBottomAxis(axis, index);
	      }
	    }, {
	      key: 'setYAxis',
	      value: function setYAxis(axis, index) {
	        this.setLeftAxis(axis, index);
	      }
	    }, {
	      key: 'setLeftAxis',
	      value: function setLeftAxis(axis, index) {
	        index = index || 0;

	        if (this.axis.left[index]) {
	          this.axis.left[index].kill();
	        }
	        this.axis.left[index] = axis;
	      }
	    }, {
	      key: 'setRightAxis',
	      value: function setRightAxis(axis, index) {
	        index = index || 0;

	        if (this.axis.right[index]) {
	          this.axis.right[index].kill();
	        }
	        this.axis.right[index] = axis;
	      }
	    }, {
	      key: 'setTopAxis',
	      value: function setTopAxis(axis, index) {
	        index = index || 0;

	        if (this.axis.top[index]) {
	          this.axis.top[index].kill();
	        }
	        this.axis.top[index] = axis;
	      }
	    }, {
	      key: 'setBottomAxis',
	      value: function setBottomAxis(axis, index) {
	        index = index || 0;

	        if (this.axis.bottom[index]) {
	          this.axis.bottom[index].kill();
	        }
	        this.axis.bottom[index] = axis;
	      }
	    }, {
	      key: 'killAxis',
	      value: function killAxis(axis) {
	        var noRedraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	        var noSerieKill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


	        var index;

	        if (axis.isX()) {

	          if ((index = this.axis.bottom.indexOf(axis)) > -1) {
	            this.axis.bottom.splice(index, 1);
	          }

	          if ((index = this.axis.top.indexOf(axis)) > -1) {
	            this.axis.top.splice(index, 1);
	          }

	          if (!noSerieKill) {
	            this.series.forEach(function (serie) {

	              if (serie.getXAxis() == axis) {
	                serie.kill();
	              }
	            });
	          }
	        }

	        if (axis.isY()) {

	          if ((index = this.axis.left.indexOf(axis)) > -1) {
	            this.axis.left.splice(index, 1);
	          }

	          if ((index = this.axis.right.indexOf(axis)) > -1) {
	            this.axis.right.splice(index, 1);
	          }

	          if (!noSerieKill) {
	            this.series.forEach(function (serie) {

	              if (serie.getYAxis() == axis) {
	                serie.kill();
	              }
	            });
	          }
	        }

	        this.axisGroup.removeChild(axis.group); // Removes all DOM
	        this.groupPrimaryGrids.removeChild(axis.gridPrimary);
	        this.groupSecondaryGrids.removeChild(axis.gridSecondary);

	        if (!noRedraw) {
	          this.draw(true);
	        }
	      }
	    }, {
	      key: 'hasXAxis',
	      value: function hasXAxis(axis) {
	        return this.hasTopAxis(axis) || this.hasBottomAxis(axis);
	      }
	    }, {
	      key: 'hasYAxis',
	      value: function hasYAxis(axis) {
	        return this.hasLeftAxis(axis) || this.hasRightAxis(axis);
	      }
	    }, {
	      key: 'hasTopAxis',
	      value: function hasTopAxis(axis) {
	        return this.hasAxis(axis, this.axis.top);
	      }
	    }, {
	      key: 'hasBottomAxis',
	      value: function hasBottomAxis(axis) {
	        return this.hasAxis(axis, this.axis.bottom);
	      }
	    }, {
	      key: 'hasLeftAxis',
	      value: function hasLeftAxis(axis) {
	        return this.hasAxis(axis, this.axis.left);
	      }
	    }, {
	      key: 'hasRightAxis',
	      value: function hasRightAxis(axis) {
	        return this.hasAxis(axis, this.axis.right);
	      }
	    }, {
	      key: 'hasAxis',
	      value: function hasAxis(axis, axisList) {
	        for (var i = 0, l = axisList.length; i < l; i++) {
	          if (axisList[i] == axis) {
	            return true;
	          }

	          if (axisList[i].hasAxis(axis)) {
	            return true;
	          }
	        }

	        return false;
	      }
	    }, {
	      key: 'autoscaleAxes',
	      value: function autoscaleAxes() {

	        this._applyToAxes('setMinMaxToFitSeries', null, true, true);

	        //this._applyToAxes( "scaleToFitAxis", [ this.getYAxis() ], false, true )
	        // X is not always ascending...
	        return this;
	      }
	    }, {
	      key: 'autoscale',
	      value: function autoscale() {
	        return this.autoscaleAxes.apply(this, arguments);
	      }
	    }, {
	      key: 'autoScale',
	      value: function autoScale() {
	        return this.autoscaleAxes.apply(this, arguments);
	      }
	    }, {
	      key: 'autoScaleAxes',
	      value: function autoScaleAxes() {
	        return this.autoscaleAxes.apply(this, arguments);
	      }
	    }, {
	      key: 'autoScaleAxis',
	      value: function autoScaleAxis(axis) {
	        if (!axis) {
	          return this;
	        }

	        axis.setMinMaxToFitSeries();
	        return this;
	      }
	    }, {
	      key: 'setBackgroundColor',
	      value: function setBackgroundColor(color) {

	        this.rectEvent.setAttribute('fill', color);
	        return this;
	      }
	    }, {
	      key: 'getAxisState',
	      value: function getAxisState() {

	        var state = {};
	        for (var i in this.axis) {
	          state[i] = this.axis[i].map(function (axis) {
	            return [axis.getCurrentMin(), axis.getCurrentMax()];
	          });
	        }
	        return state;
	      }
	    }, {
	      key: 'setAxisState',
	      value: function setAxisState(state) {

	        var j, l;
	        for (var i in state) {

	          if (!this.axis[i]) {
	            continue;
	          }

	          for (j = 0, l = state[i].length; j < l; j++) {

	            if (!this.axis[i][j]) {
	              continue;
	            }

	            this.axis[i][j].setCurrentMin(state[i][j][0]);
	            this.axis[i][j].setCurrentMax(state[i][j][1]);
	          }
	        }

	        this.draw();
	      }
	    }, {
	      key: 'saveAxisState',
	      value: function saveAxisState(savedName) {
	        this.savedAxisState = this.savedAxisState || {};
	        this.savedAxisState[savedName] = this.getAxisState();
	        return this;
	      }
	    }, {
	      key: 'recallAxisState',
	      value: function recallAxisState(savedName) {
	        if (this.savedAxisState[savedName]) {
	          this.recallAxisState(this.savedAxisState[savedName]);
	        }
	        return this;
	      }
	    }, {
	      key: '_applyToAxis',
	      value: function _applyToAxis(type) {

	        switch (type) {

	          case 'string':
	            return function (type, func, params) {
	              //    params.splice(1, 0, type);

	              for (var i = 0; i < this.axis[type].length; i++) {
	                this.axis[type][i][func].apply(this.axis[type][i], params);
	              }
	            };

	          case 'function':
	            return function (type, func, params) {
	              for (var i = 0; i < this.axis[type].length; i++) {
	                func.call(this, this.axis[type][i], type, params);
	              }
	            };

	          default:
	            throw new Error('You must either execute a function or provide a string that registers a function');
	        }
	      }
	    }, {
	      key: 'getBoundaryAxis',
	      value: function getBoundaryAxis(axis, minmax, usingZValues) {

	        var valSeries = this.getBoundaryAxisFromSeries(axis, minmax, usingZValues);
	        //  var valShapes = this.getBoundaryAxisFromShapes( axis, xy, minmax );
	        return valSeries;
	        //return Math[ minmax ]( valSeries, valShapes );
	      }
	    }, {
	      key: 'getBoundaryAxisFromSeries',
	      value: function getBoundaryAxisFromSeries(axis, minmax, usingZValues) {

	        var min = minmax == 'min',
	            val,
	            func = axis.isX() ? ['getMinX', 'getMaxX'] : ['getMinY', 'getMaxY'],
	            func2use = func[min ? 0 : 1],
	            infinity2use = min ? +Infinity : -Infinity,
	            serie,
	            series,
	            serieValue,
	            i,
	            l;

	        val = infinity2use;
	        series = this.getSeriesFromAxis(axis);

	        for (i = 0, l = series.length; i < l; i++) {

	          serie = series[i];

	          if (!serie.isShown()) {
	            continue;
	          }

	          serieValue = serie[func2use](usingZValues);
	          val = Math[minmax](isNaN(val) ? infinity2use : val, isNaN(serieValue) ? infinity2use : serieValue);
	        }

	        return val;
	      }
	    }, {
	      key: 'getSeriesFromAxis',
	      value: function getSeriesFromAxis(axis) {
	        var series = [],
	            i = this.series.length - 1;

	        for (; i >= 0; i--) {
	          if (this.series[i].getXAxis() == axis || this.series[i].getYAxis() == axis) {
	            series.push(this.series[i]);
	          }
	        }

	        return series;
	      }
	    }, {
	      key: 'updateDataMinMaxAxes',
	      value: function updateDataMinMaxAxes(usingZValues) {

	        var axisvars = ['bottom', 'top', 'left', 'right'],
	            axis,
	            j,
	            l,
	            i;

	        for (j = 0, l = axisvars.length; j < l; j++) {

	          for (i = this.axis[axisvars[j]].length - 1; i >= 0; i--) {

	            axis = this.axis[axisvars[j]][i];

	            // 25.10.2017. Wait a second, this cannot be real. Even hidden axes must have min max values.
	            // The data can be displayed while the axis is hidden
	            // I assume this was added to cover another bug, but another approach must be chosen
	            if (!axis.isShown()) ;
	            //          continue;


	            //console.log( axisvars[ j ], this.getBoundaryAxisFromSeries( this.axis[ axisvars[ j ] ][ i ], xy, 'min'), this.getBoundaryAxisFromSeries( this.axis[ axisvars[ j ] ][ i ], xy, 'max') );

	            var min = this.getBoundaryAxis(this.axis[axisvars[j]][i], 'min', usingZValues);
	            var max = this.getBoundaryAxis(this.axis[axisvars[j]][i], 'max', usingZValues);

	            if (isFinite(max)) {
	              axis.setMaxValueData(max);
	            }
	            if (isFinite(min)) {
	              axis.setMinValueData(min);
	            }
	          }
	        }
	      }
	    }, {
	      key: '_applyToAxes',
	      value: function _applyToAxes(func, params, tb, lr) {

	        var ax = [],
	            i = 0,
	            l;

	        if (tb || tb == undefined) {
	          ax.push('top');
	          ax.push('bottom');
	        }
	        if (lr || lr == undefined) {
	          ax.push('left');
	          ax.push('right');
	        }

	        for (l = ax.length; i < l; i++) {
	          this._applyToAxis(typeof func === 'undefined' ? 'undefined' : _typeof(func)).call(this, ax[i], func, params);
	        }
	      }
	    }, {
	      key: 'findAxesLinkedTo',
	      value: function findAxesLinkedTo(axis) {

	        var axes = [];
	        this._applyToAxes(function (a) {

	          if (a.linkedToAxis && a.linkedToAxis.axis == axis) {
	            axes.push(a);
	          }
	        }, {}, axis instanceof this.getConstructor('graph.axis.x'), axis instanceof this.getConstructor('graph.axis.y'));

	        return axes;
	      }
	    }, {
	      key: '_axisHasChanged',
	      value: function _axisHasChanged() {
	        this._axesHaveChanged = true;
	      }
	    }, {
	      key: 'newSerie',
	      value: function newSerie(name, options, type) {

	        var serie = void 0;

	        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object' && !type) {
	          type = options;
	          options = {};
	        }

	        if (!type) {
	          type = Graph.SERIE_LINE;
	        }

	        if (serie = this.getSerie(name)) {
	          return serie;
	        }

	        if (!(serie = makeSerie(this, name, options, type))) {
	          return;
	        }

	        this.series.push(serie);
	        this.emit('newSerie', serie);
	        return serie;
	      }
	    }, {
	      key: 'getSerie',
	      value: function getSerie(name) {

	        if (typeof name == 'number') {
	          return this.series[name] || false;
	        }

	        if (typeof name == 'function') {
	          name = name();
	        }

	        var i = 0,
	            l = this.series.length;

	        for (; i < l; i++) {

	          if (this.series[i].getName() == name || this.series[i] == name) {

	            return this.series[i];
	          }
	        }

	        return false;
	      }
	    }, {
	      key: 'getSeries',
	      value: function getSeries() {
	        return this.series;
	      }
	    }, {
	      key: 'allSeries',
	      value: function allSeries() {
	        for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
	          types[_key] = arguments[_key];
	        }

	        return this.series.filter(function (serie) {
	          return types.include(serie.getType());
	        });
	      }
	    }, {
	      key: 'drawSerie',
	      value: function drawSerie(serie, force) {

	        if (!serie.draw) {
	          throw new Error('Serie has no method draw');
	        }

	        serie.draw(force);
	      }
	    }, {
	      key: 'drawSeries',
	      value: function drawSeries(force) {

	        if (!this.width || !this.height) {
	          return;
	        }

	        var i = this.series.length - 1;
	        for (; i >= 0; i--) {
	          if (this.series[i].isShown()) {
	            this.drawSerie(this.series[i], force);
	          }
	        }
	      }
	    }, {
	      key: 'resetSeries',
	      value: function resetSeries() {
	        this.removeSeries();
	      }
	    }, {
	      key: 'killSeries',
	      value: function killSeries() {
	        this.resetSeries();
	      }
	    }, {
	      key: 'removeSeries',
	      value: function removeSeries() {
	        while (this.series[0]) {
	          this.series[0].kill(true);
	        }
	        this.series = [];

	        if (this.legend) {
	          this.legend.update();
	        }
	      }
	    }, {
	      key: 'selectSerie',
	      value: function selectSerie(serie, selectName) {

	        if (!((typeof serie === 'undefined' ? 'undefined' : _typeof(serie)) == 'object')) {
	          serie = this.getSerie(serie);
	        }

	        if (this.selectedSerie == serie && this.selectedSerie.selectionType == selectName) {
	          return;
	        }

	        if (this.selectedSerie !== serie && this.selectedSerie) {
	          this.unselectSerie(this.selectedSerie);
	        }

	        this.selectedSerie = serie;
	        this.triggerEvent('onSelectSerie', serie);

	        serie.select(selectName || 'selected');
	      }
	    }, {
	      key: 'getSelectedSerie',
	      value: function getSelectedSerie() {
	        return this.selectedSerie;
	      }
	    }, {
	      key: 'unselectSerie',
	      value: function unselectSerie(serie) {

	        if (!serie.unselect) {
	          return;
	        }

	        serie.unselect();
	        this.selectedSerie = false;
	        this.triggerEvent('onUnselectSerie', serie);
	      }
	    }, {
	      key: 'getShapesOfSerie',
	      value: function getShapesOfSerie(serie) {

	        var shapes = [];
	        var i = this.shapes.length - 1;

	        for (; i >= 0; i--) {

	          if (this.shapes[i].getSerie() == serie) {
	            shapes.push(this.shapes[i]);
	          }
	        }

	        return shapes;
	      }
	    }, {
	      key: 'makeToolbar',
	      value: function makeToolbar(toolbarData) {

	        var constructor = this.getConstructor('graph.toolbar');
	        if (constructor) {
	          return this.toolbar = new constructor(this, toolbarData);
	        } else {
	          return util.throwError('No constructor exists for toolbar');
	        }
	      }
	    }, {
	      key: 'getShapes',
	      value: function getShapes() {
	        return this.shapes || [];
	      }
	    }, {
	      key: 'newShape',
	      value: function newShape(shapeType, shapeData) {
	        var mute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	        var shapeProperties = arguments[3];


	        this.prevent(false);

	        if (!mute) {

	          this.emit('beforeNewShape', shapeData);

	          if (this.prevent(false)) {
	            return false;
	          }
	        }

	        // Backward compatibility
	        if ((typeof shapeType === 'undefined' ? 'undefined' : _typeof(shapeType)) == 'object') {
	          mute = shapeData;
	          shapeData = shapeType;
	          shapeType = shapeData.type;
	        }

	        shapeData = shapeData || {};
	        shapeData._id = util.guid();

	        var constructor;
	        if (typeof shapeType == 'function') {
	          constructor = shapeType;
	        } else {
	          constructor = this.getConstructor('graph.shape.' + shapeType);
	        }

	        if (!constructor) {
	          return util.throwError('No constructor for this shape');
	        }

	        var shape = new constructor(this, shapeData);

	        if (!shape) {
	          return util.throwError('Failed to construct shape.');
	        }

	        shape.type = shapeType;
	        shape.graph = this;
	        shape._data = shapeData;

	        if (shapeData.properties !== undefined) {
	          shape.setProperties(shapeData.properties);
	        }

	        shape.init(this, shapeProperties);

	        if (shapeData.props !== undefined) {
	          for (var i in shapeData.props) {
	            shape.setProp(i, shapeData.props[i]);
	          }
	        }

	        if (shapeData.position) {

	          for (var i = 0, l = shapeData.position.length; i < l; i++) {
	            shape.setPosition(new _graphPosition2.default(shapeData.position[i]), i);
	          }
	        }

	        /* Setting shape properties */
	        if (shapeData.fillColor !== undefined) {
	          shape.setFillColor(shapeData.fillColor);
	        }

	        if (shapeData.fillOpacity !== undefined) {
	          shape.setFillOpacity(shapeData.fillOpacity);
	        }

	        if (shapeData.strokeColor !== undefined) {
	          shape.setStrokeColor(shapeData.strokeColor);
	        }

	        if (shapeData.strokeWidth !== undefined) {
	          shape.setStrokeWidth(shapeData.strokeWidth);
	        }

	        if (shapeData.layer !== undefined) {
	          shape.setLayer(shapeData.layer);
	        }

	        if (shapeData.locked == true) {
	          shape.lock();
	        }

	        if (shapeData.movable == true) {
	          shape.movable();
	        }

	        if (shapeData.selectable == true) {
	          shape.selectable();
	        }

	        if (shapeData.resizable == true) {
	          shape.resizable();
	        }

	        if (shapeData.attributes !== undefined) {
	          shape.setProp('attributes', shapeData.attributes);
	        }

	        if (shapeData.handles !== undefined) {
	          shape.setProp('handles', shapeData.handles);
	        }

	        if (shapeData.selectOnMouseDown !== undefined) {
	          shape.setProp('selectOnMouseDown', true);
	        }

	        if (shapeData.selectOnClick !== undefined) {
	          shape.setProp('selectOnClick', true);
	        }

	        if (shapeData.transforms !== undefined && Array.isArray(shapeData.transforms)) {

	          shapeData.transforms.forEach(function (_ref) {
	            var type = _ref.type,
	                value = _ref.value;


	            shape.addTransform(type, value);
	          });
	        }

	        if (shapeData.highlightOnMouseOver !== undefined) {
	          shape.setProp('highlightOnMouseOver', true);
	        }

	        if (shapeData.labelEditable) {
	          shape.setProp('labelEditable', shapeData.labelEditable);
	        }

	        if (shapeData.labels && !shapeData.label) {
	          shapeData.label = shapeData.labels;
	        }

	        if (shapeData.label !== undefined) {

	          if (!Array.isArray(shapeData.label)) {
	            shapeData.label = [shapeData.label];
	          }

	          for (var i = 0, l = shapeData.label.length; i < l; i++) {

	            shape.showLabel(i);
	            shape.setLabelText(shapeData.label[i].text, i);
	            shape.setLabelPosition(shapeData.label[i].position, i);
	            shape.setLabelColor(shapeData.label[i].color || 'black', i);
	            shape.setLabelSize(shapeData.label[i].size, i);
	            shape.setLabelAngle(shapeData.label[i].angle || 0, i);
	            shape.setLabelBaseline(shapeData.label[i].baseline || 'no-change', i);
	            shape.setLabelAnchor(shapeData.label[i].anchor || 'start', i);
	            shape.setLabelBackgroundColor(shapeData.label[i].backgroundColor || 'transparent', i);
	            shape.setLabelBackgroundOpacity(shapeData.label[i].backgroundOpacity || 1, i);
	          }
	        }

	        if (shapeData.serie) {
	          shape.setSerie(this.getSerie(shapeData.serie));
	        }
	        shape.createHandles();
	        shape.applyStyle();

	        this.shapes.push(shape);

	        if (!mute) {
	          this.emit('newShape', shape, shapeData);
	        }

	        return shape;
	      }
	    }, {
	      key: 'newPosition',
	      value: function newPosition(varArgs) {

	        return new (Function.prototype.bind.apply(_graphPosition2.default, [null].concat(Array.prototype.slice.call(arguments))))();

	        // 18 September 2016 Norman: What is that ?
	        //Array.prototype.unshift.call( arguments, null );
	        //return new( Function.prototype.bind.apply( GraphPosition, arguments ) )();
	      }
	    }, {
	      key: 'redrawShapes',
	      value: function redrawShapes() {

	        //this.graphingZone.removeChild(this.shapeZone);
	        for (var i = 0, l = this.shapes.length; i < l; i++) {
	          this.shapes[i].redraw();
	        }
	        //this.graphingZone.insertBefore(this.shapeZone, this.axisGroup);
	      }
	    }, {
	      key: 'removeShapes',
	      value: function removeShapes() {
	        for (var i = 0, l = this.shapes.length; i < l; i++) {
	          if (this.shapes[i] && this.shapes[i].kill) {
	            this.shapes[i].kill(true);
	          }
	        }
	        this.shapes = [];
	      }
	    }, {
	      key: 'selectShape',
	      value: function selectShape(shape, mute) {

	        // Already selected. Returns false

	        if (!shape) {
	          return;
	        }

	        if (this.selectedShapes.indexOf(shape) > -1) {
	          return false;
	        }

	        if (!shape.isSelectable()) {
	          return false;
	        }

	        if (!mute) {
	          this.emit('beforeShapeSelect', shape);
	        }

	        if (this.prevent(false)) {
	          return;
	        }

	        if (this.selectedShapes.length > 0 && this.options.shapesUniqueSelection) {
	          // Only one selected shape at the time

	          this.unselectShapes(mute);
	        }

	        shape._select(mute);
	        this.selectedShapes.push(shape);

	        if (!mute) {
	          this.emit('shapeSelect', shape);
	        }
	      }
	    }, {
	      key: 'getSelectedShapes',
	      value: function getSelectedShapes() {
	        return this.selectedShapes;
	      }
	    }, {
	      key: 'unselectShape',
	      value: function unselectShape(shape, mute) {

	        if (this.selectedShapes.indexOf(shape) == -1) {
	          return;
	        }

	        if (!mute) {
	          this.emit('beforeShapeUnselect', shape);
	        }

	        if (this.cancelUnselectShape) {
	          this.cancelUnselectShape = false;
	          return;
	        }

	        shape._unselect();

	        this.selectedShapes.splice(this.selectedShapes.indexOf(shape), 1);

	        if (!mute) {
	          this.emit('shapeUnselect', shape);
	        }
	      }
	    }, {
	      key: 'unselectShapes',
	      value: function unselectShapes(mute) {

	        while (this.selectedShapes[0]) {
	          this.unselectShape(this.selectedShapes[0], mute);
	        }

	        return this;
	      }
	    }, {
	      key: '_removeShape',
	      value: function _removeShape(shape) {
	        this.shapes.splice(this.shapes.indexOf(shape), 1);
	      }
	    }, {
	      key: 'appendShapeToDom',
	      value: function appendShapeToDom(shape) {

	        if (shape.isHTML()) {
	          this.wrapper.insertBefore(shape._dom, this.dom);
	        }

	        this.getLayer(shape.getLayer(), 'shape').appendChild(shape.group);
	      }
	    }, {
	      key: 'removeShapeFromDom',
	      value: function removeShapeFromDom(shape) {

	        if (shape.isHTML()) {
	          this.wrapper.removeChild(shape._dom);
	        }

	        this.getLayer(shape.getLayer(), 'shape').removeChild(shape.group);
	      }
	    }, {
	      key: 'appendSerieToDom',
	      value: function appendSerieToDom(serie) {
	        this.getLayer(serie.getLayer(), 'serie').appendChild(serie.groupMain);
	      }
	    }, {
	      key: 'removeSerieFromDom',
	      value: function removeSerieFromDom(serie) {
	        this.getLayer(serie.getLayer(), 'serie').removeChild(serie.groupMain);
	      }
	    }, {
	      key: 'getLayer',
	      value: function getLayer(layer, mode) {

	        if (!this.layers[layer]) {

	          this.layers[layer] = [];

	          this.layers[layer][0] = document.createElementNS(Graph.ns, 'g');
	          this.layers[layer][0].setAttribute('data-layer', layer);
	          this.layers[layer][1] = document.createElementNS(Graph.ns, 'g');
	          this.layers[layer][2] = document.createElementNS(Graph.ns, 'g');

	          this.layers[layer][0].appendChild(this.layers[layer][1]);
	          this.layers[layer][0].appendChild(this.layers[layer][2]);

	          var i = 1,
	              prevLayer;

	          while (!(prevLayer = this.layers[layer - i]) && layer - i >= 0) {
	            i++;
	          }

	          if (!prevLayer) {

	            this.plotGroup.insertBefore(this.layers[layer][0], this.plotGroup.firstChild);
	          } else if (prevLayer.nextSibling) {

	            this.plotGroup.insertBefore(this.layers[layer][0], prevLayer.nextSibling);
	          } else {

	            this.plotGroup.appendChild(this.layers[layer][0]);
	          }
	        }

	        return this.layers[layer][mode == 'shape' ? 2 : 1];
	      }
	    }, {
	      key: 'focus',
	      value: function focus() {
	        this.wrapper.focus();
	      }
	    }, {
	      key: 'elementMoving',
	      value: function elementMoving(movingElement) {
	        this.bypassHandleMouse = movingElement;
	      }
	    }, {
	      key: 'stopElementMoving',
	      value: function stopElementMoving(element) {

	        if (element && element == this.bypassHandleMouse) {
	          this.bypassHandleMouse = false;
	        } else if (!element) {
	          this.bypassHandleMouse = false;
	        }
	      }
	    }, {
	      key: '_makeClosingLines',
	      value: function _makeClosingLines() {

	        this.closingLines = {};
	        var els = ['top', 'bottom', 'left', 'right'],
	            i = 0,
	            l = 4;
	        for (; i < l; i++) {
	          var line = document.createElementNS(Graph.ns, 'line');
	          line.setAttribute('stroke', this.options.closeColor);
	          line.setAttribute('shape-rendering', 'crispEdges');
	          line.setAttribute('stroke-linecap', 'square');
	          line.setAttribute('display', 'none');
	          this.closingLines[els[i]] = line;
	          this.graphingZone.appendChild(line);
	        }
	      }
	    }, {
	      key: 'isActionAllowed',
	      value: function isActionAllowed(e, action) {

	        if (action.type !== e.type && (action.type !== undefined || e.type !== 'mousedown') && !((e.type === 'wheel' || e.type === 'mousewheel') && action.type == 'mousewheel')) {
	          return;
	        }

	        if (action.enabled && (typeof action.enabled == 'function' ? !action.enabled(this) : !action.enabled)) {
	          return;
	        }

	        if (action.key) {

	          if (action.key !== e.keyCode) {

	            var keyCheck = {
	              'backspace': 8,
	              'enter': 13,
	              'tab': 9,
	              'shift': 16,
	              'ctrl': 17,
	              'alt': 18,
	              'pause': 19,
	              'escape': 27,
	              'up': 33,
	              'down': 34,
	              'left': 37,
	              'right': 39
	            };

	            if (keyCheck[action.key] !== e.keyCode) {
	              return;
	            }
	          }
	        }

	        if (action.shift === undefined) {
	          action.shift = false;
	        }

	        if (action.ctrl === undefined) {
	          action.ctrl = false;
	        }

	        if (action.meta === undefined) {
	          action.meta = false;
	        }

	        if (action.alt === undefined) {
	          action.alt = false;
	        }

	        return e.shiftKey == action.shift && e.ctrlKey == action.ctrl && e.metaKey == action.meta && e.altKey == action.alt;
	      }
	    }, {
	      key: 'forcePlugin',
	      value: function forcePlugin(plugin) {
	        this.forcedPlugin = plugin;
	      }
	    }, {
	      key: 'unforcePlugin',
	      value: function unforcePlugin() {
	        this.forcedPlugin = false;
	      }
	    }, {
	      key: '_pluginsExecute',
	      value: function _pluginsExecute(funcName) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	          args[_key2 - 1] = arguments[_key2];
	        }

	        //			Array.prototype.splice.apply(args, [0, 0, this]);

	        for (var i in this.plugins) {

	          if (this.plugins[i] && this.plugins[i][funcName]) {

	            this.plugins[i][funcName].apply(this.plugins[i], args);
	          }
	        }
	      }
	    }, {
	      key: '_pluginExecute',
	      value: function _pluginExecute(which, func, args) {

	        //Array.prototype.splice.apply( args, [ 0, 0, this ] );
	        if (!which) {
	          return;
	        }

	        if (this.plugins[which] && this.plugins[which][func]) {

	          this.plugins[which][func].apply(this.plugins[which], args);
	          return true;
	        }
	      }
	    }, {
	      key: 'pluginYieldActiveState',
	      value: function pluginYieldActiveState() {
	        this.activePlugin = false;
	      }
	    }, {
	      key: '_serieExecute',
	      value: function _serieExecute(serie, func, args) {

	        if ((typeof serie === 'undefined' ? 'undefined' : _typeof(serie)) !== 'object') {
	          serie = this.getSerie(serie);
	        }

	        if (typeof serie[func] == 'function') {
	          serie.apply(serie, args);
	        }
	      }
	    }, {
	      key: '_pluginsInit',
	      value: function _pluginsInit() {

	        var constructor, pluginName, pluginOptions;

	        for (var i in this.options.plugins) {

	          pluginName = i;
	          pluginOptions = this.options.plugins[i];

	          constructor = this.getConstructor('graph.plugin.' + pluginName);

	          if (constructor) {

	            //var options = util.extend( true, {}, constructor.defaults(), pluginOptions );
	            this.plugins[pluginName] = new constructor(pluginOptions);

	            util.mapEventEmission(this.plugins[pluginName].options, this.plugins[pluginName]);
	            this.plugins[pluginName].init(this, pluginOptions);
	          } else {
	            util.throwError('Plugin "' + pluginName + '" has not been registered');
	          }
	        }
	      }
	    }, {
	      key: 'getPlugin',
	      value: function getPlugin(pluginName) {
	        var plugin = this.plugins[pluginName];

	        if (!plugin) {
	          return util.throwError('Plugin "' + pluginName + '" has not been loaded or properly registered');
	        }

	        return plugin;
	      }
	    }, {
	      key: 'triggerEvent',
	      value: function triggerEvent() {
	        var func = arguments[0];
	        /*,
	              args = Array.prototype.splice.apply( arguments, [ 0, 1 ] );
	        */
	        if (typeof this.options[func] == 'function') {
	          return this.options[func].apply(this, arguments);
	        }
	      }
	    }, {
	      key: 'makeLegend',
	      value: function makeLegend(options) {

	        if (this.legend) {
	          return this.legend;
	        }

	        var constructor = this.getConstructor('graph.legend');
	        if (constructor) {
	          this.legend = new constructor(this, options);
	        } else {
	          return util.throwError('Graph legend is not available as it has not been registered');
	        }

	        return this.legend;
	      }
	    }, {
	      key: 'updateLegend',
	      value: function updateLegend() {
	        var onlyIfRequired = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


	        if (!this.legend) {
	          return;
	        }

	        this.legend.update(onlyIfRequired);
	        return this;
	      }
	    }, {
	      key: 'getLegend',
	      value: function getLegend() {
	        if (!this.legend) {
	          return;
	        }

	        return this.legend;
	      }
	    }, {
	      key: 'requireLegendUpdate',
	      value: function requireLegendUpdate() {

	        if (!this.legend) {
	          return;
	        }

	        this.legend.requireDelayedUpdate();
	      }
	    }, {
	      key: 'orthogonalProjectionSetup',
	      value: function orthogonalProjectionSetup() {

	        this.options.zAxis = util.extend(true, {
	          maxZ: 10,
	          minZ: 0,
	          shiftX: -25,
	          shiftY: -15,
	          xAxis: this.getXAxis(),
	          yAxis: this.getYAxis()
	        });
	      }
	    }, {
	      key: 'orthogonalProjectionUpdate',
	      value: function orthogonalProjectionUpdate() {
	        var _this2 = this;

	        if (!this.zAxis) {
	          this.zAxis = {
	            g: document.createElementNS(Graph.ns, 'g'),
	            l: document.createElementNS(Graph.ns, 'line')
	          };

	          this.zAxis.g.appendChild(this.zAxis.l);
	          this.groupGrids.appendChild(this.zAxis.g);
	        }

	        var refAxisX = this.options.zAxis.xAxis;
	        var refAxisY = this.options.zAxis.yAxis;

	        var x0 = refAxisX.getMinPx();
	        var y0 = refAxisY.getMinPx();

	        var dx = refAxisX.getZProj(this.options.zAxis.maxZ);
	        var dy = refAxisY.getZProj(this.options.zAxis.maxZ);

	        this.zAxis.l.setAttribute('stroke', 'black');
	        this.zAxis.l.setAttribute('x1', x0);
	        this.zAxis.l.setAttribute('x2', x0 + dx);
	        this.zAxis.l.setAttribute('y1', y0);
	        this.zAxis.l.setAttribute('y2', y0 + dy);

	        this.updateDataMinMaxAxes(true);

	        var sort = this.series.map(function (serie) {
	          return [serie.getZPos(), serie];
	        });

	        sort.sort(function (sa, sb) {
	          return sb[0] - sa[0];
	        });

	        var i = 0;
	        sort.forEach(function (s) {
	          s[1].setLayer(i);
	          _this2.appendSerieToDom(s[1]);
	          i++;
	        });

	        this.drawSeries(true);
	      }
	    }, {
	      key: 'kill',
	      value: function kill() {
	        this.wrapper.removeChild(this.dom);
	      }
	    }, {
	      key: '_removeSerie',
	      value: function _removeSerie(serie) {
	        this.series.splice(this.series.indexOf(serie), 1);
	        this._pluginsExecute('serieRemoved', serie);
	      }
	    }, {
	      key: 'contextListen',
	      value: function contextListen(target, menuElements, callback) {

	        if (this.options.onContextMenuListen) {
	          return this.options.onContextMenuListen(target, menuElements, callback);
	        }
	      }
	    }, {
	      key: 'lockShapes',
	      value: function lockShapes() {
	        this.shapesLocked = true;

	        // Removes the current actions of the shapes
	        for (var i = 0, l = this.shapes.length; i < l; i++) {
	          this.shapes[i].moving = false;
	          this.shapes[i].resizing = false;
	        }
	      }
	    }, {
	      key: 'unlockShapes',
	      value: function unlockShapes() {
	        //		console.log('unlock');
	        this.shapesLocked = false;
	      }
	    }, {
	      key: 'prevent',
	      value: function prevent(arg) {
	        var curr = this.prevented;
	        if (arg != -1) {
	          this.prevented = arg == undefined || arg;
	        }
	        return curr;
	      }
	    }, {
	      key: '_getXY',
	      value: function _getXY(e) {

	        var x = e.clientX,
	            y = e.clientY;

	        var pos = this.offsetCached || util.getOffset(this.wrapper);

	        x -= pos.left;
	        y -= pos.top;

	        return {
	          x: x,
	          y: y
	        };
	      }
	    }, {
	      key: '_resize',
	      value: function _resize() {

	        if (!this.width || !this.height) {
	          return;
	        }

	        this.getDrawingWidth();
	        this.getDrawingHeight();

	        this.sizeSet = true;
	        this.dom.setAttribute('width', this.width);
	        this.dom.setAttribute('height', this.height);
	        this.domTitle.setAttribute('x', this.width / 2);

	        this._sizeChanged = true;

	        if (this.drawn) {
	          this.requireLegendUpdate();
	          this.draw(true);
	        }
	      }
	    }, {
	      key: 'updateGraphingZone',
	      value: function updateGraphingZone() {
	        util.setAttributeTo(this.graphingZone, {
	          'transform': 'translate(' + this.options.paddingLeft + ', ' + this.options.paddingTop + ')'
	        });

	        this._sizeChanged = true;
	      }
	    }, {
	      key: 'getDrawingSpaceWidth',
	      value: function getDrawingSpaceWidth() {
	        var _this3 = this;

	        return function () {
	          return _this3.drawingSpaceWidth;
	        };
	      }
	    }, {
	      key: 'getDrawingSpaceHeight',
	      value: function getDrawingSpaceHeight() {
	        var _this4 = this;

	        return function () {
	          return _this4.drawingSpaceHeight;
	        };
	      }
	    }, {
	      key: 'getDrawingSpaceMinX',
	      value: function getDrawingSpaceMinX() {
	        var _this5 = this;

	        return function () {
	          return _this5.drawingSpaceMinX;
	        };
	      }
	    }, {
	      key: 'getDrawingSpaceMinY',
	      value: function getDrawingSpaceMinY() {
	        var _this6 = this;

	        return function () {
	          return _this6.drawingSpaceMinY;
	        };
	      }
	    }, {
	      key: 'getDrawingSpaceMaxX',
	      value: function getDrawingSpaceMaxX() {
	        var _this7 = this;

	        return function () {
	          return _this7.drawingSpaceMaxX;
	        };
	      }
	    }, {
	      key: 'getDrawingSpaceMaxY',
	      value: function getDrawingSpaceMaxY() {
	        var _this8 = this;

	        return function () {
	          return _this8.drawingSpaceMaxY;
	        };
	      }
	    }, {
	      key: 'trackingLine',
	      value: function trackingLine(options) {
	        var _this9 = this;

	        var self = this;

	        if (typeof options === 'boolean') {

	          if (this.options.trackingLine) {
	            this.options.trackingLine.enable = options;
	          }
	          return;
	        }

	        if (options) {
	          this.options.trackingLine = options;
	        }

	        options.series = options.series || [];
	        options.enable = options.enable === undefined ? true : !!options.enable;

	        // Individual tracking
	        if (options.mode == 'individual') {

	          if (options.series) {

	            if (!Array.isArray(options.series)) {

	              if (options.series == 'all') {

	                options.series = this.series.map(function (serie) {
	                  return {
	                    serie: serie
	                  };
	                });
	              } else {

	                options.series = [options.series];
	              }
	            }

	            options.series.forEach(function (sOptions) {

	              if (_typeof(sOptions.serie) !== 'object') {

	                if ((typeof sOptions === 'undefined' ? 'undefined' : _typeof(sOptions)) !== 'object') {
	                  throw new Error('Misuse of the trackingLine() method. Each serie must be an object with the serie property: { series: [ { serie: jsGraphSerie, options: { ... someOptions } } ] }');
	                }

	                sOptions.serie = _this9.getSerie(sOptions.serie);
	              }

	              if (!sOptions.serie) {
	                return;
	              }

	              self.addSerieToTrackingLine(sOptions.serie, sOptions);
	            });
	          }
	        } else {

	          options.series.forEach(function (serie) {
	            serie.serie.disableTracking();
	          });
	        }

	        if (options.noLine) {
	          return;
	        }

	        if (!this.trackingObject) {
	          // Avoid multiple creation of tracking lines

	          // Creates a new shape called trackingLine, in the first layer (below everything)
	          this.trackingObject = this.newShape('line', util.extend(true, {
	            position: [{
	              y: 'min'
	            }, {
	              y: 'max'
	            }],
	            stroke: 'black',
	            layer: -1
	          }, options.trackingLineShapeOptions));
	        }

	        this.trackingObject.draw();

	        return this.trackingObject;
	      }
	    }, {
	      key: 'addSerieToTrackingLine',
	      value: function addSerieToTrackingLine(serie, options) {
	        var _this10 = this;

	        if (!this.options.trackingLine) {

	          this.trackingLine({
	            mode: 'individual'
	          });
	        }

	        this.options.trackingLine.series.forEach(function (serieO, index) {
	          if (serieO.serie == serie) {
	            _this10.options.trackingLine.series.splice(index, 1);
	          }
	        });

	        this.options.trackingLine.series.push(Object.assign({
	          serie: serie
	        }, options));

	        serie.enableTracking(function (serie, index, x, y) {

	          if (_this10.options.trackingLine.enable) {

	            if (index) {

	              if (_this10.trackingObject) {

	                _this10.trackingObject.show();
	                _this10.trackingObject.getPosition(0).x = index.trueX; //serie.getData()[ 0 ][ index.closestIndex * 2 ];
	                _this10.trackingObject.getPosition(1).x = index.trueX; //serie.getData()[ 0 ][ index.closestIndex * 2 ];
	                _this10.trackingObject.redraw();
	              }

	              serie._trackingLegend = _trackingLegendSerie(_this10, {
	                serie: serie
	              }, x, y, serie._trackingLegend, options.textMethod ? options.textMethod : function (output) {

	                for (var i in output) {
	                  return output[i].serie.serie.getName() + ': ' + output[i].serie.serie.getYAxis().valueToHtml(output[i].yValue);
	                }
	              }, index.trueX);

	              if (serie._trackingLegend) {
	                serie._trackingLegend.style.display = 'block';
	              }
	            }
	          }
	        }, function (serie) {

	          if (_this10.trackingObject) {
	            _this10.trackingObject.hide();
	          }

	          if (serie.trackingShape) {
	            serie.trackingShape.hide();
	          }

	          if (serie._trackingLegend) {
	            serie._trackingLegend.style.display = 'none';
	          }

	          serie._trackingLegend = _trackingLegendSerie(_this10, {

	            serie: serie

	          }, false, false, serie._trackingLegend, false, false);
	        });
	      }
	    }, {
	      key: 'setKatexRenderer',
	      value: function setKatexRenderer(renderer) {
	        this._katexRenderer = renderer;
	      }
	    }, {
	      key: 'hasKatexRenderer',
	      value: function hasKatexRenderer() {
	        return !!this._katexRenderer;
	      }
	    }, {
	      key: 'renderWithKatex',
	      value: function renderWithKatex(katexValue, katexElement) {

	        if (this._katexRenderer) {

	          if (katexElement) {
	            katexElement.removeChild(katexElement.firstChild);
	          } else {
	            katexElement = document.createElementNS(Graph.ns, 'foreignObject');
	          }

	          var div = document.createElement('div');

	          katexElement.appendChild(div);
	          this._katexRenderer(katexValue, div);

	          return katexElement;
	        }

	        return false;
	      }
	    }, {
	      key: 'exportToSchema',
	      value: function exportToSchema() {
	        var _this11 = this;

	        var schema = {};

	        schema.title = this.options.title;

	        schema.width = this.getWidth();
	        schema.height = this.getHeight();

	        var axesPositions = ['top', 'bottom', 'left', 'right'];
	        var axesExport = [];
	        var allaxes = {
	          x: [],
	          y: []
	        };

	        axesPositions.map(function (axisPosition) {

	          if (!_this11.axis[axisPosition]) {
	            return;
	          }

	          axesExport = axesExport.concat(_this11.axis[axisPosition].map(function (axis) {
	            return {

	              type: axisPosition,
	              label: axis.options.label,
	              unit: axis.options.unit,
	              min: axis.options.forcedMin,
	              max: axis.options.forcedMax,
	              flip: axis.options.flipped

	            };
	          }));

	          if (axisPosition == 'top' || axisPosition == 'bottom') {
	            allaxes.x = allaxes.x.concat(_this11.axis[axisPosition]);
	          } else {
	            allaxes.y = allaxes.y.concat(_this11.axis[axisPosition]);
	          }
	        });

	        schema.axis = axesExport;

	        var seriesExport = [];

	        var toType = function toType(type) {
	          switch (type) {

	            case Graph.SERIE_LINE:
	              return 'line';
	              break;

	            case Graph.SERIE_BAR:
	              return 'bar';
	              break;

	            case Graph.SERIE_LINE_COLORED:
	              return 'color';
	              break;

	            case Graph.SERIE_SCATTER:
	              return 'scatter';
	              break;
	          }
	        };

	        var exportData = function exportData(serie, x) {

	          var data = [];

	          switch (serie.getType()) {

	            case Graph.SERIE_LINE:

	              for (var i = 0; i < serie.data.length; i++) {

	                for (var j = 0; j < serie.data[i].length - 1; j += 2) {

	                  data.push(serie.data[i][j + (x && serie.isFlipped() || !x && !serie.isFlipped() ? 1 : 0)]);
	                }
	              }
	              break;

	            case Graph.SERIE_SCATTER:

	              for (var j = 0; j < serie.data.length - 1; j += 2) {

	                data.push(serie.data[i + (x && serie.isFlipped() || !x && !serie.isFlipped() ? 1 : 0)]);
	              }

	              break;
	          }

	          return data;
	        };

	        schema.data = seriesExport.concat(this.series.map(function (serie) {

	          var style = [];
	          var linestyle = [];

	          if (serie.getType() == Graph.SERIE_LINE) {

	            for (var stylename in serie.styles) {
	              linestyle.push({
	                styleName: stylename,
	                color: serie.styles[stylename].lineColor,
	                lineWidth: serie.styles[stylename].lineWidth,
	                lineStyle: serie.styles[stylename].lineStyle
	              });

	              var styleObj = {
	                styleName: stylename,
	                styles: []
	              };
	              style.push(styleObj);

	              styleObj.styles = styleObj.styles.concat((serie.styles[stylename].markers || []).map(function (markers) {
	                return {
	                  shape: markers.type,
	                  zoom: markers.zoom,
	                  lineWidth: markers.strokeWidth,
	                  lineColor: markers.strokeColor,
	                  color: markers.fillColor,
	                  points: markers.points
	                };
	              }));
	            }
	          }

	          return {
	            label: serie.getLabel(),
	            id: serie.getName(),
	            type: toType(serie.getType()),
	            x: exportData(serie, true),
	            y: exportData(serie, false),
	            xAxis: allaxes.x.indexOf(serie.getXAxis()),
	            yAxis: allaxes.y.indexOf(serie.getYAxis()),
	            style: style,
	            lineStyle: linestyle
	          };
	        }));

	        return schema;
	      }
	    }], [{
	      key: 'fromJSON',
	      value: function fromJSON(schema, wrapper) {

	        var graph = void 0,
	            options = {},
	            axes = {
	          left: [],
	          top: [],
	          right: [],
	          bottom: []
	        },
	            style = void 0;

	        if (schema.title) {
	          options.title = schema.title;
	        }

	        if (schema.axis) {

	          schema.axis.forEach(function (schemaAxis) {

	            if (!schemaAxis.type) {
	              util.throwError('Axis type is required (top, bottom, left or right)');
	            }

	            var axisOptions = {};
	            if (schemaAxis.label) {
	              axisOptions.labelValue = schemaAxis.label;
	            }

	            if (schemaAxis.unit !== undefined) {
	              axisOptions.unit = schemaAxis.unit;
	            }

	            if (schemaAxis.unitWrapperAfter !== undefined) {
	              axisOptions.unitWrapperAfter = schemaAxis.unitWrapperAfter;
	            }

	            if (schemaAxis.unitWrapperBefore !== undefined) {
	              axisOptions.unitWrapperBefore = schemaAxis.unitWrapperBefore;
	            }

	            if (schemaAxis.min !== undefined) {
	              axisOptions.forcedMin = schemaAxis.min;
	            }

	            if (schemaAxis.max !== undefined) {
	              axisOptions.forcedMax = schemaAxis.max;
	            }

	            if (schemaAxis.flip !== undefined) {
	              axisOptions.flipped = schemaAxis.flip;
	            }

	            axes[schemaAxis.type].push(axisOptions);
	            schemaAxis._jsGraphIndex = axes[schemaAxis.type].length - 1;
	          });
	        }

	        graph = new Graph(wrapper, options, axes);

	        if (schema.width) {
	          graph.setWidth(schema.width);
	        }

	        if (schema.height) {
	          graph.setHeight(schema.width);
	        }

	        graph._resize();

	        if (schema.data) {

	          schema.data.forEach(function (schemaSerie) {

	            var serieType = schemaSerie.type,
	                serie,
	                serieOptions = {},
	                serieAxis;

	            var waveform = void 0;

	            switch (schemaSerie.type) {

	              case 'bar':
	                util.throwError('Bar charts not supported');
	                serieType = false;
	                break;

	              case 'color':
	                serieType = Graph.SERIE_LINE_COLORED;
	                break;

	              case 'scatter':
	                serieType = Graph.SERIE_SCATTER;
	                break;

	              case 'box':
	                serieType = Graph.SERIE_BOX;

	                if (schemaSerie.orientation == 'x' || schemaSerie.orientation == 'y') {
	                  serieOptions.orientation = schemaSerie.orientation;
	                }
	                break;

	              default:
	                serieType = Graph.SERIE_LINE;
	                break;
	            }

	            if (serieType !== Graph.SERIE_BOX) {
	              waveform = Graph.newWaveform();
	            }

	            if (!serieType) {
	              util.throwError('No valid serie type was found');
	              return;
	            }

	            serie = graph.newSerie(schemaSerie.id || schemaSerie.label || util.guid(), serieOptions, serieType);

	            if (schemaSerie.lineStyle) {

	              var lineStyle = void 0;

	              if (Array.isArray(lineStyle)) {
	                lineStyle = {
	                  unselected: lineStyle
	                };
	              }

	              Object.entries(lineStyle).forEach(function (_ref2) {
	                var _ref3 = _slicedToArray(_ref2, 2),
	                    styleName = _ref3[0],
	                    style = _ref3[1];

	                var styleSerie = {};

	                switch (serieType) {

	                  case Graph.SERIE_LINE:
	                    if (style.lineWidth !== undefined) {
	                      styleSerie.lineWidth = style.lineWidth;
	                    }

	                    if (style.color !== undefined) {
	                      styleSerie.lineColor = style.color;
	                    }

	                    if (style.lineStyle) {
	                      styleSerie.lineStyle = style.lineStyle;
	                    }

	                    serie.setStyle(styleSerie, styleName);
	                    break;
	                }
	              });
	            }

	            var defaultStyle = {};
	            var defaultStyles = {};

	            if (schemaSerie.defaultStyle) {
	              defaultStyle = schemaSerie.defaultStyle;
	            }

	            if (schemaSerie.defaultStyles) {
	              defaultStyles = schemaSerie.defaultStyles;
	            }

	            if (schemaSerie.styles) {

	              var individualStyles = void 0;

	              if (Array.isArray(schemaSerie.styles)) {
	                individualStyles = {
	                  unselected: schemaSerie.styles
	                };
	              } else {
	                individualStyles = schemaSerie.styles;
	              }

	              var styleNames = new Set(Object.keys(defaultStyles).concat(Object.keys(individualStyles)));

	              styleNames.forEach(function (styleName) {
	                var style = [],
	                    styles = void 0;

	                if (individualStyles && individualStyles[styleName]) {

	                  style = individualStyles[styleName];

	                  if (!Array.isArray(style)) {
	                    style = [style];
	                  }

	                  styles = style.map(function (eachStyleElement) {

	                    switch (serieType) {

	                      case Graph.SERIE_LINE:

	                        return {
	                          type: eachStyleElement.shape,
	                          zoom: eachStyleElement.zoom,
	                          strokeWidth: eachStyleElement.lineWidth,
	                          strokeColor: eachStyleElement.lineColor,
	                          fillColor: eachStyleElement.color,
	                          points: eachStyleElement.points
	                        };

	                        break;

	                      case Graph.SERIE_BOX:

	                        return eachStyleElement;

	                        break;

	                      case Graph.SERIE_SCATTER:
	                        return eachStyleElement;

	                        break;
	                    }
	                  });
	                }

	                switch (serieType) {

	                  case Graph.SERIE_LINE:

	                    serie.setMarkers(styles, styleName);
	                    break;

	                  case Graph.SERIE_SCATTER:
	                    serie.setStyle(Object.assign({}, defaultScatterStyle, defaultStyle, defaultStyles[styleName] || {}), styles, styleName);
	                    break;

	                  case Graph.SERIE_BOX:

	                    serie.setStyle(styles[0], styleName || 'unselected');
	                    break;
	                }
	              });
	            }

	            if (schemaSerie.color && serieType == Graph.SERIE_LINE_COLORED) {
	              serie.setColors(schemaSerie.color);
	            }

	            if (serieType !== Graph.SERIE_BOX) {
	              waveform.setData(schemaSerie.y, schemaSerie.x);
	            }

	            if (!serie) {
	              return;
	            }

	            var errorBarsXAbove = [],
	                errorBarsXBelow = [],
	                errorBarsYAbove = [],
	                errorBarsYBelow = [],
	                errorBoxesXAbove = [],
	                errorBoxesXBelow = [],
	                errorBoxesYAbove = [],
	                errorBoxesYBelow = [];

	            if (waveform !== undefined) {
	              if (schemaSerie.errorX) {

	                for (var i = 0, l = schemaSerie.errorX.length; i < l; i++) {

	                  if (Array.isArray(schemaSerie.errorX[i])) {

	                    errorBarsXAbove.push(schemaSerie.errorX[i][0]);
	                    errorBarsXBelow.push(schemaSerie.errorX[i][1]);
	                  } else {
	                    errorBarsXAbove.push(schemaSerie.errorX[i]);
	                    errorBarsXBelow.push(schemaSerie.errorX[i]);
	                  }
	                }
	              } else if (schemaSerie.errorBarX || schemaSerie.errorBoxX) {

	                if (schemaSerie.errorBarX) {

	                  for (var i = 0, l = schemaSerie.errorBarX.length; i < l; i++) {

	                    if (Array.isArray(schemaSerie.errorBarX[i])) {

	                      errorBarsXAbove.push(schemaSerie.errorBarX[i][0]);
	                      errorBarsXBelow.push(schemaSerie.errorBarX[i][1]);
	                    } else {
	                      errorBarsXAbove.push(schemaSerie.errorBarX[i]);
	                      errorBarsXBelow.push(schemaSerie.errorBarX[i]);
	                    }
	                  }
	                }

	                if (schemaSerie.errorBoxX) {

	                  for (var i = 0, l = schemaSerie.errorBoxX.length; i < l; i++) {

	                    if (Array.isArray(schemaSerie.errorBoxX[i])) {

	                      errorBoxesXAbove.push(schemaSerie.errorBoxX[i][0]);
	                      errorBoxesXBelow.push(schemaSerie.errorBoxX[i][1]);
	                    } else {
	                      errorBoxesXAbove.push(schemaSerie.errorBoxX[i]);
	                      errorBoxesXBelow.push(schemaSerie.errorBoxX[i]);
	                    }
	                  }
	                }
	              }

	              if (schemaSerie.errorY) {

	                for (var i = 0, l = schemaSerie.errorY.length; i < l; i++) {

	                  if (Array.isArray(schemaSerie.errorY[i])) {

	                    errorBarsYAbove.push(schemaSerie.errorY[i][0]);
	                    errorBarsYBelow.push(schemaSerie.errorY[i][1]);
	                  } else {
	                    errorBarsYAbove.push(schemaSerie.errorY[i]);
	                    errorBarsYBelow.push(schemaSerie.errorY[i]);
	                  }
	                }
	              } else if (schemaSerie.errorBarY || schemaSerie.errorBoxY) {

	                if (schemaSerie.errorBarY) {

	                  for (var i = 0, l = schemaSerie.errorBarY.length; i < l; i++) {

	                    if (Array.isArray(schemaSerie.errorBarY[i])) {

	                      errorBarsYAbove.push(schemaSerie.errorBarY[i][0]);
	                      errorBarsYBelow.push(schemaSerie.errorBarY[i][1]);
	                    } else {
	                      errorBarsYAbove.push(schemaSerie.errorBarY[i]);
	                      errorBarsYBelow.push(schemaSerie.errorBarY[i]);
	                    }
	                  }
	                }

	                if (schemaSerie.errorBoxY) {

	                  for (var i = 0, l = schemaSerie.errorBoxY.length; i < l; i++) {

	                    if (Array.isArray(schemaSerie.errorBoxY[i])) {

	                      errorBoxesYAbove.push(schemaSerie.errorBoxY[i][0]);
	                      errorBoxesYBelow.push(schemaSerie.errorBoxY[i][1]);
	                    } else {
	                      errorBoxesYAbove.push(schemaSerie.errorBoxY[i]);
	                      errorBoxesYBelow.push(schemaSerie.errorBoxY[i]);
	                    }
	                  }
	                }
	              }

	              style = {};
	              if (errorBarsXAbove.length > 0) {
	                waveform.setErrorBarXAbove(Graph.newWaveform(errorBarsXAbove));
	                style.right = {};
	              }
	              if (errorBarsXBelow.length > 0) {
	                waveform.setErrorBarXAbove(Graph.newWaveform(errorBarsXAbove));
	                style.left = {};
	              }
	              if (errorBarsYAbove.length > 0) {
	                waveform.setErrorBarXAbove(Graph.newWaveform(errorBarsYAbove));
	                style.top = {};
	              }
	              if (errorBarsYBelow.length > 0) {
	                waveform.setErrorBarXAbove(Graph.newWaveform(errorBarsYAbove));
	                style.bottom = {};
	              }

	              serie.setErrorBarStyle(style);

	              style = {};
	              if (errorBoxesXAbove.length > 0) {
	                waveform.setErrorBoxXAbove(Graph.newWaveform(errorBoxesXAbove));
	                style.right = {};
	              }
	              if (errorBoxesXBelow.length > 0) {
	                waveform.setErrorBoxXBelow(Graph.newWaveform(errorBoxesXBelow));
	                style.left = {};
	              }
	              if (errorBoxesYAbove.length > 0) {
	                waveform.setErrorBoxAbove(Graph.newWaveform(errorBoxesYAbove));
	                style.top = {};
	              }
	              if (errorBoxesYBelow.length > 0) {
	                waveform.setErrorBoxBelow(Graph.newWaveform(errorBoxesYBelow));
	                style.bottom = {};
	              }
	              serie.setErrorBoxStyle(style);
	            }

	            if (schema.axis) {
	              serieAxis = schema.axis[schemaSerie.xAxis];

	              if (!serieAxis || serieAxis.type !== 'top' && serieAxis.type !== 'bottom') {
	                util.warn('No x axis found. Setting automatically');
	                serie.setXAxis(graph.getXAxis(0));
	              } else {
	                if (serieAxis.type == 'top') {
	                  serie.setXAxis(graph.getTopAxis(serieAxis._jsGraphIndex));
	                } else if (serieAxis.type == 'bottom') {
	                  serie.setXAxis(graph.getBottomAxis(serieAxis._jsGraphIndex));
	                }
	              }

	              serieAxis = schema.axis[schemaSerie.yAxis];

	              if (!serieAxis || serieAxis.type !== 'left' && serieAxis.type !== 'right') {
	                util.warn('No y axis found. Setting automatically');
	                serie.setYAxis(graph.getYAxis(0));
	              } else {
	                if (serieAxis.type == 'left') {
	                  serie.setYAxis(graph.getLeftAxis(serieAxis._jsGraphIndex));
	                } else if (serieAxis.type == 'right') {
	                  serie.setYAxis(graph.getRightAxis(serieAxis._jsGraphIndex));
	                }
	              }
	            } else {
	              util.warn('No axes found. Setting automatically');
	              serie.autoAxis();
	            }

	            switch (serieType) {

	              case Graph.SERIE_BOX:

	                serie.setData(schemaSerie.boxes);

	                break;

	              default:
	              case Graph.SERIE_SCATTER:
	              case Graph.SERIE_LINE_COLORED:
	              case Graph.SERIE_LINE:

	                serie.setWaveform(waveform);

	                break;
	            }
	          });
	        }

	        graph.autoscaleAxes();
	        graph.draw();

	        return graph;
	      }
	    }, {
	      key: 'registerConstructor',
	      value: function registerConstructor(constructorName, constructor) {

	        if (_constructors.has(constructorName)) {
	          return util.throwError('Constructor ' + constructor + ' already exists.');
	        }

	        _constructors.set(constructorName, constructor);
	      }
	    }, {
	      key: 'getConstructor',
	      value: function getConstructor(constructorName) {
	        var softFail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


	        if (!_constructors.has(constructorName)) {

	          if (softFail) {
	            return false;
	          }

	          return util.throwError('Constructor "' + constructorName + "\" doesn't exist");
	        }

	        return _constructors.get(constructorName);
	      }
	    }, {
	      key: 'newWaveform',
	      value: function newWaveform() {
	        return new (Function.prototype.bind.apply(_waveform2.default, [null].concat(Array.prototype.slice.call(arguments))))();
	      }
	    }, {
	      key: 'waveform',
	      value: function waveform() {
	        return new (Function.prototype.bind.apply(_waveform2.default, [null].concat(Array.prototype.slice.call(arguments))))();
	      }
	    }]);

	    return Graph;
	  }(_EventEmitter3.default);

	  // Adds getConstructor to the prototype. Cannot do that in ES6 classes
	  Graph.prototype.getConstructor = Graph.getConstructor;

	  function makeSerie(graph, name, options, type) {

	    var constructor = graph.getConstructor(type, true);
	    if (!constructor && typeof type == 'string') {
	      constructor = graph.getConstructor('graph.serie.' + type, true);
	    }

	    if (constructor) {

	      var serie = new constructor(graph, name, options);
	      //serie.init( graph, name, options );
	      graph.appendSerieToDom(serie);
	    } else {

	      return util.throwError('No constructor exists for the serie type provided. Use Graph.registerConstructor( name, constructor ) first is you use your own series');
	    }

	    return serie;
	  }

	  function getAxisLevelFromSpan(span, level) {

	    for (var i = 0, l = level.length; i < l; i++) {

	      var possible = true;
	      for (var k = 0, m = level[i].length; k < m; k++) {

	        if (!(span[0] < level[i][k][0] && span[1] < level[i][k][0] || span[0] > level[i][k][1] && span[1] > level[i][k][1])) {
	          possible = false;
	        }
	      }

	      if (possible) {

	        level[i].push(span);
	        return i;
	      }
	    }

	    level.push([span]);
	    return level.length - 1;
	  }

	  function refreshDrawingZone(graph) {
	    var shift = {
	      top: [],
	      bottom: [],
	      left: [],
	      right: []
	    };

	    var levels = {
	      top: [],
	      bottom: [],
	      left: [],
	      right: []
	    };

	    graph._painted = true;
	    // Apply to top and bottom

	    graph._applyToAxes(function (axis, position) {

	      if (!axis.isShown()) {
	        axis.hideGroup();
	        return;
	      } else {
	        axis.showGroup();
	      }

	      if (axis.floating) {
	        return;
	      }

	      var level = getAxisLevelFromSpan(axis.getSpan(), levels[position]);
	      axis.setLevel(level);

	      shift[position][level] = Math.max(axis.getAxisPosition(), shift[position][level] || 0);
	    }, false, true, false);

	    var shiftTop = shift.top.reduce(function (prev, curr) {
	      return prev + curr;
	    }, 0);

	    var shiftBottom = shift.bottom.reduce(function (prev, curr) {
	      return prev + curr;
	    }, 0);

	    graph.drawingSpaceHeight = graph.getDrawingHeight() - shiftTop - shiftBottom;

	    [shift.top, shift.bottom].map(function (arr) {
	      arr.reduce(function (prev, current, index) {
	        arr[index] = prev + current;
	        return prev + current;
	      }, 0);
	    });

	    // Apply to top and bottom
	    graph._applyToAxes(function (axis, position) {

	      if (!axis.isShown() || axis.floating) {
	        return;
	      }

	      axis.setShift(shift[position][axis.getLevel()]);
	    }, false, true, false);

	    // Applied to left and right
	    graph._applyToAxes(function (axis, position) {

	      if (!axis.isShown()) {
	        axis.hideGroup();
	        // Don't return here. We need to go through the draw method as the axis must be assigned minPx and maxPx values.
	        // This is because some series can still be visible although the axis isn't.
	      } else {
	        axis.showGroup();
	      }

	      axis.setMinPx(shiftTop);
	      axis.setMaxPx(graph.getDrawingHeight(true) - shiftBottom);

	      if (axis.floating) {
	        return;
	      }

	      // First we need to draw it in order to determine the width to allocate
	      // graph is done to accomodate 0 and 100000 without overlapping any element in the DOM (label, ...)

	      // Let's not draw dependant axes yet
	      var drawn = !axis.linkedToAxis ? axis.draw() : 0;

	      if (!axis.isShown()) {
	        return;
	      }
	      // Get axis position gives the extra shift that is common
	      var level = getAxisLevelFromSpan(axis.getSpan(), levels[position]);
	      axis.setLevel(level);
	      shift[position][level] = Math.max(drawn, shift[position][level] || 0);
	    }, false, false, true);

	    var shift2 = util.extend(true, {}, shift);

	    // Applied to left and right
	    graph._applyToAxes(function (axis, position) {

	      if (!axis.isShown() || axis.floating) {
	        return;
	      }

	      shift2[position][axis.getLevel()] = Math.max(shift[position][axis.getLevel()], axis.equalizePosition(shift[position][axis.getLevel()]));
	    }, false, false, true);

	    shift = shift2;

	    var shiftLeft = shift.left.reduce(function (prev, curr) {
	      return prev + curr;
	    }, 0);

	    var shiftRight = shift.right.reduce(function (prev, curr) {
	      return prev + curr;
	    }, 0);

	    graph.drawingSpaceWidth = graph.getDrawingWidth() - shiftLeft - shiftRight;

	    [shift.left, shift.right].map(function (arr) {
	      arr.reduce(function (prev, current, index) {
	        arr[index] = prev + current;
	        return prev + current;
	      }, 0);
	    });

	    // Apply to left and right
	    graph._applyToAxes(function (axis, position) {

	      if (!axis.isShown() || axis.floating) {
	        return;
	      }
	      axis.setShift(shift[position][axis.getLevel()]);
	    }, false, false, true);

	    // Apply to top and bottom
	    graph._applyToAxes(function (axis, position) {

	      if (!axis.isShown()) ;

	      axis.setMinPx(shiftLeft);
	      axis.setMaxPx(graph.getDrawingWidth(true) - shiftRight);

	      if (axis.floating) {
	        return;
	      }

	      if (!axis.linkedToAxis) {
	        axis.draw();
	      }
	    }, false, true, false);

	    // Floating axes
	    graph._applyToAxes(function (axis) {

	      if (!axis.floating) {
	        return;
	      }

	      var floatingAxis = axis.getFloatingAxis();
	      var floatingValue = axis.getFloatingValue();
	      var floatingPx = floatingAxis.getPx(floatingValue);

	      axis.setShift(floatingPx);

	      if (!axis.linkedToAxis) {
	        axis.draw();
	      }
	    }, false, true, true);

	    _closeLine(graph, 'right', graph.getDrawingWidth(true), graph.getDrawingWidth(true), shiftTop, graph.getDrawingHeight(true) - shiftBottom);
	    _closeLine(graph, 'left', 0, 0, shiftTop, graph.getDrawingHeight(true) - shiftBottom);
	    _closeLine(graph, 'top', shiftLeft, graph.getDrawingWidth(true) - shiftRight, 0, 0);
	    _closeLine(graph, 'bottom', shiftLeft, graph.getDrawingWidth(true) - shiftRight, graph.getDrawingHeight(true) - shiftBottom, graph.getDrawingHeight(true) - shiftBottom);

	    graph.clipRect.setAttribute('y', shiftTop);
	    graph.clipRect.setAttribute('x', shiftLeft);
	    graph.clipRect.setAttribute('width', graph.getDrawingWidth() - shiftLeft - shiftRight);
	    graph.clipRect.setAttribute('height', graph.getDrawingHeight() - shiftTop - shiftBottom);

	    graph.rectEvent.setAttribute('y', shiftTop + graph.getPaddingTop());
	    graph.rectEvent.setAttribute('x', shiftLeft + graph.getPaddingLeft());

	    graph.rectEvent.setAttribute('width', graph.drawingSpaceWidth);
	    graph.rectEvent.setAttribute('height', graph.drawingSpaceHeight);

	    graph.drawingSpaceMinX = shiftLeft + graph.getPaddingLeft(); // + "px";
	    graph.drawingSpaceMinY = shiftTop + graph.getPaddingTop(); // + "px";
	    graph.drawingSpaceMaxX = graph.getDrawingWidth() - shiftRight + graph.getPaddingLeft(); // + "px";
	    graph.drawingSpaceMaxY = graph.getDrawingHeight() - shiftBottom + graph.getPaddingTop(); //  + "px";

	    // Apply to top and bottom
	    graph._applyToAxes(function (axis, position) {

	      if (!axis.isShown()) {
	        return;
	      }

	      axis.drawLines();
	    }, false, true, true);

	    /*
	    graph.shapeZoneRect.setAttribute('x', shift[1]);
	    graph.shapeZoneRect.setAttribute('y', shift[2]);
	    graph.shapeZoneRect.setAttribute('width', graph.getDrawingWidth() - shift[2] - shift[3]);
	    graph.shapeZoneRect.setAttribute('height', graph.getDrawingHeight() - shift[1] - shift[0]);
	    */
	    graph.shift = shift;
	    graph.redrawShapes(); // Not sure this should be automatic here. The user should be clever.
	  }

	  function _handleKey(graph, event, type) {
	    console.log(event, type);
	    if (graph.forcedPlugin) {

	      graph.activePlugin = graph.forcedPlugin;
	      graph._pluginExecute(graph.activePlugin, type, [graph, event]);
	      return;
	    }

	    checkKeyActions(graph, event, [graph, event], type);
	  }

	  // Similar to checkMouseActions
	  function checkKeyActions(graph, e, parameters, methodName) {

	    var keyComb = graph.options.keyActions,
	        i,
	        l;

	    for (i = 0, l = keyComb.length; i < l; i++) {

	      if (keyComb[i].plugin) {
	        // Is it a plugin ?

	        if (graph.forcedPlugin == keyComb[i].plugin || graph.isActionAllowed(e, keyComb[i])) {

	          if (keyComb[i].options) {
	            parameters.push(keyComb[i].options);
	          }

	          graph.activePlugin = keyComb[i].plugin; // Lease the mouse action to the current action
	          graph._pluginExecute(keyComb[i].plugin, methodName, parameters);

	          e.preventDefault();
	          e.stopPropagation();

	          return true;
	        }
	      } else if (keyComb[i].callback && graph.isActionAllowed(e, keyComb[i])) {

	        if (keyComb[i].options) {
	          parameters.push(keyComb[i].options);
	        }

	        e.preventDefault();
	        e.stopPropagation();

	        keyComb[i].callback.apply(graph, parameters);
	        return true;
	      }

	      if (keyComb[i].removeSelectedShape && graph.isActionAllowed(e, keyComb[i])) {

	        e.preventDefault();
	        e.stopPropagation();

	        graph.selectedShapes.map(function (shape) {

	          shape.kill(keyComb[i].keepInDom);
	        });
	      }

	      /* else if ( keyComb[ i ].series ) {
	         var series;
	        if ( keyComb[ i ].series === 'all' ) {
	          series = graph.series;
	        }
	         if ( !Array.isArray( keyComb[ i ].series ) ) {
	          series = [ series ];
	        }
	         if ( keyComb[ i ].options ) {
	          parameters.push( keyComb[ i ].options );
	        }
	         for ( var j = 0; j < series.length; i++ ) {
	          graph._serieExecute( series[ i ], methodName, parameters );
	        }
	        return true;
	      }*/
	    }

	    return false;
	  }

	  function doDom() {

	    // Create SVG element, set the NS
	    this.dom = document.createElementNS(Graph.ns, 'svg');
	    this.dom.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
	    //this.dom.setAttributeNS(this.ns, 'xmlns:xlink', this.nsxml);
	    util.setAttributeTo(this.dom, {
	      'xmlns': Graph.ns,
	      'font-family': this.options.fontFamily,
	      'font-size': this.options.fontSize
	    });

	    try {
	      util.setAttributeTo(this.dom, {
	        'data-jsgraph-version': 'v2.0.76'
	      });
	    } catch (e) {
	      // ignore
	    }

	    this.defs = document.createElementNS(Graph.ns, 'defs');
	    this.dom.appendChild(this.defs);

	    this.groupEvent = document.createElementNS(Graph.ns, 'g');

	    this.rectEvent = document.createElementNS(Graph.ns, 'rect');
	    util.setAttributeTo(this.rectEvent, {
	      'pointer-events': 'fill',
	      'fill': 'transparent'
	    });
	    this.groupEvent.appendChild(this.rectEvent);

	    this.dom.appendChild(this.groupEvent);

	    // Handling graph title
	    this.domTitle = document.createElementNS(Graph.ns, 'text');
	    this.setTitle(this.options.title);
	    util.setAttributeTo(this.domTitle, {
	      'text-anchor': 'middle',
	      'y': 20
	    });
	    this.groupEvent.appendChild(this.domTitle);
	    //

	    this.graphingZone = document.createElementNS(Graph.ns, 'g');
	    this.updateGraphingZone();

	    this.groupEvent.appendChild(this.graphingZone);

	    /*  this.shapeZoneRect = document.createElementNS(this.ns, 'rect');
	    //this.shapeZoneRect.setAttribute('pointer-events', 'fill');
	    this.shapeZoneRect.setAttribute('fill', 'transparent');
	    this.shapeZone.appendChild(this.shapeZoneRect);
	    */
	    this.axisGroup = document.createElementNS(Graph.ns, 'g');
	    this.graphingZone.appendChild(this.axisGroup);

	    this.groupGrids = document.createElementNS(Graph.ns, 'g');

	    // With the z stacking, this should probably be removed
	    //this.groupGrids.setAttribute( 'clip-path', 'url(#_clipplot' + this._creation + ')' );

	    this.groupPrimaryGrids = document.createElementNS(Graph.ns, 'g');
	    this.groupSecondaryGrids = document.createElementNS(Graph.ns, 'g');

	    this.axisGroup.appendChild(this.groupGrids);

	    this.groupGrids.appendChild(this.groupSecondaryGrids);
	    this.groupGrids.appendChild(this.groupPrimaryGrids);

	    this.plotGroup = document.createElementNS(Graph.ns, 'g');
	    this.graphingZone.appendChild(this.plotGroup);

	    // 5 September 2014. I encountered a case here shapeZone must be above plotGroup
	    /*this.shapeZone = document.createElementNS( this.ns, 'g' );
	    this.graphingZone.appendChild( this.shapeZone );
	    */

	    this.layers = [];

	    this._makeClosingLines();

	    this.clip = document.createElementNS(Graph.ns, 'clipPath');
	    this.clip.setAttribute('id', '_clipplot' + this._creation);
	    this.defs.appendChild(this.clip);

	    this.clipRect = document.createElementNS(Graph.ns, 'rect');
	    this.clip.appendChild(this.clipRect);
	    this.clip.setAttribute('clipPathUnits', 'userSpaceOnUse');

	    this.markerArrow = document.createElementNS(this.ns, 'marker');
	    this.markerArrow.setAttribute('viewBox', '0 0 10 10');
	    this.markerArrow.setAttribute('id', 'arrow' + this._creation);
	    this.markerArrow.setAttribute('refX', '6');
	    this.markerArrow.setAttribute('refY', '5');
	    this.markerArrow.setAttribute('markerUnits', 'strokeWidth');
	    this.markerArrow.setAttribute('markerWidth', '8');
	    this.markerArrow.setAttribute('markerHeight', '6');
	    this.markerArrow.setAttribute('orient', 'auto');
	    //this.markerArrow.setAttribute('fill', 'context-stroke');
	    //this.markerArrow.setAttribute('stroke', 'context-stroke');

	    var pathArrow = document.createElementNS(Graph.ns, 'path');
	    pathArrow.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
	    //pathArrow.setAttribute( 'fill', 'context-stroke' );
	    this.markerArrow.appendChild(pathArrow);

	    this.defs.appendChild(this.markerArrow);

	    // Horionzal split marker for axis
	    this.markerHorizontalSplit = document.createElementNS(Graph.ns, 'marker');
	    this.markerHorizontalSplit.setAttribute('viewBox', '0 0 6 8');
	    this.markerHorizontalSplit.setAttribute('id', 'horionzalsplit_' + this.getId());
	    this.markerHorizontalSplit.setAttribute('refX', '3');
	    this.markerHorizontalSplit.setAttribute('refY', '4');
	    this.markerHorizontalSplit.setAttribute('markerUnits', 'strokeWidth');
	    this.markerHorizontalSplit.setAttribute('markerWidth', '6');
	    this.markerHorizontalSplit.setAttribute('markerHeight', '8');

	    var path = document.createElementNS(Graph.ns, 'line');
	    path.setAttribute('x1', '0');
	    path.setAttribute('y1', '8');

	    path.setAttribute('x2', '6');
	    path.setAttribute('y2', '0');

	    path.setAttribute('stroke', 'black');
	    this.markerHorizontalSplit.appendChild(path);

	    this.defs.appendChild(this.markerHorizontalSplit);

	    // Vertical split marker for axis
	    this.markerVerticalSplit = document.createElementNS(Graph.ns, 'marker');
	    this.markerVerticalSplit.setAttribute('viewBox', '0 0 8 6');
	    this.markerVerticalSplit.setAttribute('id', 'verticalsplit_' + this.getId());
	    this.markerVerticalSplit.setAttribute('refX', '4');
	    this.markerVerticalSplit.setAttribute('refY', '3');
	    this.markerVerticalSplit.setAttribute('markerUnits', 'strokeWidth');
	    this.markerVerticalSplit.setAttribute('markerWidth', '8');
	    this.markerVerticalSplit.setAttribute('markerHeight', '6');

	    var path = document.createElementNS(Graph.ns, 'line');

	    path.setAttribute('x1', '0');
	    path.setAttribute('y1', '0');

	    path.setAttribute('x2', '8');
	    path.setAttribute('y2', '6');

	    path.setAttribute('stroke', 'black');
	    this.markerVerticalSplit.appendChild(path);
	    this.defs.appendChild(this.markerVerticalSplit);

	    this.vertLineArrow = document.createElementNS(Graph.ns, 'marker');
	    this.vertLineArrow.setAttribute('viewBox', '0 0 10 10');
	    this.vertLineArrow.setAttribute('id', 'verticalline' + this._creation);
	    this.vertLineArrow.setAttribute('refX', '0');
	    this.vertLineArrow.setAttribute('refY', '5');
	    this.vertLineArrow.setAttribute('markerUnits', 'strokeWidth');
	    this.vertLineArrow.setAttribute('markerWidth', '20');
	    this.vertLineArrow.setAttribute('markerHeight', '10');
	    this.vertLineArrow.setAttribute('orient', 'auto');
	    //this.vertLineArrow.setAttribute('fill', 'context-stroke');
	    //this.vertLineArrow.setAttribute('stroke', 'context-stroke');
	    this.vertLineArrow.setAttribute('stroke-width', '1px');

	    var pathVertLine = document.createElementNS(Graph.ns, 'path');
	    pathVertLine.setAttribute('d', 'M 0 -10 L 0 10');
	    pathVertLine.setAttribute('stroke', 'black');

	    this.vertLineArrow.appendChild(pathVertLine);

	    this.defs.appendChild(this.vertLineArrow);

	    // Removed with z stacking ?
	    //    this.plotGroup.setAttribute( 'clip-path', 'url(#_clipplot' + this._creation + ')' );

	    this.bypassHandleMouse = false;
	  }

	  function _registerEvents(graph) {

	    if (!graph.wrapper) {
	      throw 'No wrapper exists. Cannot register the events.';
	    }

	    graph.dom.setAttribute('tabindex', 0);

	    graph.dom.addEventListener('keydown', function (e) {
	      _handleKey(graph, e, 'keydown');
	    });

	    graph.dom.addEventListener('keypress', function (e) {
	      _handleKey(graph, e, 'keypress');
	    });

	    graph.dom.addEventListener('keyup', function (e) {
	      _handleKey(graph, e, 'keyup');
	    });
	    // Not sure this has to be prevented

	    // August 17th, 2017: I extended the graph.groupEvent to the more general graph.dom to make the zoom plugin more
	    // intuitive. Let us see if it breaks another example...
	    graph.dom.addEventListener('mousemove', function (e) {
	      //e.preventDefault();
	      var coords = graph._getXY(e);
	      _handleMouseMove(graph, coords.x, coords.y, e);
	    });

	    graph.dom.addEventListener('mouseleave', function (e) {

	      _handleMouseLeave(graph);
	    });

	    graph.groupEvent.addEventListener('mousedown', function (e) {

	      graph.focus();

	      //   e.preventDefault();
	      if (e.which == 3 || e.ctrlKey) {
	        return;
	      }

	      var coords = graph._getXY(e);
	      _handleMouseDown(graph, coords.x, coords.y, e);
	    });

	    graph.dom.addEventListener('mouseup', function (e) {

	      graph.emit('mouseUp', e);
	      var coords = graph._getXY(e);

	      _handleMouseUp(graph, coords.x, coords.y, e);
	    });

	    graph.wrapper.addEventListener('mouseup', function (e) {
	      e.stopPropagation();
	    });

	    graph.dom.addEventListener('dblclick', function (e) {

	      graph.emit('dblClick', e);
	      var coords = graph._getXY(e);

	      _handleDblClick(graph, coords.x, coords.y, e);
	    });

	    graph.groupEvent.addEventListener('click', function (e) {

	      // Cancel right click or Command+Click
	      if (e.which == 3 || e.ctrlKey) {
	        return;
	      }

	      //   e.preventDefault();
	      var coords = graph._getXY(e);

	      if (!graph.prevent(false)) {
	        _handleClick(graph, coords.x, coords.y, e);
	      }

	      //}, 200 );
	    });

	    graph.groupEvent.addEventListener('mousewheel', function (e) {

	      var deltaY = e.wheelDeltaY || e.wheelDelta || -e.deltaY;
	      var coords = graph._getXY(e);
	      _handleMouseWheel(graph, deltaY, coords.x, coords.y, e);

	      return false;
	    });

	    graph.groupEvent.addEventListener('wheel', function (e) {

	      var coords = graph._getXY(e);
	      var deltaY = e.wheelDeltaY || e.wheelDelta || -e.deltaY;
	      _handleMouseWheel(graph, deltaY, coords.x, coords.y, e);

	      return false;
	    });
	  }

	  function _handleMouseDown(graph, x, y, e) {

	    if (graph.forcedPlugin) {

	      graph.activePlugin = graph.forcedPlugin;
	      graph._pluginExecute(graph.activePlugin, 'onMouseDown', [graph, x, y, e]);
	      return;
	    }

	    if (graph.activePlugin) {
	      graph.activePlugin = false;
	    }

	    checkMouseActions(graph, e, [graph, x, y, e], 'onMouseDown');
	  }

	  function _handleMouseMove(graph, x, y, e) {

	    if (graph.bypassHandleMouse) {
	      graph.bypassHandleMouse.handleMouseMove(e);
	      return;
	    }

	    if (graph.activePlugin && graph._pluginExecute(graph.activePlugin, 'onMouseMove', [graph, x, y, e])) {
	      return;
	    }

	    //			return;

	    graph._applyToAxes('handleMouseMove', [x - graph.options.paddingLeft, e], true, false);
	    graph._applyToAxes('handleMouseMove', [y - graph.options.paddingTop, e], false, true);

	    if (!graph.activePlugin) {
	      var index;

	      // Takes care of the tracking line
	      if (graph.options.trackingLine && graph.options.trackingLine.enable && graph.options.trackingLine.snapToSerie) {

	        if (graph.options.trackingLine.mode == 'common') {

	          var snapToSerie = graph.options.trackingLine.snapToSerie;
	          index = snapToSerie.handleMouseMove(false, true);

	          if (this.trackingObject) {

	            if (!index) {

	              graph.trackingObject.hide();
	            } else {

	              graph.trackingObject.show();

	              graph.trackingObject.getPosition(0).x = index.xClosest;
	              graph.trackingObject.getPosition(1).x = index.xClosest;
	              graph.trackingObject.redraw();

	              var x = snapToSerie.getXAxis().getPx(index.xClosest) + graph.options.paddingLeft;
	            }
	          }

	          var series = graph.options.trackingLine.series;

	          // Gets a default value
	          if (!series) {

	            series = graph.getSeries().map(function (serie) {
	              return {
	                serie: serie,
	                withinPx: 20,
	                withinVal: -1
	              };
	            });
	          }

	          graph._trackingLegend = _trackingLegendSerie(graph, series, x, y, graph._trackingLegend, graph.options.trackingLine.textMethod, index.xClosest);
	        }
	      }
	    }
	    // End takes care of the tracking line

	    if (graph.options.onMouseMoveData) {
	      var results = {};

	      for (var i = 0; i < graph.series.length; i++) {

	        results[graph.series[i].getName()] = graph.series[i].handleMouseMove(false, true);
	      }

	      graph.options.onMouseMoveData.call(graph, e, results);
	    }

	    checkMouseActions(graph, e, [graph, x, y, e], 'onMouseMove');
	  }

	  function checkMouseActions(graph, e, parameters, methodName) {

	    var keyComb = graph.options.mouseActions,
	        i,
	        l,
	        executed = false;

	    for (i = 0, l = keyComb.length; i < l; i++) {

	      if (keyComb[i].plugin) {
	        // Is it a plugin ?

	        if (graph.forcedPlugin == keyComb[i].plugin || graph.isActionAllowed(e, keyComb[i])) {

	          if (keyComb[i].options) {
	            parameters.push(keyComb[i].options);
	          }

	          // Lease the mouse action to the current action
	          // 25.10.2017: Except for mousewheel. See #111
	          if (e.type !== 'wheel' && e.type !== 'mousewheel') {
	            graph.activePlugin = keyComb[i].plugin;
	          }

	          graph._pluginExecute(keyComb[i].plugin, methodName, parameters);
	          executed = true;
	          continue;
	        }
	      } else if (keyComb[i].callback && graph.isActionAllowed(e, keyComb[i])) {

	        if (keyComb[i].options) {
	          parameters.push(keyComb[i].options);
	        }

	        keyComb[i].callback.apply(graph, parameters);
	        executed = true;
	        continue;
	      } else if (keyComb[i].series) {

	        var series;
	        if (keyComb[i].series === 'all') {
	          series = graph.series;
	        }

	        if (!Array.isArray(keyComb[i].series)) {
	          series = [series];
	        }

	        if (keyComb[i].options) {
	          parameters.push(keyComb[i].options);
	        }

	        for (var j = 0; j < series.length; i++) {
	          graph._serieExecute(series[i], methodName, parameters);
	        }
	        executed = true;
	        continue;
	      }
	    }

	    return executed;
	  }

	  var _trackingLegendSerie = function _trackingLegendSerie(graph, serie, x, y, legend, textMethod, xValue) {

	    var justCreated = false;

	    if (!Array.isArray(serie)) {
	      serie = [serie];
	    }

	    var output = [];

	    if (!legend && graph.options.trackingLine.legend) {
	      justCreated = true;
	      legend = _makeTrackingLegend(graph);
	    }

	    serie.map(function (serie) {

	      var index = serie.serie.handleMouseMove(xValue, false);

	      if (!index || !textMethod) {

	        if (serie.serie.trackingShape) {
	          serie.serie.trackingShape.hide();
	        }

	        return legend;
	      }

	      // Should we display the dot ?
	      if (serie.withinPx > 0 && Math.abs(x - graph.options.paddingLeft - serie.serie.getXAxis().getPx(index.xClosest)) - serie.withinPx > 1e-14 || serie.withinVal > 0 && Math.abs(serie.serie.getXAxis().getVal(x - graph.options.paddingLeft) - index.xClosest) - serie.withinVal > serie.serie.getXAxis().getVal(x - graph.options.paddingLeft) / 100000) {

	        if (serie.serie.trackingShape) {
	          serie.serie.trackingShape.hide();
	        }
	      } else {

	        output[serie.serie.getName()] = {

	          yValue: index.xClosest,
	          xValue: index.yClosest,
	          serie: serie,
	          index: index

	        };

	        var serieShape = void 0;
	        if (graph.options.trackingLine && graph.options.trackingLine.serieShape) {
	          serieShape = graph.options.trackingLine.serieShape;
	        } else {
	          serieShape = {
	            shape: 'ellipse',
	            properties: {
	              rx: [serie.serie.getLineWidth() * 3 + 'px'],
	              ry: [serie.serie.getLineWidth() * 3 + 'px']
	            }
	          };
	        }

	        if (!serie.serie.trackingShape) {

	          serie.serie.trackingShape = graph.newShape(serieShape.shape, {
	            fillColor: serie.serie.getLineColor(),
	            strokeColor: 'White',
	            strokeWidth: serie.serie.getLineWidth()
	          }, true, serieShape.properties).setSerie(serie.serie).forceParentDom(serie.serie.groupMain).draw();

	          serieShape.onCreated && serieShape.onCreated(serie.serie.trackingShape);

	          serie.serie.trackingShape.on('changed', function () {

	            serieShape.onChanged && serieShape.onChanged(serie.serie.trackingShape);
	          });
	        }

	        serie.serie.trackingShape.show();
	        serie.serie.trackingShape.getPosition(0).x = index.xClosest;

	        if (serieShape.magnet) {

	          var magnetOptions = serieShape.magnet,
	              val = magnetOptions.within,
	              minmaxpos = void 0;

	          if (magnetOptions.withinPx) {
	            val = serie.serie.getXAxis().getRelVal(magnetOptions.withinPx);
	          }

	          if (minmaxpos = serie.serie.findLocalMinMax(index.xClosest, val, magnetOptions.mode)) {

	            serie.serie.trackingShape.getPosition(0).x = minmaxpos;
	          }
	        }

	        serie.serie.trackingShape.redraw();
	      }
	    }); // End map

	    if (!graph.options.trackingLine.legend) {
	      return;
	    }

	    if (Object.keys(output).length == 0 || !textMethod) {
	      legend.style.display = 'none';
	    } else {

	      if (legend.style.display == 'none' || justCreated) {

	        forceTrackingLegendMode(graph, legend, x, y, true);
	      } else {
	        _trackingLegendMove(graph, legend, x, y);
	      }

	      legend.style.display = 'block';
	      var txt = textMethod(output, xValue, x, y);

	      legend.innerHTML = txt;

	      //legend.innerHTML = textMethod( output, xValue, x, y );
	    }

	    return legend;
	  };

	  var forceTrackingLegendMode = function forceTrackingLegendMode(graph, legend, toX, toY, skip) {

	    var start = Date.now(),
	        h = legend.offsetHeight,
	        startX = parseInt(legend.style.marginLeft.replace('px', '') || 0),
	        startY = parseInt(legend.style.marginTop.replace('px', '') || 0);

	    toX = toX > graph.getWidth() / 2 ? toX - toX % 10 - 20 - legend.offsetWidth : toX - toX % 10 + 30;
	    toY = toY - toY % 10 + h / 2;

	    if (skip) {
	      legend.style.marginLeft = toX + 'px';
	      legend.style.marginTop = toY + 'px';
	      return;
	    }

	    function next() {

	      var progress = (Date.now() - start) / 200;
	      if (progress > 1) {
	        progress = 1;
	      }

	      legend.style.marginLeft = (toX - startX) * progress + startX + 'px';
	      legend.style.marginTop = (toY - startY) * progress + startY + 'px';

	      if (progress < 1) {
	        window.requestAnimationFrame(next);
	      }
	    }

	    window.requestAnimationFrame(next);
	  };

	  var _trackingLegendMove = util.debounce(forceTrackingLegendMode, 50);

	  function _makeTrackingLegend(graph) {

	    var group = document.createElement('div');
	    group.setAttribute('class', 'trackingLegend');
	    group.style.position = 'absolute';
	    group.style.borderRadius = '4px';
	    group.style.boxShadow = '1px 1px 3px 0px rgba(100,100,100,0.6)';
	    group.style.border = '2px solid #333333';
	    group.style.backgroundColor = 'rgba(255, 255, 255, 0.5 )';
	    group.style.pointerEvents = 'none';
	    group.style.paddingTop = '5px';
	    group.style.paddingBottom = '5px';
	    group.style.paddingLeft = '10px';
	    group.style.paddingRight = '10px';

	    graph.getWrapper().insertBefore(group, graph.getDom());

	    return group;
	  }

	  function _handleDblClick(graph, x, y, e) {
	    //	var _x = x - graph.options.paddingLeft;
	    //	var _y = y - graph.options.paddingTop;
	    var pref = graph.options.dblclick;
	    checkMouseActions(graph, e, [x, y, e], 'onDblClick');
	    /*
	        if ( !pref || !pref.type ) {
	          return;
	        }
	         switch ( pref.type ) {
	           case 'plugin':
	             var plugin;
	             if ( ( plugin = graph.plugins[ pref.plugin ] ) ) {
	               plugin.onDblClick( graph, x, y, pref.options, e );
	            }
	             break;
	        }*/
	  }

	  function _handleMouseUp(graph, x, y, e) {

	    if (graph.bypassHandleMouse) {
	      graph.bypassHandleMouse.handleMouseUp(e);
	      graph.activePlugin = false;
	      return;
	    }

	    graph._pluginExecute(graph.activePlugin, 'onMouseUp', [graph, x, y, e]);
	    graph.activePlugin = false;
	  }

	  function _handleClick(graph, x, y, e) {

	    graph.emit('click', [graph, x, y, e]);
	    // Not on a shape
	    checkMouseActions(graph, e, [x, y, e], 'onClick');

	    if (!e.target.jsGraphIsShape && !graph.prevent(false) && graph.options.shapesUnselectOnClick) {

	      graph.unselectShapes();
	    }
	  }

	  function _getAxis(graph, num, options, pos) {

	    var options = options || {};
	    var inst;

	    var _availableAxes = {

	      def: {
	        x: graph.getConstructor('graph.axis.x'),
	        y: graph.getConstructor('graph.axis.y')
	      },

	      time: {
	        x: graph.getConstructor('graph.axis.x.time')
	      },

	      bar: {
	        x: graph.getConstructor('graph.axis.x.bar')
	      }
	    };

	    switch (options.type) {

	      case 'time':
	        var axisInstance = _availableAxes.time;
	        break;

	      case 'bar':
	        var axisInstance = _availableAxes.bar;
	        break;

	      case 'broken':
	        var axisInstance = _availableAxes.broken;
	        break;

	      default:
	        var axisInstance = _availableAxes.def;
	        break;
	    }

	    switch (pos) {

	      case 'top':
	      case 'bottom':
	        inst = axisInstance.x;
	        break;

	      case 'left':
	      case 'right':
	        inst = axisInstance.y;
	        break;
	    }

	    num = num || 0;

	    if ((typeof num === 'undefined' ? 'undefined' : _typeof(num)) == 'object') {
	      options = num;
	      num = 0;
	    }

	    if (!graph.axis[pos][num]) {

	      graph.axis[pos][num] = new inst(graph, pos, options);
	      graph.axis[pos][num].init(graph, options);
	    }

	    return graph.axis[pos][num];
	  }

	  function _closeLine(graph, mode, x1, x2, y1, y2) {

	    if (graph.options.close === false) {
	      return;
	    }

	    var l = 0;

	    graph.axis[mode].map(function (g) {

	      if (g.isDisplayed() && !g.floating) {
	        l++;
	      }
	    });

	    if ((graph.options.close === true || graph.options.close[mode]) && l == 0) {

	      graph.closingLines[mode].setAttribute('display', 'block');
	      graph.closingLines[mode].setAttribute('x1', x1);
	      graph.closingLines[mode].setAttribute('x2', x2);
	      graph.closingLines[mode].setAttribute('y1', y1);
	      graph.closingLines[mode].setAttribute('y2', y2);
	    } else {

	      graph.closingLines[mode].setAttribute('display', 'none');
	    }
	  }

	  function _handleMouseWheel(graph, delta, coordX, coordY, e) {
	    if (checkMouseActions(graph, e, [delta, e, coordX, coordY], 'onMouseWheel')) {
	      e.preventDefault();
	      e.stopPropagation();
	    }
	  }

	  function _handleMouseLeave(graph) {
	    if (graph.options.handleMouseLeave) {
	      graph.options.handleMouseLeave.call(graph);
	    }
	  }

	  function haveAxesChanged(graph) {
	    var temp = graph._axesHaveChanged;
	    graph._axesHaveChanged = false;
	    return temp;
	  }

	  function hasSizeChanged(graph) {
	    var temp = graph._sizeChanged;
	    graph._sizeChanged = false;
	    return temp;
	  }

	  // Constants
	  Graph.SERIE_LINE = Symbol();
	  Graph.SERIE_SCATTER = Symbol();
	  Graph.SERIE_CONTOUR = Symbol();
	  Graph.SERIE_BAR = Symbol();
	  Graph.SERIE_BOX = Symbol();
	  Graph.SERIE_ZONE = Symbol();
	  Graph.SERIE_LINE_COLORED = Symbol();
	  Graph.SERIE_ZONE = Symbol();
	  Graph.SERIE_DENSITYMAP = Symbol();
	  Graph.SERIE_LINE_3D = Symbol();
	  Graph.SERIE_ZONE_3D = Symbol();

	  Graph.TICKS_OUTSIDE = Symbol();
	  Graph.TICKS_INSIDE = Symbol();
	  Graph.TICKS_CENTERED = Symbol();

	  Graph.ns = 'http://www.w3.org/2000/svg';
	  Graph.nsxlink = 'http://www.w3.org/1999/xlink';

	  exports.default = Graph;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 46 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(138), __webpack_require__(348)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _fit_lm, _extend) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _fit_lm2 = _interopRequireDefault(_fit_lm);

	  var _extend2 = _interopRequireDefault(_extend);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  var Waveform = function () {
	    function Waveform() {
	      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var xScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

	      _classCallCheck(this, Waveform);

	      this.xOffset = xOffset;
	      this.xScale = xScale;

	      // Error bar handling
	      this.errors = {

	        nb: 0,

	        bars: {
	          above: null,
	          below: null
	        },

	        boxes: {
	          above: null,
	          below: null
	        }
	      };

	      this.BELOW = Waveform.BELOW;
	      this.ABOVE = Waveform.ABOVE;
	      this.BOX = Waveform.BOX;
	      this.BAR = Waveform.BAR;

	      this.setData(data);
	    }

	    /** [ [ x1, y1 ], [ x2, y2 ] ] */

	    /*
	    setDataXY( data ) {
	       let newData = [ this._makeArray( data.length ), this._makeArray( data.length ) ],
	        warnNaN = false;
	      const nanable = this.isNaNAllowed();
	       data.map( ( el, index ) => {
	         if ( !nanable && ( el[ 0 ] !== el[ 0 ] || el[ 1 ] !== el[ 1 ] ) ) {
	          warnNaN = true;
	        }
	         newData[ 0 ][ index ] = el[ 0 ];
	        newData[ 1 ][ index ] = el[ 1 ];
	      } );
	       if ( warnNaN ) {
	        this.warn( "Trying to assign NaN values to a typed array that does not support NaNs. 0's will be used instead" );
	      }
	       this._setData( ...newData );
	      return this;
	    }
	    */


	    _createClass(Waveform, [{
	      key: 'setData',
	      value: function setData(data) {
	        var dataX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;


	        /* First, we must treat the case of the array of array for backward compatibility */
	        if (Array.isArray(data[0])) {
	          var x = [];
	          var y = [];
	          data.forEach(function (el) {
	            x.push(el[0]);
	            y.push(el[1]);
	          });

	          this.setXWaveform(x);
	          data = y;
	        }

	        var newData = this._makeArray(data.length),
	            warnNaN = false;

	        var nanable = this.isNaNAllowed();

	        data.map(function (el, index) {

	          if (!nanable && (el[0] !== el[0] || el[1] !== el[1])) {
	            warnNaN = true;
	          }

	          newData[index] = el;
	        });

	        if (warnNaN) {
	          this.warn("Trying to assign NaN values to a typed array that does not support NaNs. 0's will be used instead");
	        }

	        this._setData(newData);

	        if (dataX) {
	          this.setXWaveform(dataX);
	        }
	        return this;
	      }
	    }, {
	      key: 'getY',
	      value: function getY(index, optimized) {

	        if (optimized && this.dataInUse) {
	          return this.dataInUse.y[index] * this.getScale() + this.getShift();
	        }

	        return this.data[index] * this.getScale() + this.getShift();
	      }
	    }, {
	      key: 'setXWaveform',
	      value: function setXWaveform(waveform) {

	        if (!(waveform instanceof Waveform)) {

	          if (Array.isArray(waveform)) {
	            waveform = new Waveform(waveform);
	          } else {
	            throw "Cannot set X waveform. Data is not a valid array.";
	          }
	        }

	        this.xdata = waveform;
	        this.computeXMinMax();
	        return this;
	      }
	    }, {
	      key: 'hasXWaveform',
	      value: function hasXWaveform() {
	        return !!this.xdata;
	      }
	    }, {
	      key: 'getXWaveform',
	      value: function getXWaveform() {
	        if (this.xdata) {
	          return this.xdata;
	        }

	        var wave = new Waveform();
	        for (var i = 0; i < this.getLength(); i += 1) {
	          wave.append(this.getX(i));
	        }
	        return wave;
	      }
	    }, {
	      key: 'rescaleX',
	      value: function rescaleX(offset, scale) {
	        this.xScale = scale;
	        this.xOffset = offset;
	        this.computeXMinMax();
	        return this;
	      }
	    }, {
	      key: 'getTypedArrayClass',
	      value: function getTypedArrayClass() {
	        return this._typedArrayClass || false;
	      }
	    }, {
	      key: 'setTypedArrayClass',
	      value: function setTypedArrayClass(constructor) {

	        if (this.getTypedArrayClass() && this.isNaNAllowed() && !this.isNaNAllowed(constructor)) {
	          this.warn("NaN values are not allowed by the new constructor (" + constructor.name + ") while it was allowed by the previous one (" + this._typedArrayClass.name + ")");
	        }

	        if (this.getTypedArrayClass() && this.isUnsigned() && !this.isUnsigned(constructor)) {
	          this.warn("You are switching from signed values to unsigned values. You may experience data corruption if there were some negative values.");
	        }

	        this._typedArrayClass = constructor;

	        if (this.data) {
	          this._setData(constructor.from(this.data));
	        }

	        if (this.hasXWaveform()) {
	          this.getXWaveform().setTypedArrayClass(constructor);
	        }
	      }
	    }, {
	      key: 'isNaNAllowed',
	      value: function isNaNAllowed() {
	        var constructor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._typedArrayClass;


	        // The following types accept NaNs
	        return constructor == Array || constructor == Float32Array || constructor == Float64Array;
	      }
	    }, {
	      key: 'isUnsigned',
	      value: function isUnsigned() {
	        var constructor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._typedArrayClass;


	        // The following types accept NaNs
	        return constructor == Uint8Array || constructor == Uint8ClampedArray || constructor == Uint16Array || constructor == Uint32Array;
	      }
	    }, {
	      key: 'recalculateMinMaxNewPoint',
	      value: function recalculateMinMaxNewPoint(x, y) {
	        if (x < this.minX || this.minX === undefined) {
	          this.minX = x;
	        }

	        if (x > this.maxX || this.maxX === undefined) {
	          this.maxX = x;
	        }

	        if (y < this.minY || this.minY === undefined) {
	          this.minY = y;
	        }

	        if (y > this.maxY || this.maxY === undefined) {
	          this.maxY = y;
	        }
	      }
	    }, {
	      key: 'prepend',
	      value: function prepend(x, y) {

	        if (typeof x == "function") {
	          x = x(this);
	        }

	        if (typeof y == "function") {
	          y = y(this);
	        }

	        if (this.xdata) {
	          this.xdata.prepend(null, x);
	        } else if (x !== null) {
	          this.xdata = this.getXWaveform();
	          this.xdata.prepend(null, x);
	        } else {
	          this.xOffset -= this.xScale;
	        }

	        this.data.unshift(y);
	        this.recalculateMinMaxNewPoint(x, y);
	        return this;
	      }
	    }, {
	      key: 'append',
	      value: function append(x, y) {

	        if (typeof x == "function") {
	          x = x(this);
	        }

	        if (typeof y == "function") {
	          y = y(this);
	        }

	        if (this.xdata) {
	          this.xdata.append(null, x);
	        } else if (x !== null) {
	          this.xdata = this.getXWaveform();
	          this.xdata.append(null, x);
	        }

	        if (this.monotoneous) {
	          if (y > this.data[this.data.y] && this.getMonotoneousAscending() === false) {
	            this.monotoneous = false;
	          } else if (y < this.data[this.data.y] && this.getMonotoneousAscending() === true) {
	            this.monotoneous = false;
	          }
	        }

	        if (this.data.length == 1 || this._monotoneousAscending === undefined) {

	          this.monotoneous = true;

	          if (y == this.data[0]) {
	            this._monotoneousAscending = undefined;
	          } else {
	            this._monotoneousAscending = y > this.data[0];
	          }
	        }

	        this.data.push(y);
	        this.recalculateMinMaxNewPoint(x, y);

	        return this;
	      }
	    }, {
	      key: '_makeArray',
	      value: function _makeArray(length) {

	        var constructor = this.getTypedArrayClass();
	        if (constructor) {
	          return new constructor(length);
	        }
	        return new Array(length);
	      }
	    }, {
	      key: '_setData',
	      value: function _setData(dataY) {
	        var l = dataY.length;
	        var i = 1,
	            monoDir = dataY[1] > dataY[0],
	            minY = dataY[0],
	            maxY = dataY[0];

	        this._monotoneous = true;

	        for (; i < l; i++) {
	          if (dataY[i] !== dataY[i - 1] && monoDir !== dataY[i] > dataY[i - 1]) {
	            this._monotoneous = false;
	          }

	          if (dataY[i] === dataY[i]) {
	            // NaN support
	            minY = Math.min(dataY[i], minY);
	            maxY = Math.max(dataY[i], maxY);
	          }
	        }

	        if (this._monotoneous) {
	          this._monotoneousAscending = dataY[1] > dataY[0];
	        }

	        if (this.hasErrorBars()) {
	          // If prefer to loop again here

	          for (i = 0; i < l; i++) {

	            if (dataY[i] === dataY[i]) {
	              // NaN support

	              minY = Math.min(minY, dataY[i] - this.getMaxError(i, 'below'));
	              maxY = Math.max(maxY, dataY[i] + this.getMaxError(i, 'above'));
	            }
	          }

	          this.minY = minY;
	          this.maxY = maxY;
	        } else {
	          this.minY = minY;
	          this.maxY = maxY;
	        }

	        this.data = dataY;

	        this.computeXMinMax();
	      }
	    }, {
	      key: 'computeXMinMax',
	      value: function computeXMinMax() {

	        if (!this.data) {

	          return;
	        }

	        if (this.xdata) {

	          this.minX = this.xdata.getMin();
	          this.maxX = this.xdata.getMax();
	        } else {

	          var b1 = this.xOffset + this.xScale * this.getLength(),
	              b2 = this.xOffset;

	          this.minX = Math.min(b1, b2);
	          this.maxX = Math.max(b1, b2);
	        }
	      }
	    }, {
	      key: 'getDataInUse',
	      value: function getDataInUse() {
	        return this.dataInUse || this.data;
	      }
	    }, {
	      key: 'getIndexFromVal',
	      value: function getIndexFromVal(val) {
	        var useDataToUse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	        var roundingMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.round;


	        var data = void 0;

	        if (useDataToUse && this.dataInUse) {
	          data = this.dataInUse.y;
	        } else {
	          data = this.data;
	        }

	        var position = void 0;

	        position = this.getIndexFromData(val, data, this.data.getMonotoneousAscending(), roundingMethod);

	        if (useDataToUse && this.dataInUse && this.dataInUseType == "aggregateY") {
	          // In case of aggregation, round to the closest element of 4.
	          return position - position % 4;
	        }

	        return position;
	      }
	    }, {
	      key: 'getIndexFromX',
	      value: function getIndexFromX(xval) {
	        var useDataToUse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	        var roundingMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.round;


	        var xdata = void 0;

	        if (useDataToUse && this.dataInUse) {
	          xdata = this.dataInUse.x;
	        } else if (this.xdata) {
	          xdata = this.xdata.getData();
	        }

	        var position = void 0;

	        if (this.hasXWaveform()) {
	          position = this.xdata.getIndexFromData(xval, xdata, this.xdata.getMonotoneousAscending(), roundingMethod);
	        } else {
	          position = Math.max(0, Math.min(this.getLength() - 1, roundingMethod((xval - this.xOffset) / this.xScale)));
	        }

	        if (useDataToUse && this.dataInUse && this.dataInUseType == "aggregateX") {
	          // In case of aggregation, round to the closest element of 4.
	          return position - position % 4;
	        }

	        return position;
	      }
	    }, {
	      key: 'getIndexFromData',
	      value: function getIndexFromData(val, valCollection, isAscending, roundingMethod) {

	        if (!this.isMonotoneous()) {
	          console.trace();
	          throw "Impossible to get the index from a non-monotoneous wave !";
	        }

	        val -= this.getShift();
	        val /= this.getScale();

	        return binarySearch(val, valCollection, !isAscending);
	      }
	    }, {
	      key: 'getReductionType',
	      value: function getReductionType() {
	        return this.dataInUseType;
	      }
	    }, {
	      key: 'getXMin',
	      value: function getXMin() {
	        return this.minX * this.getXScale() + this.getXShift();
	      }
	    }, {
	      key: 'getXMax',
	      value: function getXMax() {
	        return this.maxX * this.getXScale() + this.getXShift();
	      }
	    }, {
	      key: 'getYMin',
	      value: function getYMin() {
	        return this.minY * this.getScale() + this.getShift();
	      }
	    }, {
	      key: 'getYMax',
	      value: function getYMax() {
	        return this.maxY * this.getScale() + this.getShift();
	      }
	    }, {
	      key: 'getMin',
	      value: function getMin() {
	        return this.minY * this.getScale() + this.getShift();
	      }
	    }, {
	      key: 'getMax',
	      value: function getMax() {
	        return this.maxY * this.getScale() + this.getShift();
	      }
	    }, {
	      key: 'getMinX',
	      value: function getMinX() {

	        return this.minX * this.getXScale() + this.getXShift();
	      }
	    }, {
	      key: 'getMaxX',
	      value: function getMaxX() {
	        return this.maxX * this.getXScale() + this.getXShift();
	      }
	    }, {
	      key: 'getMinY',
	      value: function getMinY() {
	        return this.minY * this.getScale() + this.getShift();
	      }
	    }, {
	      key: 'getMaxY',
	      value: function getMaxY() {
	        return this.maxY * this.getScale() + this.getShift();
	      }
	    }, {
	      key: 'getDataY',
	      value: function getDataY() {
	        return this.data;
	      }
	    }, {
	      key: 'getData',
	      value: function getData(optimized) {
	        if (!optimized || !this.dataInUse) {
	          return this.data;
	        }
	        return this.dataInUse.y;
	      }
	    }, {
	      key: 'setShift',
	      value: function setShift() {
	        var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;


	        // We must update the min and the max of the y data
	        //this.minY += ( shift - this.getShift() );
	        //this.maxY += ( shift - this.getShift() );
	        this.shift = shift;
	        return this;
	      }
	    }, {
	      key: 'getShift',
	      value: function getShift() {
	        return this.shift || 0;
	      }
	    }, {
	      key: 'getScale',
	      value: function getScale() {
	        return this.scale || 1;
	      }
	    }, {
	      key: 'setScale',
	      value: function setScale() {
	        var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;


	        // this.minY = ( this.minY - this.getShift() ) * scale;
	        // this.maxY = ( this.maxY - this.getShift() ) * scale;
	        this.scale = scale;
	        return this;
	      }
	    }, {
	      key: 'setXShift',
	      value: function setXShift() {
	        var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;


	        if (!this.hasXWaveform) {
	          return this;
	        }

	        // We must update the min and the max of the x data
	        // That's important for when the data has already been set
	        //  this.minX += ( shift - this.getXShift() );
	        //    this.maxX += ( shift - this.getXShift() );
	        this.getXWaveform().setShift(shift);
	        return this;
	      }
	    }, {
	      key: 'getXShift',
	      value: function getXShift() {


	        if (!this.hasXWaveform) {
	          return 0;
	        }

	        return this.getXWaveform().getShift();
	      }
	    }, {
	      key: 'setXScale',
	      value: function setXScale() {
	        var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;


	        if (!this.hasXWaveform) {
	          return this;
	        }

	        this.getXWaveform().setScale(scale);
	        return this;
	      }
	    }, {
	      key: 'getXScale',
	      value: function getXScale() {

	        if (!this.hasXWaveform) {
	          return 1;
	        }

	        return this.getXWaveform().getScale();
	      }
	    }, {
	      key: 'getLength',
	      value: function getLength() {
	        return this.data.length;
	      }
	    }, {
	      key: 'getDataToUseFlat',
	      value: function getDataToUseFlat() {

	        var l = void 0;
	        var j = 0;
	        var arr = void 0;

	        if (this.dataInUse) {

	          l = this.dataInUse.x.length;
	          arr = new Array(l * 2).fill(0);

	          for (var i = 0; i < l; i += 1) {
	            arr[j] = this.dataInUse.x[i];
	            arr[j + 1] = this.dataInUse.y[i];
	            j += 2;
	          }
	        } else {

	          l = this.getLength();
	          arr = new Array(l * 2).fill(0);
	          for (var i = 0; i < l; i += 1) {
	            arr[j + 1] = this.data[i];
	            arr[j] = this.getX(i);
	            j += 2;
	          }
	        }

	        return arr;
	      }
	    }, {
	      key: 'fit',
	      value: function fit(options) {

	        var self = this;

	        return new Promise(function (resolver, rejector) {

	          var fit = new _fit_lm2.default((0, _extend2.default)({}, {

	            dataY: self,
	            dataX: self.getXWaveform(),
	            done: function done(results) {
	              resolver(results);
	            },
	            waveform: new Waveform()

	          }, options));

	          fit.init();
	          fit.fit();
	        });
	      }
	    }, {
	      key: 'getX',
	      value: function getX(index, optimized) {

	        if (optimized && this.dataInUse) {
	          return this.dataInUse.x[index] * this.getXScale() + this.getXShift();
	        }

	        if (this.xdata) {
	          return this.xdata.data[index] * this.getXScale() + this.getXShift();
	        } else {
	          return this.xOffset + index * this.xScale;
	        }
	      }
	    }, {
	      key: 'getXRaw',
	      value: function getXRaw(index, optimized) {

	        if (optimized && this.dataInUse) {
	          return this.dataInUse.x[index];
	        }

	        if (this.xdata) {
	          return this.xdata.data[index];
	        } else {
	          return index;
	        }
	      }
	    }, {
	      key: '_integrateP',
	      value: function _integrateP() {
	        var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	        var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - 1;


	        from = Math.round(from);
	        to = Math.round(to);

	        if (from > to) {
	          var temp = from;
	          from = to;
	          to = temp;
	        }

	        var l = to - from + 1;
	        var sum = 0;

	        var deltaTot = 0;
	        var diff = void 0;
	        var arrY = this.getData();

	        for (; from <= to; from++) {

	          if (arrY.length - 1 > from) {
	            diff = this.getX(from + 1) - this.getX(from);
	            deltaTot += diff;
	            sum += arrY[from] * diff;
	          }
	        }

	        return [sum, l, deltaTot];
	      }
	    }, {
	      key: 'integrateP',
	      value: function integrateP(from, to) {
	        var val = this._integrateP(from, to);
	        return val[0];
	      }
	    }, {
	      key: 'integrate',
	      value: function integrate(fromX, toX) {
	        return this.integrateP(this.getIndexFromX(fromX), this.getIndexFromX(toX));
	      }
	    }, {
	      key: 'average',
	      value: function average() {
	        var p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	        var p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - 1;

	        return this.getAverageP(p0, p1);
	      }
	    }, {
	      key: 'mean',
	      value: function mean() {
	        return this.average();
	      }
	    }, {
	      key: 'getAverageP',
	      value: function getAverageP(from, to) {
	        var sum = this._integrateP(from, to);
	        return sum[0] / sum[2];
	      }
	    }, {
	      key: 'getAverageX',
	      value: function getAverageX(from, to) {
	        var sum = this._integrateX(from, to);
	        return sum[0] / sum[2];
	      }
	    }, {
	      key: 'checkMonotonicity',
	      value: function checkMonotonicity() {

	        var i = 1,
	            data = this.getData();
	        var l = this.data.length;
	        var dir = data[1] > data[0];

	        for (; i < l; i++) {
	          if (data[i] !== data[i - 1] && dir !== data[i] > data[i - 1]) {
	            return this._monotoneous = false;
	          }
	        }

	        this._monotoneousAscending = data[1] > data[0];
	        return this._monotoneous = true;
	      }
	    }, {
	      key: 'requireXMonotonicity',
	      value: function requireXMonotonicity() {
	        if (this.xdata) {
	          this.xdata.requireMonotonicity();
	        }
	      }
	    }, {
	      key: 'requireMonotonicity',
	      value: function requireMonotonicity() {
	        if (!this.isMonotoneous()) {
	          throw "The wave must be monotonic";
	        }
	      }
	    }, {
	      key: 'isMonotoneous',
	      value: function isMonotoneous() {
	        return !!this._monotoneous;
	      }
	    }, {
	      key: 'isXMonotoneous',
	      value: function isXMonotoneous() {
	        if (this.xdata) {
	          return this.xdata.isMonotoneous();
	        }
	        // Offset and scale is always monotoneous
	        return true;
	      }
	    }, {
	      key: 'invert',
	      value: function invert(data) {

	        var d = dataY || this.data;
	        d.reverse();

	        if (this.isMonotoneous()) {
	          this._monotoneousAscending = !this._monotoneousAscending;
	        }

	        return d;
	      }
	    }, {
	      key: 'resampleForDisplay',
	      value: function resampleForDisplay(options) {
	        // Serie redrawing

	        var i = 0;

	        this.requireXMonotonicity();

	        var inverting = false,
	            dataY = this.getDataY(),
	            data = {
	          x: [],
	          y: []
	        },
	            dataMinMax = [],
	            resampleSum = void 0,
	            resampleMin = void 0,
	            resampleMax = void 0,
	            resampleNum = void 0,
	            resample_x_start = void 0,
	            resample_x_px_start = void 0,
	            x_px = void 0,
	            doing_mean = false,
	            firstPointIndex = 0,
	            xval = void 0;

	        var l = this.getLength();

	        if (!options.xPosition) {
	          throw "No position calculation method provided";
	        }

	        if (!options.resampleToPx) {
	          throw "No \"resampleToPx\" method was provided. Unit: px per point";
	        }

	        if (options.minX > options.maxX) {
	          var temp = options.minX;
	          options.minX = options.maxX;
	          options.maxX = temp;
	        }

	        if (this.xdata && !this.xdata.getMonotoneousAscending() || !this.xdata && this.xScale < -0) {
	          inverting = true;
	          i = l;
	        }

	        for (; inverting ? i > 0 : i < l; inverting ? i-- : i++) {

	          xval = this.getX(i);

	          if (options.minX > xval) {

	            firstPointIndex = i;
	            continue;
	          }

	          x_px = options.xPosition(xval);

	          if (!doing_mean) {

	            if (!firstPointIndex) {

	              firstPointIndex = i;
	            } else {

	              data.x.push(xval);
	              data.y.push(dataY[firstPointIndex]);
	            }

	            while (isNaN(dataY[i])) {

	              if (inverting) {
	                i--;
	              } else {
	                i++;
	              }
	            }

	            resampleSum = resampleMin = resampleMax = dataY[firstPointIndex];
	            resampleNum = 1;
	            resample_x_px_start = x_px;
	            resample_x_start = xval;
	            firstPointIndex = 0;

	            doing_mean = true;

	            continue;
	          }

	          if (Math.abs(x_px - resample_x_px_start) > options.resampleToPx || i == l || i == 0 || isNaN(dataY[i])) {

	            var xpos = (resample_x_start + xval) / 2;

	            data.x.push(xpos);
	            data.y.push(resampleSum / resampleNum);

	            dataMinMax.push(xpos, resampleMin, resampleMax);

	            if (options.maxX !== undefined && xval > options.maxX) {

	              break;
	            }

	            doing_mean = false;

	            continue;
	          }

	          resampleSum += dataY[i];
	          resampleNum++;

	          resampleMin = Math.min(resampleMin, dataY[i]);
	          resampleMax = Math.max(resampleMax, dataY[i]);
	        }

	        this.dataInUseType = "resampled";
	        this.dataInUse = data;
	        return dataMinMax;
	      }
	    }, {
	      key: 'interpolate',
	      value: function interpolate(x) {

	        var yData = this.getDataY();
	        var xIndex = void 0;

	        if (this.xdata) {
	          var xData = this.xdata.getData();
	          xIndex = binarySearch(x, xData, !this.xdata.getMonotoneousAscending());
	          if (xData[xIndex] == x) {
	            return yData[xIndex];
	          }
	          return (x - xData[xIndex]) / (xData[xIndex + 1] - xData[xIndex]) * (yData[xIndex + 1] - yData[xIndex]) + yData[xIndex];
	        } else {
	          xIndex = (x - this.xOffset) / this.xScale;
	          var xIndexF = Math.floor(xIndex);
	          return (xIndex - xIndexF) * (yData[xIndexF + 1] - yData[xIndexF]) + yData[xIndexF];
	        }
	      }
	    }, {
	      key: 'interpolateIndex_X',
	      value: function interpolateIndex_X(index) {

	        var yData = this.getDataY();
	        if (this.xdata) {
	          var xData = this.xdata.getData();
	          var indexStart = Math.floor(index);

	          return (index - indexStart) * (xData[indexStart + 1] - xData[indexStart]) + xData[indexStart];
	        }
	      }
	    }, {
	      key: 'getMonotoneousAscending',
	      value: function getMonotoneousAscending() {

	        if (!this.isMonotoneous()) {
	          return "The waveform is not monotoneous";
	        }

	        return this._monotoneousAscending;
	      }
	    }, {
	      key: 'getXMonotoneousAscending',
	      value: function getXMonotoneousAscending() {
	        if (this.xdata) {
	          return this.xdata.getMonotoneousAscending();
	        }

	        return this.xScale > 0;
	      }
	    }, {
	      key: 'isXMonotoneousAscending',
	      value: function isXMonotoneousAscending() {
	        return this.getXMonotoneousAscending.apply(this, arguments);
	      }
	    }, {
	      key: 'divide',
	      value: function divide(numberOrWave) {
	        return this._arithmetic(numberOrWave, DIVIDE);
	      }
	    }, {
	      key: 'divideBy',
	      value: function divideBy() {
	        return this.divide.apply(this, arguments);
	      }
	    }, {
	      key: 'multiply',
	      value: function multiply(numberOrWave) {
	        return this._arithmetic(numberOrWave, MULTIPLY);
	      }
	    }, {
	      key: 'multiplyBy',
	      value: function multiplyBy() {
	        return this.multiply.apply(this, arguments);
	      }
	    }, {
	      key: 'log',
	      value: function log() {
	        return this.logBase(10);
	      }
	    }, {
	      key: 'ln',
	      value: function ln() {
	        return this.logBase(Math.E);
	      }
	    }, {
	      key: 'logBase',
	      value: function logBase(base) {

	        var logBase = Math.log(base);
	        this.data.map(function (valY) {

	          return Math.log(valY) / logBase;
	        });
	      }
	    }, {
	      key: 'add',
	      value: function add(numberOrWave) {
	        return this._arithmetic(numberOrWave, ADD);
	      }
	    }, {
	      key: 'addBy',
	      value: function addBy() {
	        return this.add.apply(this, arguments);
	      }
	    }, {
	      key: 'subtract',
	      value: function subtract(numberOrWave) {
	        return this._arithmetic(numberOrWave, SUBTRACT);
	      }
	    }, {
	      key: 'subtractBy',
	      value: function subtractBy() {
	        return this.subtract.apply(this, arguments);
	      }
	    }, {
	      key: 'math',
	      value: function math(method) {

	        for (var i = 0; i < this.getLength(); i++) {
	          this.data[i] = method(this.getY(i), this.getX(i));
	        }

	        this._setData(this.data);
	        return this;
	      }
	    }, {
	      key: '_arithmetic',
	      value: function _arithmetic(numberOrWave, operator) {

	        if (numberOrWave instanceof Waveform) {
	          return this._waveArithmetic(numberOrWave, operator);
	        } else if (typeof numberOrWave == 'number') {

	          return this._numberArithmetic(numberOrWave, operator);
	        }
	      }
	    }, {
	      key: '_numberArithmetic',
	      value: function _numberArithmetic(num, operation) {

	        var i = 0,
	            l = this.getLength();

	        if (operation == MULTIPLY) {

	          for (; i < l; i++) {
	            this.data[i] *= num;
	          }

	          this.minY *= num;
	          this.maxY *= num;
	        } else if (operation == DIVIDE) {

	          for (; i < l; i++) {
	            this.data[i] /= num;
	          }

	          this.minY /= num;
	          this.maxY /= num;
	        } else if (operation == ADD) {

	          for (; i < l; i++) {
	            this.data[i] += num;
	          }

	          this.minY += num;
	          this.maxY += num;
	        } else if (operation == SUBTRACT) {

	          for (; i < l; i++) {
	            this.data[i] -= num;
	          }

	          this.minY -= num;
	          this.maxY -= num;
	        }

	        return this;
	      }
	    }, {
	      key: '_waveArithmetic',
	      value: function _waveArithmetic(wave, operation) {

	        var yDataThis = this.getDataY(),
	            i = 0;
	        var l = this.getLength();
	        this.requireXMonotonicity();
	        wave.requireXMonotonicity();

	        if (operation == MULTIPLY) {

	          for (; i < l; i++) {
	            yDataThis[i] *= wave.interpolate(this.getX(i));
	          }
	        } else if (operation == DIVIDE) {

	          for (; i < l; i++) {
	            yDataThis[i] /= wave.interpolate(this.getX(i));
	          }
	        } else if (operation == ADD) {

	          for (; i < l; i++) {
	            yDataThis[i] += wave.interpolate(this.getX(i));
	          }
	        } else if (operation == SUBTRACT) {

	          for (; i < l; i++) {
	            yDataThis[i] -= wave.interpolate(this.getX(i));
	          }
	        }

	        this._setData(yDataThis);
	        return this;
	      }
	    }, {
	      key: 'aggregate',
	      value: function aggregate() {
	        var _this = this;

	        var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'x';


	        this._dataAggregating = {};
	        this._dataAggregated = {};
	        this._dataAggregationDirection = direction.toUpperCase();

	        var pow2 = pow2floor(this.getLength());

	        this._dataAggregating = aggregator({

	          minX: this.minX,
	          maxX: this.maxX,
	          minY: this.minY,
	          maxY: this.maxY,
	          data: this.data,
	          xdata: this.xdata ? this.xdata.getData() : undefined,
	          xScale: this.xScale,
	          xOffset: this.xOffset,
	          numPoints: pow2,
	          direction: direction

	        }).then(function (event) {

	          _this._dataAggregated = event.aggregates;
	          _this._dataAggregating = false;
	        });
	      }
	    }, {
	      key: 'hasAggregation',
	      value: function hasAggregation() {
	        return !!this._dataAggregated;
	      }
	    }, {
	      key: 'selectAggregatedData',
	      value: function selectAggregatedData(pxWidth) {

	        if (pxWidth < 2) {
	          return false;
	        }
	        /*
	        console.log( direction, this._dataAggregationDirection );
	             if( direction !== this._dataAggregationDirection ) {
	              throw "The data is not aggregated in that direction";
	            }
	        */

	        var level = pow2ceil(pxWidth);

	        if (this._dataAggregated[level]) {

	          this.dataInUseType = "aggregate" + this._dataAggregationDirection;
	          this.dataInUse = this._dataAggregated[level];
	          return;
	        } else if (this._dataAggregating) {

	          return this._dataAggregating;
	        }

	        this.dataInUseType = "none";
	        this.dataInUse = {
	          y: this.data,
	          x: this.getXWaveform().data
	        };
	      }
	    }, {
	      key: 'duplicate',
	      value: function duplicate(alsoDuplicateXWave) {
	        var newWaveform = new Waveform();
	        newWaveform._setData(this.getDataY().slice());
	        newWaveform.rescaleX(this.xOffset, this.xShift);
	        newWaveform.setShift(this.getShift());
	        newWaveform.setScale(this.getScale());

	        if (this.xdata) {
	          if (alsoDuplicateXWave) {
	            newWaveform.setXWaveform(this.xdata.duplicate());
	          } else {
	            newWaveform.setXWaveform(this.xdata);
	          }

	          newWaveform.setXShift(this.getXShift());
	          newWaveform.setXScale(this.getXScale());
	        } else {
	          newWaveform.xOffset = this.xOffset;
	          newWaveform.xScale = this.xScale;
	        }

	        return newWaveform;
	      }
	    }, {
	      key: 'subrangeX',
	      value: function subrangeX(fromX, toX) {

	        if (!this.xdata) {
	          // We can select the new range from there

	          var fromP = this.getIndexFromX(fromX),
	              toP = this.getIndexFromX(toP);

	          return new Waveform().setData(this.data.slice(fromP, toP)).rescaleX(this.xOffset, this.xScale);
	        } else {

	          var waveform = new Waveform();

	          for (var i = 0, l = this.data.length; i < l; i++) {

	            if (this.data[i] >= fromX && this.data[i] < toX) {

	              waveform.append(this.dataX[i], this.data[i]);
	            }
	          }

	          return waveform;
	        }
	      }
	    }, {
	      key: 'findLocalMinMax',
	      value: function findLocalMinMax(xRef, xWithin, type) {

	        var index = this.getIndexFromX(xRef),
	            indexPlus = this.getIndexFromX(xRef + xWithin),
	            indexMinus = this.getIndexFromX(xRef - xWithin);

	        return this.findLocalMinMaxIndex(indexMinus, indexPlus, type);
	      }
	    }, {
	      key: 'findLocalMinMaxIndex',
	      value: function findLocalMinMaxIndex(indexMinus, indexPlus, type) {

	        var tmp = void 0;

	        if (indexPlus < indexMinus) {
	          tmp = indexPlus;
	          indexPlus = indexMinus;
	          indexMinus = tmp;
	        }

	        var curr = void 0,
	            currI = void 0;

	        if (type == 'max') {

	          curr = Number.NEGATIVE_INFINITY;

	          for (var i = indexMinus; i <= indexPlus; i++) {

	            if (this.getY(i) > curr) {
	              curr = this.getY(i);
	              currI = i;
	            }
	          }
	        } else {

	          curr = Number.POSITIVE_INFINITY;

	          for (var i = indexMinus; i <= indexPlus; i++) {

	            if (this.getY(i) < curr) {
	              curr = this.getY(i);
	              currI = i;
	            }
	          }
	        }

	        if (currI == indexMinus || currI == indexPlus) {
	          return false;
	        }

	        return this.getX(currI);
	      }
	    }, {
	      key: 'warn',
	      value: function warn(text) {
	        if (console) {
	          console.warn(text);
	        }
	      }
	    }, {
	      key: 'setUnit',
	      value: function setUnit(unit) {
	        this.unit = unit;
	        return this;
	      }
	    }, {
	      key: 'setXUnit',
	      value: function setXUnit(unit) {
	        if (this.hasXWaveform()) {
	          this.xdata.setUnit(unit);
	        }

	        this.xunit = unit;
	        return this;
	      }
	    }, {
	      key: 'getUnit',
	      value: function getUnit() {
	        return this.unit || "";
	      }
	    }, {
	      key: 'getXUnit',
	      value: function getXUnit() {
	        if (this.hasXWaveform()) {
	          return this.xdata.getUnit();
	        }

	        return this.xunit | "";
	      }
	    }, {
	      key: 'hasXUnit',
	      value: function hasXUnit() {
	        return this.getXUnit().length > 0;
	      }
	    }, {
	      key: 'hasUnit',
	      value: function hasUnit() {
	        return this.getUnit().length > 0;
	      }
	    }, {
	      key: 'findLevels',
	      value: function findLevels(level, options) {

	        options = (0, _extend2.default)({

	          box: 1,
	          edge: 'both',
	          rounding: 'before',
	          rangeP: [0, this.getLength()]

	        }, options);

	        var lastLvlIndex = options.rangeP[0];
	        var lvlIndex;
	        var indices = [];
	        var i = 0;

	        while (lvlIndex = this.findLevel(level, (0, _extend2.default)(true, {}, options, {
	          rangeP: [lastLvlIndex, options.rangeP[1]]
	        }))) {
	          indices.push(lvlIndex);
	          lastLvlIndex = Math.ceil(lvlIndex);

	          i++;
	          if (i > 1000) {
	            return;
	          }
	        }

	        return indices;
	      }
	    }, {
	      key: 'findLevel',
	      value: function findLevel(level, options) {

	        options = (0, _extend2.default)({

	          box: 1,
	          edge: 'both',
	          direction: 'ascending',
	          rounding: 'before',
	          rangeP: [0, this.getLength()]

	        }, options);

	        if (options.rangeX) {
	          options.rangeP = options.rangeX.map(this.getIndexFromX);
	        }

	        var value, below, i, j, l, increment;

	        var box = options.box;

	        if (box % 2 == 0) {
	          box++;
	        }

	        if (options.direction == "descending") {
	          i = options.rangeP[1], l = options.rangeP[0], increment = -1;
	        } else {
	          i = options.rangeP[0], l = options.rangeP[1], increment = +1;
	        }

	        for (;; i += increment) {

	          if (options.direction == "descending") {
	            if (i < l) {
	              break;
	            }
	          } else {
	            if (i > l) {
	              break;
	            }
	          }

	          if (i < options.rangeP[0] + (box - 1) / 2) {
	            continue;
	          }

	          if (i > options.rangeP[1] - (box - 1) / 2) {
	            break;
	          }

	          value = this.getAverageP(i - (box - 1) / 2, i + (box - 1) / 2);

	          if (below === undefined) {
	            below = value < level;
	            continue;
	          }
	          // Crossing up
	          if (value >= level && below) {

	            below = false;

	            if (options.edge == 'ascending' || options.edge == 'both') {
	              // Found something

	              for (j = i + (box - 1) / 2; j >= i - (box - 1) / 2; j--) {

	                if (this.data[j] >= level && this.data[j - 1] <= level) {
	                  // Find a crossing

	                  switch (options.rounding) {
	                    case 'before':
	                      return j - 1;
	                      break;

	                    case 'after':
	                      return j;
	                      break;

	                    case 'interpolate':
	                      return getIndexInterpolate(level, this.data[j], this.data[j - 1], j, j - 1);
	                      break;
	                  }
	                }
	              }
	            }
	          } else if (value <= level && !below) {

	            below = true;

	            if (options.edge == 'descending' || options.edge == 'both') {

	              for (j = i + (box - 1) / 2; j >= i - (box - 1) / 2; j--) {

	                if (this.data[j] <= level && this.data[j - 1] >= level) {
	                  // Find a crossing

	                  switch (options.rounding) {
	                    case 'before':
	                      return j - 1;
	                      break;

	                    case 'after':
	                      return j;
	                      break;

	                    case 'interpolate':
	                      return getIndexInterpolate(level, this.data[j], this.data[j - 1], j, j - 1);
	                      break;
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	    }, {
	      key: 'normalize',
	      value: function normalize(mode) {

	        var factor = void 0,
	            total = void 0,
	            minValue = void 0,
	            maxValue = void 0,
	            ratio = void 0,
	            i = void 0;

	        if (mode == 'max1' || mode == 'max100') {

	          factor = 1;

	          if (mode == 'max100') {
	            factor = 100;
	          }

	          maxValue = this.data[0];

	          for (i = 1; i < this.getLength(); i++) {

	            if (this.data[i] > maxValue) {

	              maxValue = this.data[i];
	            }
	          }

	          for (i = 0; i < this.getLength(); i++) {

	            this.data[i] /= maxValue / factor;
	          }
	        } else if (mode == 'sum1') {

	          total = 0;

	          for (i = 0; i < this.getLength(); i++) {
	            total += this.data[i];
	          }

	          for (i = 0; i < this.getLength(); i++) {

	            this.data[i] /= total;
	          }
	        } else if (mode == 'max1min0') {

	          maxValue = this.data[0], minValue = this.data[0];

	          for (i = 1; i < this.getLength(); i++) {
	            if (this.data[i] > maxValue) {

	              maxValue = this.data[i];
	            } else if (this.data[i] < minValue) {

	              minValue = this.data[i];
	            }
	          }

	          ratio = 1 / (maxValue - minValue);

	          for (i = 0; i < this.getLength(); i++) {

	            this.data[i] = (this.data[i] - minValue) * ratio;
	          }
	        }

	        this.setData(this.data);
	      }
	    }, {
	      key: 'setErrorBarX',
	      value: function setErrorBarX(waveform) {

	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }

	        var xWave = this.getXWaveform();
	        xWave.setErrorBar(waveform);
	        return this;
	      }
	    }, {
	      key: 'setErrorBarXBelow',
	      value: function setErrorBarXBelow(waveform) {

	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }

	        var xWave = this.getXWaveform();
	        xWave.setErrorBarBelow(waveform);
	        return this;
	      }
	    }, {
	      key: 'setErrorBarXAbove',
	      value: function setErrorBarXAbove(waveform) {

	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }

	        var xWave = this.getXWaveform();
	        xWave.setErrorBarAbove(waveform);
	        return this;
	      }
	    }, {
	      key: 'setErrorBoxX',
	      value: function setErrorBoxX(waveform) {

	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }

	        var xWave = this.getXWaveform();
	        xWave.setErrorBoxAbove(waveform);
	        xWave.setErrorBoxBelow(waveform);
	        return this;
	      }
	    }, {
	      key: 'setErrorBoxXBelow',
	      value: function setErrorBoxXBelow(waveform) {

	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }

	        var xWave = this.getXWaveform();

	        xWave.setErrorBoxBelow(waveform);
	        return this;
	      }
	    }, {
	      key: 'setErrorBoxXAbove',
	      value: function setErrorBoxXAbove(waveform) {

	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }

	        var xWave = this.getXWaveform();
	        xWave.setErrorBoxAbove(waveform);
	        return this;
	      }
	    }, {
	      key: 'setErrorBar',
	      value: function setErrorBar(waveform) {
	        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }
	        this.errors.nb++;
	        this.errors.nb++;
	        this.errors.bars.bottom = waveform;
	        this.errors.bars.top = waveform;

	        if (checkMinMax) {
	          this._setData();
	        }
	      }
	    }, {
	      key: 'setErrorBarBelow',
	      value: function setErrorBarBelow(waveform) {
	        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }
	        this.errors.nb++;
	        this.errors.bars.below = waveform;

	        if (checkMinMax) {
	          this._setData();
	        }
	      }
	    }, {
	      key: 'setErrorBarAbove',
	      value: function setErrorBarAbove(waveform) {
	        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }

	        this.errors.nb++;
	        this.errors.bars.above = waveform;

	        if (checkMinMax) {
	          this._setData();
	        }
	      }
	    }, {
	      key: 'setErrorBox',
	      value: function setErrorBox(waveform) {
	        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }
	        this.errors.nb++;
	        this.errors.nb++;
	        this.errors.boxes.above = waveform;
	        this.errors.boxes.below = waveform;

	        if (checkMinMax) {
	          this._setData();
	        }
	      }
	    }, {
	      key: 'setErrorBoxBelow',
	      value: function setErrorBoxBelow(waveform) {
	        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }
	        this.errors.nb++;
	        this.errors.boxes.below = waveform;

	        if (checkMinMax) {
	          this._setData();
	        }
	      }
	    }, {
	      key: 'setErrorBoxAbove',
	      value: function setErrorBoxAbove(waveform) {
	        var checkMinMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


	        if (Array.isArray(waveform)) {
	          waveform = new Waveform(waveform);
	        }

	        this.errors.boxes.above = waveform;
	        if (checkMinMax) {
	          this._setData();
	        }
	      }
	    }, {
	      key: 'getMaxError',
	      value: function getMaxError(i) {
	        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Waveform.ABOVE;


	        return Math.max(this.getMaxErrorType(i, side, Waveform.BOX), this.getMaxErrorType(i, side, Waveform.BAR));
	      }
	    }, {
	      key: 'getMaxErrorType',
	      value: function getMaxErrorType(i) {
	        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Waveform.ABOVE;
	        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Waveform.BOX;


	        var stack = void 0;
	        if (type == Waveform.BOX) {
	          stack = this.errors.boxes;
	        } else if (type == Waveform.BAR) {
	          stack = this.errors.bars;
	        } else {
	          throw 'Unknown type of error';
	        }

	        var waveform = void 0;
	        if (!(waveform = stack[side])) {
	          if (side == Waveform.ABOVE) {
	            if (stack[side] == Waveform.BELOW) {
	              waveform = stack.below;
	            }
	          } else {
	            if (stack[side] == Waveform.ABOVE) {
	              waveform = stack.above;
	            }
	          }
	        }

	        if (!waveform) {
	          return 0;
	        }

	        return waveform.getY(i);
	      }
	    }, {
	      key: 'getErrorBarXBelow',
	      value: function getErrorBarXBelow(index) {
	        return this.getErrorX(index, Waveform.BELOW, Waveform.BAR);
	      }
	    }, {
	      key: 'getErrorBarXAbove',
	      value: function getErrorBarXAbove(index) {
	        return this.getErrorX(index, Waveform.ABOVE, Waveform.BAR);
	      }
	    }, {
	      key: 'getErrorBoxXBelow',
	      value: function getErrorBoxXBelow(index) {
	        return this.getErrorX(index, Waveform.BELOW, Waveform.BOX);
	      }
	    }, {
	      key: 'getErrorBoxXAbove',
	      value: function getErrorBoxXAbove(index) {
	        return this.getErrorX(index, Waveform.ABOVE, Waveform.BOX);
	      }
	    }, {
	      key: 'getErrorBarYBelow',
	      value: function getErrorBarYBelow(index) {
	        return this.getError(index, Waveform.BELOW, Waveform.BAR);
	      }
	    }, {
	      key: 'getErrorBarYAbove',
	      value: function getErrorBarYAbove(index) {
	        return this.getError(index, Waveform.ABOVE, Waveform.BAR);
	      }
	    }, {
	      key: 'getErrorBoxYBelow',
	      value: function getErrorBoxYBelow(index) {
	        return this.getError(index, Waveform.BELOW, Waveform.BOX);
	      }
	    }, {
	      key: 'getErrorBoxYAbove',
	      value: function getErrorBoxYAbove(index) {
	        return this.getError(index, Waveform.ABOVE, Waveform.BOX);
	      }
	    }, {
	      key: 'getErrorX',
	      value: function getErrorX(index) {
	        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Waveform.ABOVE;
	        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Waveform.BAR;


	        if (!this.hasXWaveform()) {
	          return false;
	        }

	        return this.xdata.getError(index, side, type);
	      }
	    }, {
	      key: 'getError',
	      value: function getError(index) {
	        var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Waveform.ABOVE;
	        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Waveform.BAR;


	        var errors = type == Waveform.BAR ? this.errors.bars : this.errors.boxes;

	        if (!errors) {
	          return false;
	        }

	        var wave = void 0;
	        if (wave = side == Waveform.ABOVE ? errors.above : errors.below) {

	          if (wave == Waveform.ABOVE && side == Waveform.BELOW) {
	            wave = errors.above;
	          } else if (wave == Waveform.BELOW && side == Waveform.ABOVE) {
	            wave = errors.below;
	          }

	          if (!wave) {
	            return false;
	          }

	          return wave.getY(index);
	        }
	      }
	    }, {
	      key: 'hasErrorBars',
	      value: function hasErrorBars() {

	        return this.errors.nb > 0 || this.hasXWaveform() && this.xdata.errors.nb > 0;
	      }
	    }]);

	    return Waveform;
	  }();

	  Waveform.BELOW = Symbol();
	  Waveform.ABOVE = Symbol();

	  Waveform.BOX = Symbol();
	  Waveform.BAR = Symbol();

	  var MULTIPLY = Symbol();
	  var ADD = Symbol();
	  var SUBTRACT = Symbol();
	  var DIVIDE = Symbol();

	  // http://stackoverflow.com/questions/26965171/fast-nearest-power-of-2-in-javascript
	  function pow2ceil(v) {
	    v--;
	    var p = 2;
	    while (v >>= 1) {
	      p <<= 1;
	    }
	    return p;
	  }

	  function pow2floor(v) {

	    var p = 1;

	    while (v >>= 1) {
	      p <<= 1;
	    }
	    return p;
	  }

	  function getIndexInterpolate(value, valueBefore, valueAfter, indexBefore, indexAfter) {
	    return (value - valueBefore) / (valueAfter - valueBefore) * (indexAfter - indexBefore) + indexBefore;
	  }

	  function binarySearch(target, haystack) {
	    var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : haystack[haystack.length - 1] < haystack[0];


	    var seedA = 0,
	        length = haystack.length,
	        seedB = length - 1,
	        seedInt = void 0,
	        i = 0,
	        nanDirection = 1;

	    if (!reverse && (haystack[0] > target || haystack[seedB] < target) || reverse && (haystack[0] < target || haystack[seedB] > target)) {
	      throw new Error('Target ' + target + ' is not in the stack');
	    }

	    if (haystack[seedA] == target) {
	      return seedA;
	    }

	    if (haystack[seedB] == target) {
	      return seedB;
	    }

	    while (true) {
	      i++;
	      if (i > 100) {
	        throw new Error("Error loop");
	      }

	      seedInt = Math.floor((seedA + seedB) / 2);

	      //  seedInt -= seedInt % 2; // Always looks for an x.

	      while (isNaN(haystack[seedInt])) {

	        if (seedInt >= haystack.length - 1) {

	          return haystack.length - 1;
	        } else if (seedInt <= 0) {

	          return 0;
	        }

	        seedInt += nanDirection;
	      }

	      if (seedInt == seedA || haystack[seedInt] == target || seedInt == seedB) {
	        return seedInt;
	      }

	      //    console.log(seedA, seedB, seedInt, haystack[seedInt]);
	      if (haystack[seedInt] < target) {
	        if (reverse) {
	          seedB = seedInt;
	        } else {
	          seedA = seedInt;
	        }
	      } else if (haystack[seedInt] > target) {
	        if (reverse) {
	          seedA = seedInt;
	        } else {
	          seedB = seedInt;
	        }
	      } else {
	        return false;
	      }

	      nanDirection *= -1;
	    }
	  }

	  exports.default = Waveform;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 47 */
	/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(8).f;
	var has = __webpack_require__(12);
	var TAG = __webpack_require__(6)('toStringTag');

	module.exports = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};


	/***/ }),
	/* 48 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var defined = __webpack_require__(24);
	var fails = __webpack_require__(3);
	var spaces = __webpack_require__(80);
	var space = '[' + spaces + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');

	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = fails(function () {
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};

	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};

	module.exports = exporter;


	/***/ }),
	/* 49 */
	/***/ (function(module, exports) {

	module.exports = {};


	/***/ }),
	/* 50 */
	/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(4);
	module.exports = function (it, TYPE) {
	  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};


	/***/ }),
	/* 51 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(57), __webpack_require__(5), __webpack_require__(73), __webpack_require__(46)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphCore, _graphSerie, _graphUtil, _graphMixinErrorbars, _waveform) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphCore2 = _interopRequireDefault(_graphCore);

	  var _graphSerie2 = _interopRequireDefault(_graphSerie);

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphMixinErrorbars2 = _interopRequireDefault(_graphMixinErrorbars);

	  var _waveform2 = _interopRequireDefault(_waveform);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieLine = function (_Serie) {
	    _inherits(SerieLine, _Serie);

	    _createClass(SerieLine, null, [{
	      key: 'default',
	      value: function _default() {
	        /**
	         * @name SerieLineDefaultOptions
	         * @object
	         * @static
	         * @memberof SerieLine
	         */
	        return {

	          lineColor: 'black',
	          lineStyle: 1,
	          flip: false,
	          label: '',
	          lineWidth: 1,
	          markers: false,
	          trackMouse: false,
	          trackMouseLabel: false,
	          trackMouseLabelRouding: 1,
	          lineToZero: false,
	          selectableOnClick: false,
	          markersIndependant: false,
	          overflowX: false,
	          overflowY: false
	        };
	      }
	    }]);

	    function SerieLine(graph, name, options) {
	      _classCallCheck(this, SerieLine);

	      var _this = _possibleConstructorReturn(this, (SerieLine.__proto__ || Object.getPrototypeOf(SerieLine)).apply(this, arguments));

	      _this.selectionType = 'unselected';
	      _this.markerFamilies = {};

	      util.mapEventEmission(_this.options, _this); // Register events

	      // Creates an empty style variable
	      _this.styles = {};

	      // Unselected style
	      _this.styles.unselected = {
	        lineColor: _this.options.lineColor,
	        lineStyle: _this.options.lineStyle,
	        lineWidth: _this.options.lineWidth,
	        markers: _this.options.markers
	      };

	      _this.styles.selected = {
	        lineWidth: 3
	      };

	      _this.extendStyles();
	      _this.markersDom = new Map();

	      _this.shown = true;

	      _this.data = [];
	      _this._isMinOrMax = {
	        x: {
	          min: false,
	          max: false
	        },
	        y: {
	          min: false,
	          max: false
	        }
	      };

	      // Optimize is no markerPoints => save loops
	      //      this.markerPoints = {};

	      _this.groupLines = document.createElementNS(_this.graph.ns, 'g');
	      _this.domMarker = document.createElementNS(_this.graph.ns, 'path');
	      _this.domMarker.style.cursor = 'pointer';

	      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');
	      _this.additionalData = {};

	      _this.marker = document.createElementNS(_this.graph.ns, 'circle');
	      _this.marker.setAttribute('fill', 'black');
	      _this.marker.setAttribute('r', 3);
	      _this.marker.setAttribute('display', 'none');

	      _this.markerLabel = document.createElementNS(_this.graph.ns, 'text');
	      _this.markerLabelSquare = document.createElementNS(_this.graph.ns, 'rect');
	      _this.markerLabelSquare.setAttribute('fill', 'white');
	      _this.domMarkerHover = {};
	      _this.domMarkerSelect = {};
	      _this.markerHovered = 0;
	      _this.groupMarkerSelected = document.createElementNS(_this.graph.ns, 'g');

	      _this.markerPoints = {};

	      //this.scale = 1;
	      //this.shift = 0;
	      _this.lines = [];

	      _this.groupMain.appendChild(_this.groupLines);

	      _this.groupMain.appendChild(_this.marker);

	      _this.groupMain.appendChild(_this.groupMarkerSelected);
	      _this.groupMain.appendChild(_this.markerLabelSquare);
	      _this.groupMain.appendChild(_this.markerLabel);

	      _this.groupMarkers = document.createElementNS(_this.graph.ns, 'g');
	      _this.groupMain.appendChild(_this.groupMarkers);

	      _this.independantMarkers = [];

	      if (_this.initExtended1) {
	        _this.initExtended1();
	      }

	      _this.groupLines.addEventListener('click', function (e) {

	        if (_this.options.selectableOnClick) {

	          if (_this.isSelected()) {

	            _this.graph.unselectSerie(_this);
	          } else {
	            _this.graph.selectSerie(_this);
	          }
	        }
	      });

	      if (_this.options.markers) {
	        _this.setMarkers(_this.options.markers, 'unselected');
	      }

	      return _this;
	    }

	    /**
	     * Sets the options of the serie
	     * @see SerieLineDefaultOptions
	     * @param {Object} options - A object containing the options to set
	     * @return {SerieLine} The current serie
	     * @memberof SerieLine
	     */


	    _createClass(SerieLine, [{
	      key: 'setOptions',
	      value: function setOptions(options) {
	        this.options = util.extend(true, {}, SerieLine.prototype.defaults, options || {});
	        // Unselected style
	        this.styles.unselected = {
	          lineColor: this.options.lineColor,
	          lineStyle: this.options.lineStyle,
	          markers: this.options.markers
	        };

	        this.applyLineStyles();
	        return this;
	      }
	    }, {
	      key: 'onMouseOverMarker',
	      value: function onMouseOverMarker(e, index) {

	        var toggledOn = this.toggleMarker(index, true, true);

	        if (this.options.onMouseOverMarker) {

	          this.options.onMouseOverMarker(index, this.infos ? this.infos[index] || false : false, [this.waveform.getX(index), this.waveform.getY(index)]);
	        }
	      }
	    }, {
	      key: 'onMouseOutMarker',
	      value: function onMouseOutMarker(e, index) {
	        this.markersOffHover();

	        if (this.options.onMouseOutMarker) {
	          this.options.onMouseOutMarker(index, this.infos ? this.infos[index] || false : false, [this.waveform.getX(index), this.waveform.getY(index)]);
	        }
	      }
	    }, {
	      key: 'toggleMarker',
	      value: function toggleMarker(index, force, hover) {

	        var i = index;

	        var _on;
	        if (typeof force === 'undefined') {
	          _on = !hover ? !this.domMarkerSelect[index] : !this.domMarkerHover[index];
	        }
	        var el = this['domMarker' + (hover ? 'Hover' : 'Select')];

	        if (_on || force === true) {

	          if (!el[index]) {

	            var dom = document.createElementNS(this.graph.ns, 'path');

	            this.setMarkerStyleTo(dom, this.markerFamilies[this.selectionType][this.getMarkerCurrentFamily(i)]);
	            this['domMarker' + (hover ? 'Hover' : 'Select')][index] = dom;
	            this.groupMarkerSelected.appendChild(dom);
	          } else {
	            dom = el[index];
	          }

	          var x = this.getX(this.waveform.getX(i)),
	              y = this.getY(this.waveform.getY(i));

	          dom.setAttribute('d', 'M ' + x + ' ' + y + ' ' + this.getMarkerPath(this.markerFamilies[this.selectionType][this.getMarkerCurrentFamily(i)], 1));

	          if (hover) {
	            this.markerHovered++;
	          }
	        } else if (!_on || force === false) {

	          if (hover && this.domMarkerHover[index] && !this.domMarkerSelect[index] || this.domMarkerSelect[index]) {

	            if (!el[index]) {
	              return;
	            }

	            this.groupMarkerSelected.removeChild(el[index]);

	            delete el[index];

	            if (hover) this.markerHovered--;
	          }
	        }

	        return _on;
	      }
	    }, {
	      key: 'markersOffHover',
	      value: function markersOffHover() {

	        for (var i in this.domMarkerHover) {
	          this.toggleMarker(i.split(','), false, true);
	        }
	        return this;
	      }
	    }, {
	      key: 'markersOffSelect',
	      value: function markersOffSelect() {

	        for (var i in this.domMarkerSelect) {
	          this.toggleMarker(i.split(','), false, false);
	        }
	        return this;
	      }
	    }, {
	      key: 'onClickOnMarker',
	      value: function onClickOnMarker(e, index) {

	        var toggledOn = this.toggleMarker(index);

	        if (toggledOn && this.options.onSelectMarker) {
	          this.options.onSelectMarker(index, this.infos ? this.infos[index[0]] || false : false);
	        }

	        if (!toggledOn && this.options.onUnselectMarker) {
	          this.options.onUnselectMarker(index, this.infos ? this.infos[index[0]] || false : false);
	        }

	        if (this.options.onToggleMarker) {
	          this.options.onToggleMarker(index, this.infos ? this.infos[index[0]] || false : false, toggledOn);
	        }
	      }
	    }, {
	      key: '_getMarkerIndexFromEvent',
	      value: function _getMarkerIndexFromEvent(e) {
	        var px = this.graph._getXY(e);

	        //  return this.searchIndexByPxXY( ( px.x ), ( px.y ) );
	        return this.searchIndexByPxXY(px.x - this.graph.getPaddingLeft(), px.y - this.graph.getPaddingTop());
	      }
	    }, {
	      key: 'onMouseWheel',
	      value: function onMouseWheel() {}
	    }, {
	      key: 'empty',
	      value: function empty() {

	        for (var i = 0, l = this.lines.length; i < l; i++) {
	          this.groupLines.removeChild(this.lines[i]);
	        }
	        this.lines = [];

	        return this;
	      }
	    }, {
	      key: 'select',
	      value: function select(selectionType) {

	        selectionType = selectionType || 'selected';

	        this.selected = selectionType !== 'unselected';

	        if (this.areMarkersShown() || this.areMarkersShown(selectionType)) {
	          this.selectionType = selectionType;

	          this.draw(true); // Drawing is absolutely required here
	          this.applyLineStyles();
	        } else {
	          this.selectionType = selectionType;
	          this.applyLineStyles();
	        }

	        this.applyLineStyle(this.getSymbolForLegend());
	        return this;
	      }
	    }, {
	      key: 'unselect',
	      value: function unselect() {

	        this.selected = false;

	        return this.select('unselected');
	      }
	    }, {
	      key: 'degrade',
	      value: function degrade(pxPerP) {

	        this.degradationPx = pxPerP;
	        return this;
	      }
	    }, {
	      key: 'drawInit',
	      value: function drawInit(force) {
	        var _this2 = this;

	        try {
	          this.axisCheck();
	        } catch (e) {
	          console.warn(e);
	          return false;
	        }

	        this.currentLineId = 0;
	        this.counter = 0;
	        this._drawn = true;
	        this.currentLine = '';

	        // Degradation

	        if (this.waveform) {

	          if (this.degradationPx) {

	            this.waveform.resampleForDisplay({

	              resampleToPx: this.degradationPx,
	              xPosition: this.getXAxis().getPx.bind(this.getXAxis()),
	              minX: this.getXAxis().getCurrentMin(),
	              maxX: this.getXAxis().getCurrentMax()

	            });

	            this._dataToUse = [this.waveform.getDataToUseFlat()];
	          } else if (this.waveform.hasAggregation()) {

	            var xaxis = this.getXAxis(),
	                numberOfPointsInTotal = this.graph.getDrawingWidth() * (xaxis.getDataMax() - xaxis.getDataMin()) / (xaxis.getCurrentMax() - xaxis.getCurrentMin()),
	                promise = this.waveform.selectAggregatedData(numberOfPointsInTotal);

	            if (promise instanceof Promise) {

	              promise.then(function () {

	                _this2.draw(force);
	              });

	              return false;
	            } else if (promise === false) {

	              return false;
	            } else {

	              this._dataToUse = this.waveform.getDataToUseFlat();
	            }
	          }

	          //    this._dataToUse = this.waveform.getDataToUseFlat();
	        } else {

	          this._dataToUse = this.data;
	          this._xDataToUse = this.xData;
	        }

	        return true;
	      }
	    }, {
	      key: 'removeLinesGroup',
	      value: function removeLinesGroup() {
	        this._afterLinesGroup = this.groupLines.nextSibling;
	        this.groupMain.removeChild(this.groupLines);
	      }
	    }, {
	      key: 'insertLinesGroup',
	      value: function insertLinesGroup() {

	        if (!this._afterLinesGroup) {
	          throw 'Could not find group after lines to insertion.';
	        }

	        this.groupMain.insertBefore(this.groupLines, this._afterLinesGroup);
	        this._afterLinesGroup = false;
	      }
	    }, {
	      key: 'removeExtraLines',
	      value: function removeExtraLines() {

	        var i = this.currentLineId,
	            l = this.lines.length;

	        for (; i < l; i++) {
	          this.groupLines.removeChild(this.lines[i]);
	        }

	        this.lines.splice(this.currentLineId, l - this.currentLineId);
	        this.currentLineId = 0;
	      }
	    }, {
	      key: 'draw',
	      value: function draw(force) {
	        // Serie redrawing

	        _get(SerieLine.prototype.__proto__ || Object.getPrototypeOf(SerieLine.prototype), 'draw', this).apply(this, arguments);

	        if (!this.getXAxis() || !this.getYAxis()) {
	          throw 'No axes were defined for this serie';
	        }

	        if (force || this.hasDataChanged()) {
	          if (!this.drawInit(force)) {
	            return;
	          }

	          var data = this._dataToUse,
	              xData = this._xDataToUse,
	              slotToUse = this._slotToUse;

	          this.removeLinesGroup();
	          this.eraseMarkers();

	          this.lookForMaxima = true;
	          this.lookForMinima = false;

	          this.markerFamily = this.markerFamilies[this.selectionType || 'unselected'];

	          this.pos0 = this.getYAxis().getPos(0);

	          if (this.hasErrors()) {
	            this.errorDrawInit();
	          }

	          this._draw();

	          if (this.hasErrors()) {
	            this.errorDraw();
	          }

	          this.removeExtraLines();
	          this.insertMarkers();
	          this.insertLinesGroup();
	        }

	        // Unhovers everything
	        for (var i in this.domMarkerHover) {
	          this.toggleMarker(i.split(','), false, true);
	        }

	        // Deselects everything
	        for (var i in this.domMarkerSelect) {
	          this.toggleMarker(i.split(','), false, false);
	        }

	        this.applyLineStyle(this.getSymbolForLegend());

	        if (this.hasStyleChanged(this.selectionType)) {
	          this.updateStyle();
	        }

	        this.dataHasChanged(false);
	        _get(SerieLine.prototype.__proto__ || Object.getPrototypeOf(SerieLine.prototype), 'afterDraw', this).call(this);
	      }
	    }, {
	      key: '_draw',
	      value: function _draw() {
	        var _this3 = this;

	        var waveform = this.waveform,
	            data = void 0,
	            x = void 0,
	            y = void 0,
	            lastX = false,
	            lastY = false,
	            xpx = void 0,
	            ypx = void 0,
	            xpx2 = void 0,
	            ypx2 = void 0,
	            xAxis = this.getXAxis(),
	            yAxis = this.getYAxis(),
	            xMin = xAxis.getCurrentMin(),
	            yMin = yAxis.getCurrentMin(),
	            xMax = xAxis.getCurrentMax(),
	            yMax = yAxis.getCurrentMax();

	        if (!waveform) {
	          return;
	        }

	        data = waveform.getData(true);

	        // Y crossing
	        var yLeftCrossingRatio = void 0,
	            yLeftCrossing = void 0,
	            yRightCrossingRatio = void 0,
	            yRightCrossing = void 0,
	            xTopCrossingRatio = void 0,
	            xTopCrossing = void 0,
	            xBottomCrossingRatio = void 0,
	            xBottomCrossing = void 0,


	        /*xshift = waveform.getXShift(),
	        xscale = wave.getXScale(),*/
	        yshift = waveform.getShift(),
	            yscale = waveform.getScale();

	        var pointOutside = false;
	        var lastPointOutside = false;
	        var pointOnAxis = void 0;

	        var _monotoneous = this.isMonotoneous(),
	            _markersShown = this.markersShown();

	        var i = 0,
	            l = waveform.getLength();

	        this.currentLine = '';

	        if (waveform.isXMonotoneous()) {

	          if (waveform.isXMonotoneousAscending()) {

	            try {
	              i = waveform.getIndexFromX(xMin, true) || 0;
	              l = waveform.getIndexFromX(xMax, true);
	            } catch (e) {

	              l = waveform.getLength();
	            }
	          } else {

	            try {
	              i = waveform.getIndexFromX(xMax, true) || 0;
	              l = waveform.getIndexFromX(xMin, true);
	            } catch (e) {

	              l = waveform.getLength();
	            }
	          }

	          l += 2;
	          if (l > data.length) {
	            l = data.length;
	          }
	        }

	        for (; i < l; i += 1) {

	          x = waveform.getX(i, true);
	          y = data[i] * yscale + yshift;

	          if (x != x || y != y) {
	            // NaN checks
	            this._createLine();
	            continue;
	          }

	          if (!this.options.overflowX && x < xMin && lastX < xMin || !this.options.overflowX && x > xMax && lastX > xMax || (!this.options.overflowY && y < yMin && lastY < yMin || !this.options.overflowY && y > yMax && lastY > yMax) && !this.options.lineToZero) {
	            lastX = x;
	            lastY = y;
	            lastPointOutside = true;
	            continue;
	          }

	          this.counter2 = i;

	          if (_markersShown) {
	            this.getMarkerCurrentFamily(this.counter2);
	          }

	          xpx2 = this.getX(x);
	          ypx2 = this.getY(y);
	          //xpx2 = 0;
	          //ypx2 = 0;

	          if (xpx2 == xpx && ypx2 == ypx) {
	            continue;
	          }

	          if (xpx2 != xpx2 || ypx2 != ypx2) {
	            // NaN checks
	            if (this.counter > 0) {

	              this._createLine();
	            }
	            continue;
	          }

	          if (!_monotoneous) {

	            pointOutside = !this.options.overflowX && (x < xMin || x > xMax) || !this.options.overflowY && (y < yMin || y > yMax);
	          } else {
	            pointOutside = !this.options.overflowY && (y < yMin || y > yMax);
	          }

	          if (this.options.lineToZero) {
	            pointOutside = x < xMin || x > xMax;

	            if (pointOutside) {
	              continue;
	            }
	          } else {

	            if (pointOutside || lastPointOutside) {

	              if ((lastX === false || lastY === false) && !lastPointOutside) {

	                xpx = xpx2;
	                ypx = ypx2;
	                lastX = x;
	                lastY = y;
	              } else {

	                pointOnAxis = [];
	                // Y crossing
	                yLeftCrossingRatio = (x - xMin) / (x - lastX);
	                yLeftCrossing = y - yLeftCrossingRatio * (y - lastY);
	                yRightCrossingRatio = (x - xMax) / (x - lastX);
	                yRightCrossing = y - yRightCrossingRatio * (y - lastY);

	                // X crossing
	                xTopCrossingRatio = (y - yMin) / (y - lastY);
	                xTopCrossing = x - xTopCrossingRatio * (x - lastX);
	                xBottomCrossingRatio = (y - yMax) / (y - lastY);
	                xBottomCrossing = x - xBottomCrossingRatio * (x - lastX);

	                if (yLeftCrossingRatio < 1 && yLeftCrossingRatio > 0 && yLeftCrossing !== false && yLeftCrossing < yMax && yLeftCrossing > yMin) {
	                  pointOnAxis.push([xMin, yLeftCrossing]);
	                }

	                if (yRightCrossingRatio < 1 && yRightCrossingRatio > 0 && yRightCrossing !== false && yRightCrossing < yMax && yRightCrossing > yMin) {
	                  pointOnAxis.push([xMax, yRightCrossing]);
	                }

	                if (xTopCrossingRatio < 1 && xTopCrossingRatio > 0 && xTopCrossing !== false && xTopCrossing < xMax && xTopCrossing > xMin) {
	                  pointOnAxis.push([xTopCrossing, yMin]);
	                }

	                if (xBottomCrossingRatio < 1 && xBottomCrossingRatio > 0 && xBottomCrossing !== false && xBottomCrossing < xMax && xBottomCrossing > xMin) {
	                  pointOnAxis.push([xBottomCrossing, yMax]);
	                }

	                if (pointOnAxis.length > 0) {

	                  if (!pointOutside) {
	                    // We were outside and now go inside

	                    if (pointOnAxis.length > 1) {
	                      console.error('Programmation error. Please e-mail me.');
	                      console.log(pointOnAxis, xBottomCrossing, xTopCrossing, yRightCrossing, yLeftCrossing, y, yMin, yMax, lastY);
	                    }

	                    this._createLine();
	                    this._addPoint(this.getX(pointOnAxis[0][0]), this.getY(pointOnAxis[0][1]), pointOnAxis[0][0], pointOnAxis[0][1], false, false, false);
	                    this._addPoint(xpx2, ypx2, lastX, lastY, false, false, true);
	                  } else if (!lastPointOutside) {
	                    // We were inside and now go outside

	                    if (pointOnAxis.length > 1) {
	                      console.error('Programmation error. Please e-mail me.');
	                      console.log(pointOnAxis, xBottomCrossing, xTopCrossing, yRightCrossing, yLeftCrossing, y, yMin, yMax, lastY);
	                    }

	                    this._addPoint(this.getX(pointOnAxis[0][0]), this.getY(pointOnAxis[0][1]), pointOnAxis[0][0], pointOnAxis[0][1], false, false, false);
	                  } else {

	                    // No crossing: do nothing
	                    if (pointOnAxis.length == 2) {
	                      this._createLine();

	                      this._addPoint(this.getX(pointOnAxis[0][0]), this.getY(pointOnAxis[0][1]), pointOnAxis[0][0], pointOnAxis[0][1], false, false, false);
	                      this._addPoint(this.getX(pointOnAxis[1][0]), this.getY(pointOnAxis[1][1]), pointOnAxis[0][0], pointOnAxis[0][1], false, false, false);
	                    }
	                  }
	                } else if (!pointOutside) {

	                  this._addPoint(xpx2, ypx2, lastX, lastY, i, false, false);
	                } // else {
	                // Norman:
	                // This else case is not the sign of a bug. If yLeftCrossing == 0 or 1 for instance, pointOutside or lastPointOutside will be true
	                // However, there's no need to draw anything because the point is on the axis and will already be covered.
	                // 28 Aug 2015

	                /*
	                  if ( lastPointOutside !== pointOutside ) {
	                    console.error( "Programmation error. A crossing should have been found" );
	                    console.log( yLeftCrossing, yLeftCrossingRatio, yMax, yMin );
	                    console.log( yRightCrossing, yRightCrossingRatio, yMax, yMin );
	                    console.log( xTopCrossing, xTopCrossingRatio, xMax, xMin );
	                    console.log( xBottomCrossing, xBottomCrossingRatio, xMax, xMin );
	                    console.log( pointOutside, lastPointOutside )
	                   }
	                  */
	                // }
	              }

	              xpx = xpx2;
	              ypx = ypx2;
	              lastX = x;
	              lastY = y;

	              lastPointOutside = pointOutside;

	              continue;
	            }
	          }

	          this._addPoint(xpx2, ypx2, x, y, i, false, true);

	          //this.detectPeaks( x, y );

	          xpx = xpx2;
	          ypx = ypx2;

	          lastX = x;
	          lastY = y;
	        }

	        this._createLine();

	        if (this._tracker) {

	          if (this._trackerDom) {
	            this._trackerDom.remove();
	          }

	          var cloned = this.groupLines.cloneNode(true);
	          this.groupMain.appendChild(cloned);

	          for (i = 0, l = cloned.children.length; i < l; i++) {

	            cloned.children[i].setAttribute('stroke', 'transparent');
	            cloned.children[i].setAttribute('stroke-width', '25px');
	            cloned.children[i].setAttribute('pointer-events', 'stroke');
	          }

	          this._trackerDom = cloned;

	          this.groupMain.addEventListener('mousemove', function (e) {
	            var coords = _this3.graph._getXY(e),
	                ret = _this3.handleMouseMove(false, false);

	            _this3._trackingCallback(_this3, ret, coords.x, coords.y);
	          });

	          this.groupMain.addEventListener('mouseleave', function (e) {
	            _this3._trackingOutCallback(_this3);
	          });
	        }

	        return this;
	      }
	    }, {
	      key: 'kill',
	      value: function kill() {
	        _get(SerieLine.prototype.__proto__ || Object.getPrototypeOf(SerieLine.prototype), 'kill', this).call(this);
	      }
	    }, {
	      key: 'getMarkerCurrentFamily',
	      value: function getMarkerCurrentFamily(k) {

	        if (!this.markerPoints || !this.markerPoints[this.selectionType]) {
	          return;
	        }

	        var family;

	        for (var z = 0; z < this.markerPoints[this.selectionType].length; z++) {
	          if (this.markerPoints[this.selectionType][z][0] <= k) {
	            // This one is a possibility !
	            if (this.markerPoints[this.selectionType][z][1] >= k) {
	              // Verify that it's in the boundary
	              this.markerCurrentFamily = this.markerPoints[this.selectionType][z][2];
	              family = this.markerFamilies[this.selectionType][this.markerCurrentFamily];
	            }
	          } else {
	            break;
	          }
	        }

	        if (!family) {
	          return false;
	        }
	        this.getMarkerDom(family);
	        return this.markerCurrentFamily;
	      }
	    }, {
	      key: 'setMarkerStyleTo',
	      value: function setMarkerStyleTo(dom, family) {

	        if (!dom || !family) {
	          console.trace();
	          throw 'Cannot set marker style. DOM does not exist.';
	        }

	        dom.setAttribute('fill', family.fillColor || 'transparent');
	        dom.setAttribute('stroke', family.strokeColor || this.getLineColor());
	        dom.setAttribute('stroke-width', family.strokeWidth || 1);
	      }
	    }, {
	      key: 'hideTrackingMarker',
	      value: function hideTrackingMarker() {
	        this.marker.setAttribute('display', 'none');
	        this.markerLabel.setAttribute('display', 'none');
	        this.markerLabelSquare.setAttribute('display', 'none');
	      }
	    }, {
	      key: '_addPoint',
	      value: function _addPoint(xpx, ypx, x, y, j, move, allowMarker) {

	        /*if( ! this.currentLineId ) {
	            throw "No current line"
	          }* @memberof SerieLine
	        */

	        if (xpx !== xpx || ypx !== ypx) {
	          return;
	        }

	        if (this.counter == 0) {
	          this.currentLine = 'M ';
	        } else {

	          if (this.options.lineToZero || move) {
	            this.currentLine += 'M ';
	          } else {
	            this.currentLine += 'L ';
	          }
	        }

	        this.currentLine += xpx;
	        this.currentLine += ' ';
	        this.currentLine += ypx;
	        this.currentLine += ' ';

	        if (this.options.lineToZero && this.pos0 !== undefined) {

	          this.currentLine += 'L ';
	          this.currentLine += xpx;
	          this.currentLine += ' ';
	          this.currentLine += this.pos0;
	          this.currentLine += ' ';
	        }

	        if (this.hasErrors()) {
	          this.errorAddPoint(j, x, y, xpx, ypx);
	        }

	        if (!this.markerPoints) {
	          this.counter++;

	          return;
	        }

	        if (this.markersShown() && allowMarker !== false && this.markerFamily) {
	          drawMarkerXY(this, this.markerFamily[this.markerCurrentFamily], xpx, ypx, this.markersDom.get(this.markerFamily[this.markerCurrentFamily]));
	        }

	        this.counter++;
	      }
	    }, {
	      key: '_createLine',
	      value: function _createLine() {

	        var i = this.currentLineId++,
	            line;

	        // Creates a line if needed
	        if (this.lines[i]) {
	          line = this.lines[i];
	        } else {

	          line = document.createElementNS(this.graph.ns, 'path');
	          this.applyLineStyle(line);
	          this.groupLines.appendChild(line);
	          this.lines[i] = line;
	        }

	        if (this.counter == 0) {
	          line.setAttribute('d', '');
	        } else {
	          line.setAttribute('d', this.currentLine);
	        }

	        this.currentLine = 'M ';
	        this.counter = 0;

	        return line;
	      }
	    }, {
	      key: 'applyLineStyles',
	      value: function applyLineStyles() {

	        for (var i = 0; i < this.lines.length; i++) {
	          this.applyLineStyle(this.lines[i]);
	        }
	      }
	    }, {
	      key: 'applyLineStyle',
	      value: function applyLineStyle(line) {

	        line.setAttribute('stroke', this.getLineColor());
	        line.setAttribute('stroke-width', this.getLineWidth());
	        if (this.getLineDashArray()) {
	          line.setAttribute('stroke-dasharray', this.getLineDashArray());
	        } else {
	          line.removeAttribute('stroke-dasharray');
	        }
	        line.setAttribute('fill', 'none');
	        //	line.setAttribute('shape-rendering', 'optimizeSpeed');
	      }
	    }, {
	      key: 'updateStyle',
	      value: function updateStyle() {
	        this.applyLineStyles();
	        this.setLegendSymbolStyle();

	        this.styleHasChanged(false);
	      }
	    }, {
	      key: 'getMarkerPath',
	      value: function getMarkerPath(family, add) {

	        var z = family.zoom || 1,
	            add = add || 0,
	            el = [];

	        switch (family.type) {

	          case 2:
	            el = ['m', -2, -2, 'l', 4, 4, 'm', -4, 0, 'l', 4, -4];
	            break;

	          case 3:
	            el = ['m', -2, 0, 'l', 4, 0, 'm', -2, -2, 'l', 0, 4];
	            break;

	          case 4:
	            el = ['m', -1, -1, 'l', 2, 0, 'l', -1, 2, 'z'];
	            break;

	          default:
	          case 1:
	            el = ['m', -2, -2, 'l', 4, 0, 'l', 0, 4, 'l', -4, 0, 'z'];
	            break;

	        }

	        if ((z == 1 || !z) && !add) {
	          return el.join(' ');
	        }

	        var num = 'number';

	        if (!el) {
	          return;
	        }

	        for (var i = 0, l = el.length; i < l; i++) {

	          if (_typeof(el[i]) == num) {

	            el[i] *= z + add;
	          }
	        }

	        return el.join(' ');
	      }
	    }, {
	      key: 'getMarkerDom',
	      value: function getMarkerDom(family) {

	        var self = this;

	        if (!this.markersDom.has(family)) {

	          var dom = document.createElementNS(this.graph.ns, 'path');
	          this.setMarkerStyleTo(dom, family);
	          this.markersDom.set(family, {
	            dom: dom,
	            path: ''
	          });

	          dom.addEventListener('mouseover', function (e) {
	            var closest = self._getMarkerIndexFromEvent(e);
	            self.onMouseOverMarker(e, closest);
	          });

	          dom.addEventListener('mouseout', function (e) {
	            var closest = self._getMarkerIndexFromEvent(e);
	            self.onMouseOutMarker(e, closest);
	          });

	          dom.addEventListener('click', function (e) {
	            var closest = self._getMarkerIndexFromEvent(e);
	            self.onClickOnMarker(e, closest);
	          });
	        }

	        return family.dom;
	      }
	    }, {
	      key: 'getMarkerDomIndependent',
	      value: function getMarkerDomIndependent(index, family) {
	        var _this4 = this;

	        if (!this.independantMarkers[index]) {

	          var dom = document.createElementNS(this.graph.ns, 'path');
	          this.setMarkerStyleTo(dom, family);

	          dom.addEventListener('mouseover', function (e) {

	            _this4.onMouseOverMarker(e, index);
	          });

	          dom.addEventListener('mouseout', function (e) {

	            _this4.onMouseOutMarker(e, index);
	          });

	          dom.addEventListener('click', function (e) {

	            _this4.onClickOnMarker(e, index);
	          });

	          this.independantMarkers[index] = dom;
	        }

	        this.groupMarkers.appendChild(this.independantMarkers[index]);

	        return this.independantMarkers[index];
	      }
	    }, {
	      key: 'searchIndexByPxXY',
	      value: function searchIndexByPxXY(x, y) {

	        var oldDist = false,
	            xyindex = false,
	            dist;

	        var xData = this._xDataToUse,
	            p_x,
	            p_y;

	        for (var k = 0, m = this.waveform.getLength(); k < m; k += 1) {

	          p_x = this.waveform.getX(k);
	          p_y = this.waveform.getY(k);

	          dist = Math.pow(this.getX(p_x) - x, 2) + Math.pow(this.getY(p_y) - y, 2);
	          //console.log(x, y, dist, this.data[i][k], this.data[i][k + 1]);

	          if (!oldDist || dist < oldDist) {
	            oldDist = dist;
	            xyindex = k;
	          }
	        }

	        return xyindex;
	      }
	    }, {
	      key: 'searchClosestValue',
	      value: function searchClosestValue(valX, valY) {

	        if (this.waveform) {

	          var indexX = this.waveform.getIndexFromXY(valX, valY, undefined, undefined, this.getXAxis().getRelPx(1), this.getYAxis().getRelPx(1));

	          var returnObj = {};

	          var direction = void 0;

	          if (valX > this.waveform.getX(indexX)) {
	            direction = 0;
	          } else {
	            direction = 1;
	          }

	          Object.assign(returnObj, {
	            indexMin: indexX + direction,
	            indexMax: indexX + direction + 1,
	            indexClosest: indexX,
	            xMin: this.waveform.getX(indexX + direction),
	            xMax: this.waveform.getX(indexX + direction + 1),
	            yMin: this.waveform.getY(indexX + direction),
	            yMax: this.waveform.getY(indexX + direction + 1),
	            xClosest: this.waveform.getX(indexX),
	            yClosest: this.waveform.getY(indexX),
	            xExact: valX
	          });
	          return returnObj;
	        }
	      }
	    }, {
	      key: 'handleMouseMove',
	      value: function handleMouseMove(xValue, doMarker, yValue) {

	        var valX = xValue || this.getXAxis().getMouseVal(),
	            valY = yValue || this.getYAxis().getMouseVal();

	        var value = this.searchClosestValue(valX, valY);

	        if (!value) {
	          return;
	        }

	        var intY;

	        if (value.xMax == value.xMin) {
	          intY = value.yMin;
	        }

	        if (doMarker && this.options.trackMouse) {

	          if (value.xMin == undefined) {

	            return false;
	          } else {

	            if (!this.marker) {
	              return;
	            }

	            var x = this.getX(this.getFlip() ? value.yClosest : value.xClosest);
	            var y = this.getY(this.getFlip() ? value.xClosest : value.yClosest);

	            if (isNaN(x) || isNaN(y)) {
	              return;
	            }

	            this.marker.setAttribute('display', 'block');
	            this.marker.setAttribute('cx', x);
	            this.marker.setAttribute('cy', y);

	            this.markerLabel.setAttribute('display', 'block');
	            this.markerLabelSquare.setAttribute('display', 'block');

	            switch (this.options.trackMouseLabel) {

	              case false:

	                break;

	              default:
	                this.markerLabel.textContent = this.options.trackMouseLabel.replace('<x>', valX.toFixed(this.options.trackMouseLabelRouding)).replace('<y>', intY.toFixed(this.options.trackMouseLabelRouding));
	                break;
	            }

	            this.markerLabel.setAttribute('x', x + 5);
	            this.markerLabel.setAttribute('y', y - 5);

	            this.markerLabelSquare.setAttribute('x', x + 5);
	            this.markerLabelSquare.setAttribute('y', y - 5 - this.graph.options.fontSize);
	            this.markerLabelSquare.setAttribute('width', this.markerLabel.getComputedTextLength() + 2);
	            this.markerLabelSquare.setAttribute('height', this.graph.options.fontSize + 2);
	          }
	        }

	        return {
	          xBefore: value.xMin,
	          xAfter: value.xMax,
	          yBefore: value.yMin,
	          yAfter: value.yMax,
	          trueX: value.xExact,
	          indexClosest: value.indexClosest,
	          interpolatedY: intY,

	          xClosest: value.xClosest,
	          yClosest: value.yClosest
	        };
	      }
	    }, {
	      key: 'getMax',
	      value: function getMax(start, end) {

	        var start2 = Math.min(start, end),
	            end2 = Math.max(start, end),
	            v1 = this.searchClosestValue(start2),
	            v2 = this.searchClosestValue(end2),
	            i,
	            j,
	            max = -Infinity,
	            initJ,
	            maxJ;

	        //      console.log( start2, end2, v1, v2 );

	        if (!v1) {
	          start2 = this.minX;
	          v1 = this.searchClosestValue(start2);
	        }

	        if (!v2) {
	          end2 = this.maxX;
	          v2 = this.searchClosestValue(end2);
	        }

	        if (!v1 || !v2) {
	          return -Infinity;
	        }

	        for (i = v1.dataIndex; i <= v2.dataIndex; i++) {
	          initJ = i == v1.dataIndex ? v1.xBeforeIndexArr : 0;
	          maxJ = i == v2.dataIndex ? v2.xBeforeIndexArr : this.data[i].length;

	          for (j = initJ; j <= maxJ; j += 2) {
	            max = Math.max(max, this.data[i][j + 1]);
	          }
	        }

	        return max;
	      }
	    }, {
	      key: 'getMin',
	      value: function getMin(start, end) {

	        var start2 = Math.min(start, end),
	            end2 = Math.max(start, end),
	            v1 = this.searchClosestValue(start2),
	            v2 = this.searchClosestValue(end2),
	            i,
	            j,
	            min = Infinity,
	            initJ,
	            maxJ;

	        if (!v1) {
	          start2 = this.minX;
	          v1 = this.searchClosestValue(start2);
	        }

	        if (!v2) {
	          end2 = this.maxX;
	          v2 = this.searchClosestValue(end2);
	        }

	        if (!v1 || !v2) {
	          return Infinity;
	        }

	        for (i = v1.dataIndex; i <= v2.dataIndex; i++) {
	          initJ = i == v1.dataIndex ? v1.xBeforeIndexArr : 0;
	          maxJ = i == v2.dataIndex ? v2.xBeforeIndexArr : this.data[i].length;

	          for (j = initJ; j <= maxJ; j += 2) {
	            min = Math.min(min, this.data[i][j + 1]);
	          }
	        }

	        return min;
	      }
	    }, {
	      key: 'setStyle',
	      value: function setStyle(style) {
	        var selectionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unselected';


	        this.styles[selectionType] = style;
	        this.styleHasChanged(selectionType);
	      }
	    }, {
	      key: 'setLineStyle',
	      value: function setLineStyle(number) {
	        var selectionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unselected';
	        var applyToSelected = arguments[2];


	        this.styles[selectionType] = this.styles[selectionType] || {};
	        this.styles[selectionType].lineStyle = number;

	        if (applyToSelected) {
	          this.setLineStyle(number, 'selected');
	        }

	        this.styleHasChanged(selectionType);

	        return this;
	      }
	    }, {
	      key: 'getLineStyle',
	      value: function getLineStyle(selectionType) {
	        return this.getStyle(selectionType).lineStyle;
	      }
	    }, {
	      key: 'getLineDashArray',
	      value: function getLineDashArray() {
	        var selectionType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectionType || 'unselected';


	        switch (this.getStyle(selectionType).lineStyle) {

	          case 2:
	            return '1, 1';
	            break;
	          case 3:
	            return '2, 2';
	            break;
	          case 4:
	            return '3, 3';
	            break;
	          case 5:
	            return '4, 4';
	            break;
	          case 6:
	            return '5, 5';
	            break;

	          case 7:
	            return '5 2';
	            break;
	          case 8:
	            return '2 5';
	            break;

	          case 9:
	            return '4 2 4 4';
	            break;
	          case 10:
	            return '1,3,1';
	            break;
	          case 11:
	            return '9 2';
	            break;
	          case 12:
	            return '2 9';
	            break;

	          case 1:
	          case false:
	            return false;
	            break;

	          default:
	            return this.styles[selectionType].lineStyle;
	            break;
	        }

	        this.styleHasChanged(selectionType);
	      }
	    }, {
	      key: 'getStyle',
	      value: function getStyle() {
	        var selectionType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectionType || 'unselected';

	        return this.styles[selectionType];
	      }
	    }, {
	      key: 'extendStyles',
	      value: function extendStyles() {
	        for (var i in this.styles) {

	          var s = this.styles[i];
	          if (s) {
	            this.styles[i] = util.extend(true, {}, this.styles.unselected, s);
	          }
	        }
	      }
	    }, {
	      key: 'extendStyle',
	      value: function extendStyle(styleTarget, styleOrigin) {
	        var s = this.styles[styleTarget];

	        this.styles[styleTarget] = util.extend(true, {}, this.styles[styleOrigin || 'unselected'], s || {});

	        this.styles[styleTarget].markers.map(function (marker) {
	          if (marker.dom) {
	            marker.dom = '';
	          }
	        });

	        this._recalculateMarkerPoints(styleTarget, this.styles[styleTarget].markers);
	        this.styleHasChanged(styleTarget);
	      }
	    }, {
	      key: 'setLineWidth',
	      value: function setLineWidth(width, selectionType, applyToSelected) {

	        selectionType = selectionType || 'unselected';
	        this.styles[selectionType] = this.styles[selectionType] || {};
	        this.styles[selectionType].lineWidth = width;

	        if (applyToSelected) {
	          this.setLineWidth(width, 'selected');
	        }

	        this.styleHasChanged(selectionType);

	        return this;
	      }
	    }, {
	      key: 'getLineWidth',
	      value: function getLineWidth(selectionType) {

	        return this.getStyle(selectionType).lineWidth || 1;
	      }
	    }, {
	      key: 'setLineColor',
	      value: function setLineColor(color, selectionType, applyToSelected) {

	        selectionType = selectionType || 'unselected';
	        this.styles[selectionType] = this.styles[selectionType] || {};
	        this.styles[selectionType].lineColor = color;

	        if (applyToSelected) {
	          this.setLineColor(color, 'selected');
	        }

	        this.styleHasChanged(selectionType);

	        return this;
	      }
	    }, {
	      key: 'getLineColor',
	      value: function getLineColor(selectionType) {

	        return this.getStyle(selectionType).lineColor || 'black';
	      }
	    }, {
	      key: 'showMarkers',
	      value: function showMarkers(selectionType, redraw) {
	        selectionType = selectionType || 'unselected';
	        this.styles[selectionType] = this.styles[selectionType] || {};
	        this.styles[selectionType].showMarkers = true;

	        if (redraw && this._drawn) {
	          this.draw(true);
	        } else {
	          this.styleHasChanged(selectionType);
	        }

	        return this;
	      }
	    }, {
	      key: 'hideMarkers',
	      value: function hideMarkers(selectionType, redraw) {

	        selectionType = selectionType || 'unselected';
	        this.styles[selectionType].showMarkers = false;

	        if (redraw && this._drawn) {
	          this.draw(true);
	        } else {
	          this.styleHasChanged(selectionType);
	        }
	        return this;
	      }
	    }, {
	      key: 'markersShown',
	      value: function markersShown(selectionType) {
	        return this.getStyle(selectionType).showMarkers !== false;
	      }
	    }, {
	      key: 'areMarkersShown',
	      value: function areMarkersShown() {
	        return this.markersShown.apply(this, arguments);
	      }
	    }, {
	      key: 'isMarkersShown',
	      value: function isMarkersShown() {
	        return this.markersShown.apply(this, arguments);
	      }
	    }, {
	      key: 'setMarkers',
	      value: function setMarkers(families, selectionType, applyToSelected) {
	        // Family has to be an object
	        // Family looks like
	        /*
	        {
	        	type: 1,
	        	zoom: 1,
	        	strokeWidth: 1,
	        	strokeColor: '',
	        	fillColor: '',
	              points: []
	        }
	        * @memberof SerieLine
	        */

	        this.styles[selectionType || 'unselected'] = this.styles[selectionType || 'unselected'] || {};

	        this.showMarkers(selectionType, false);

	        if (!Array.isArray(families) && (typeof families === 'undefined' ? 'undefined' : _typeof(families)) == 'object') {
	          families = [families];
	        } else if (!families) {

	          families = [{
	            type: 1,
	            zoom: 1,
	            points: 'all'
	          }];
	        }

	        this.styles[selectionType || 'unselected'].markers = families;

	        if (applyToSelected) {
	          this.styles.selected.markers = util.extend(true, {}, families);
	        }

	        this._recalculateMarkerPoints(selectionType, families);
	        this.styleHasChanged(selectionType);
	        this.dataHasChanged(true); // Data has not really changed, but marker placing is performed during the draw method
	        return this;
	      }
	    }, {
	      key: 'setMarkersPoints',
	      value: function setMarkersPoints(points, family, selectionType) {
	        this._extendMarkers('points', points, family, selectionType, true);
	      }
	    }, {
	      key: 'setMarkersColor',
	      value: function setMarkersColor(color, family, selectionType) {
	        this._extendMarkers('color', color, family, selectionType);
	      }
	    }, {
	      key: 'setMarkersType',
	      value: function setMarkersType(type, family, selectionType) {
	        this._extendMarkers('type', type, family, selectionType);
	      }
	    }, {
	      key: 'setMarkersZoom',
	      value: function setMarkersZoom(zoom, family, selectionType) {
	        this._extendMarkers('zoom', zoom, family, selectionType);
	      }
	    }, {
	      key: 'setMarkersStrokeColor',
	      value: function setMarkersStrokeColor(strokeColor, family, selectionType) {
	        this._extendMarkers('strokeColor', strokeColor, family, selectionType);
	      }
	    }, {
	      key: 'setMarkersStrokeWidth',
	      value: function setMarkersStrokeWidth(strokeWidth, family, selectionType) {
	        this._extendMarkers('strokeWidth', strokeWidth, family, selectionType);
	      }
	    }, {
	      key: 'setMarkersFillColor',
	      value: function setMarkersFillColor(fillColor, family, selectionType) {
	        this._extendMarkers('fillColor', fillColor, family, selectionType);
	      }
	    }, {
	      key: '_extendMarkers',
	      value: function _extendMarkers(type, value, family, selectionType, recalculatePoints) {

	        family = family || 0;
	        selectionType = selectionType || 'unselected';

	        if (!this.styles[selectionType] || !this.styles[selectionType].markers) {
	          return;
	        }

	        this.styles[selectionType].markers[family][type] = value;

	        if (recalculatePoints) {
	          this._recalculateMarkerPoints(selectionType, this.styles[selectionType].markers);
	        }

	        if (!this.markersDom[this.styles[selectionType].markers[family]]) {
	          // DOM doesn't exist yet.
	          return;
	        }

	        this.setMarkerStyleTo(this.markersDom[this.styles[selectionType].markers[family]].dom, this.styles[selectionType].markers[family]);
	      }
	    }, {
	      key: '_recalculateMarkerPoints',
	      value: function _recalculateMarkerPoints(selectionType, families) {

	        var markerPoints = [];
	        // Overwriting any other undefined families
	        markerPoints.push([0, Infinity, null]);

	        for (var i = 0, k = families.length; i < k; i++) {

	          families[i].markerPath = this.getMarkerPath(families[i]);

	          if (!families[i].points) {
	            families[i].points = 'all';
	          }

	          if (!Array.isArray(families[i].points)) {
	            families[i].points = [families[i].points];
	          }

	          for (var j = 0, l = families[i].points.length; j < l; j++) {

	            if (families[i].points[j] == 'all') {

	              markerPoints.push([0, Infinity, i]);
	            } else if (!Array.isArray(families[i].points[j])) {

	              markerPoints.push([families[i].points[j], families[i].points[j], i]);
	              //markerPoints.push( [ family[ i ].points[ j ] + 1, null ] );
	            } else {

	              markerPoints.push([families[i].points[j][0], families[i].points[j][1], i]);
	            }
	          }
	        }

	        this.markerFamilies[selectionType || 'unselected'] = families;

	        // Let's sort if by the first index.
	        markerPoints.sort(function (a, b) {
	          return a[0] - b[0] || (a[2] == null ? -1 : 1);
	        });

	        this.markerPoints[selectionType || 'unselected'] = markerPoints;
	      }
	    }, {
	      key: 'insertMarkers',
	      value: function insertMarkers(selectionType) {

	        if (!this.markerFamilies || !this.markerFamilies[selectionType || this.selectionType] || this.options.markersIndependant) {
	          return;
	        }

	        for (var i = 0, l = this.markerFamilies[selectionType || this.selectionType].length; i < l; i++) {

	          if (!this.markersDom.has(this.markerFamilies[selectionType || this.selectionType][i])) {
	            continue;
	          }

	          var dom = this.markersDom.get(this.markerFamilies[selectionType || this.selectionType][i]);

	          dom.dom.setAttribute('d', dom.path);

	          this.groupMarkers.appendChild(dom.dom);
	          this.currentMarkersSelectionType = this.selectionType;
	        }
	      }
	    }, {
	      key: 'getMarkerForLegend',
	      value: function getMarkerForLegend() {

	        if (!this.markerPoints || !this.markerPoints[this.selectionType]) {
	          return;
	        }

	        if (!this.markerForLegend) {

	          var marker = document.createElementNS(this.graph.ns, 'path');
	          this.setMarkerStyleTo(marker, this.markerFamilies[this.selectionType][0]);

	          marker.setAttribute('d', 'M 14 0 ' + this.getMarkerPath(this.markerFamilies[this.selectionType][0]));

	          this.markerForLegend = marker;
	        }

	        return this.markerForLegend;
	      }
	    }, {
	      key: 'eraseMarkers',
	      value: function eraseMarkers() {

	        var self = this;

	        if (this.options.markersIndependant) {

	          for (var i in this.independantMarkers) {
	            self.groupMarkers.removeChild(this.independantMarkers[i]);
	          }

	          this.independantMarkers = {};
	        } else if (this.currentMarkersSelectionType) {

	          this.markersDom.forEach(function (el) {

	            if (!el.dom) {
	              return;
	            }

	            if (el.dom.parentNode !== self.groupMarkers) {
	              return;
	            }

	            self.groupMarkers.removeChild(el.dom);
	            el.path = '';
	          });

	          this.currentMarkersSelectionType = false;
	        }
	      }
	    }, {
	      key: 'isMonotoneous',
	      value: function isMonotoneous() {
	        if (this.waveform) {
	          return this.waveform.isMonotoneous();
	        }

	        return !!this.xmonotoneous;
	      }
	    }, {
	      key: 'findLocalMinMax',
	      value: function findLocalMinMax(xRef, xWithin, type) {

	        if (!this.waveform) {
	          return false;
	        }

	        return this.waveform.findLocalMinMax(xRef, xWithin, type);
	      }
	    }]);

	    return SerieLine;
	  }(_graphSerie2.default);

	  function drawMarkerXY(graph, family, x, y, markerDom) {

	    if (!family) {
	      return;
	    }

	    if (graph.options.markersIndependant) {
	      var dom = graph.getMarkerDomIndependent(graph.counter2, family);
	      var p = 'M ' + x + ' ' + y + ' ';
	      p += family.markerPath + ' ';

	      dom.setAttribute('d', p);
	    }

	    markerDom.path = markerDom.path || '';
	    markerDom.path += 'M ' + x + ' ' + y + ' ';
	    markerDom.path += family.markerPath + ' ';
	  }

	  util.mix(SerieLine, _graphMixinErrorbars2.default);

	  exports.default = SerieLine;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 52 */
	/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(20);
	// eslint-disable-next-line no-prototype-builtins
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};


	/***/ }),
	/* 53 */
	/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;


	/***/ }),
	/* 54 */
	/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(20);
	var TAG = __webpack_require__(6)('toStringTag');
	// ES3 wrong here
	var ARG = cof(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};

	module.exports = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};


	/***/ }),
	/* 55 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _parsePx(px) {
	    if (px && px.indexOf && px.indexOf('px') > -1) {
	      return parseInt(px.replace('px', ''));
	    }
	    return false;
	  }

	  function isNumeric(n) {
	    return !isNaN(parseFloat(n)) && isFinite(n);
	  }

	  /**
	   * Utility class to compute positioning
	   * @class
	   */

	  var Position = function () {
	    function Position(x, y, dx, dy) {
	      _classCallCheck(this, Position);

	      if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) == 'object') {
	        this.x = x.x;
	        this.y = x.y;
	        this.dx = x.dx;
	        this.dy = x.dy;
	      } else {
	        this.x = x;
	        this.y = y;
	        this.dx = dx;
	        this.dy = dy;
	      }
	    }

	    _createClass(Position, [{
	      key: 'duplicate',
	      value: function duplicate() {
	        return new Position(this.x, this.y, this.dx, this.dy);
	      }
	    }, {
	      key: 'compute',
	      value: function compute(graph, xAxis, yAxis, serie) {

	        if (!graph || !xAxis || !yAxis || !graph.hasXAxis || !graph.hasYAxis) {
	          graph.throw();
	        }

	        if (!graph.hasXAxis(xAxis)) {
	          throw 'Graph does not contain the x axis that was used as a parameter';
	        }

	        if (!graph.hasYAxis(yAxis)) {
	          throw 'Graph does not contain the x axis that was used as a parameter';
	        }

	        return this._compute(graph, xAxis, yAxis, serie);
	      }
	    }, {
	      key: '_compute',
	      value: function _compute(graph, xAxis, yAxis, serie) {

	        var relativeTo = this._relativeTo;
	        if (relativeTo) {
	          var relativeToComputed = relativeTo._compute(graph, xAxis, yAxis, serie);
	        }

	        var parsed,
	            pos = {
	          x: false,
	          y: false
	        };

	        if (!xAxis) {
	          xAxis = graph.getXAxis();
	        }

	        if (!yAxis) {
	          yAxis = graph.getYAxis();
	        }

	        for (var i in pos) {

	          var axis = i == 'x' ? xAxis : yAxis;
	          var val = this[i];
	          var dval = this['d' + i];

	          if (val === undefined && (dval !== undefined && relativeTo === undefined || relativeTo === undefined)) {

	            if (i == 'x') {

	              if (dval === undefined) {
	                continue;
	              }

	              pos[i] = relativeTo ? relativeTo[i] : 0;
	            } else if (this.x !== undefined && serie) {

	              if (_parsePx(this.x) !== false) {
	                console.warn('You have defined x in px and not y. Makes no sense. Returning 0 for y');
	                pos[i] = 0;
	              } else {

	                var closest = serie.searchClosestValue(this.x);

	                if (!closest) {
	                  console.warn('Could not find y position for x = ' + this.x + ' on serie "' + serie.getName() + '". Returning 0 for y.');
	                  pos[i] = 0;
	                } else {
	                  pos[i] = serie.getY(closest.yMin);
	                }
	              }
	            }
	          } else if (val !== undefined) {

	            pos[i] = this.getPx(val, axis);
	          }

	          if (dval !== undefined) {

	            var def = val !== undefined || relativeToComputed == undefined || relativeToComputed[i] == undefined ? pos[i] : relativeToComputed[i];

	            if (i == 'y' && relativeToComputed && relativeToComputed.x !== undefined && relativeToComputed.y == undefined) {

	              if (!serie) {
	                throw 'Error. No serie exists. Cannot find y value';
	                return;
	              }

	              var closest = serie.searchClosestValue(relativeTo.x);
	              if (closest) {
	                def = serie.getY(closest.yMin);
	              }

	              //console.log( relativeTo.x, closest, serie.getY( closest.yMin ), def );
	            }

	            if (!def) {
	              def = 0;
	            }

	            if ((parsed = _parsePx(dval)) !== false) {
	              // dx in px => val + 10px

	              pos[i] = def + parsed; // return integer (will be interpreted as px)
	            } else if ((parsed = this._parsePercent(dval)) !== false) {

	              pos[i] = def + this._getPositionPx(parsed, true, axis, graph); // returns xx%
	            } else if (axis) {

	              pos[i] = def + axis.getRelPx(dval); // px + unittopx
	            }
	          }
	        }

	        return pos;
	      }
	    }, {
	      key: '_getPositionPx',
	      value: function _getPositionPx(value, x, axis, graph) {

	        var parsed;

	        if ((parsed = _parsePx(value)) !== false) {
	          return parsed; // return integer (will be interpreted as px)
	        }

	        if ((parsed = this._parsePercent(value)) !== false) {
	          return parsed / 100 * (x ? graph.getDrawingWidth() : graph.getDrawingHeight());
	        } else if (axis) {
	          return axis.getPos(value);
	        }
	      }
	    }, {
	      key: '_parsePercent',
	      value: function _parsePercent(percent) {
	        if (percent && percent.indexOf && percent.indexOf('%') > -1) {
	          return percent;
	        }
	        return false;
	      }
	    }, {
	      key: 'getDeltaPx',
	      value: function getDeltaPx(value, axis) {
	        var v;
	        if ((v = _parsePx(value)) !== false) {
	          return v + 'px';
	        } else {

	          return axis.getRelPx(value) + 'px';
	        }
	      }
	    }, {
	      key: 'deltaPosition',
	      value: function deltaPosition(mode, delta, axis) {

	        mode = mode == 'y' ? 'y' : 'x';
	        var ref = this[mode],
	            refd = this['d' + mode],
	            refPx,
	            deltaPx;

	        if (ref !== undefined) {
	          if ((refPx = _parsePx(ref)) !== false) {

	            if ((deltaPx = _parsePx(delta)) !== false) {
	              this[mode] = refPx + deltaPx + 'px';
	            } else {
	              this[mode] = refPx + axis.getRelPx(delta) + 'px';
	            }
	          } else {

	            ref = this.getValPosition(ref, axis);

	            if ((deltaPx = _parsePx(delta)) !== false) {
	              this[mode] = ref + axis.getRelVal(deltaPx);
	            } else {
	              this[mode] = ref + delta;
	            }
	          }
	        } else if (refd !== undefined) {

	          if (mode == 'y' && ref === undefined && !this._relativeTo) {
	            // This means that the shape is placed by the x value. Therefore, the dy is only a stand-off.
	            // Therefore, we do nothing
	            return;
	          }

	          if ((refPx = _parsePx(refd)) !== false) {

	            if ((deltaPx = _parsePx(delta)) !== false) {
	              this['d' + mode] = refPx + deltaPx + 'px';
	            } else {
	              this['d' + mode] = refPx + axis.getRelPx(delta) + 'px';
	            }
	          } else {

	            refd = this.getValPosition(refd, axis);

	            if ((deltaPx = _parsePx(delta)) !== false) {
	              this['d' + mode] = refd + axis.getRelVal(deltaPx);
	            } else {
	              this['d' + mode] = refd + delta;
	            }
	          }
	        }
	      }
	    }, {
	      key: 'getValPosition',
	      value: function getValPosition(rel, axis) {

	        if (rel == 'max') {
	          return axis.getMaxValue();
	        }

	        if (rel == 'min') {
	          return axis.getMinValue();
	        }

	        return rel;
	      }
	    }, {
	      key: 'getPx',
	      value: function getPx(value, axis, rel) {

	        var parsed;

	        if (typeof value == 'function') {

	          return value(axis, rel);
	        } else if ((parsed = _parsePx(value)) !== false) {

	          return parsed; // return integer (will be interpreted as px)
	        } else if ((parsed = this._parsePercent(value)) !== false) {

	          return parsed; // returns xx%
	        } else if (axis) {

	          if (value == 'min') {

	            return axis.getMinPx();
	          } else if (value == 'max') {

	            return axis.getMaxPx();
	          } else if (rel) {

	            return axis.getRelPx(value);
	          } else if (isNumeric(value)) {

	            return axis.getPos(value);
	          }
	        }
	      }
	    }, {
	      key: 'getPxRel',
	      value: function getPxRel(value, axis) {
	        return this.getPx(value, axis, true);
	      }
	    }, {
	      key: 'relativeTo',
	      value: function relativeTo(pos) {
	        this._relativeTo = Position.check(pos);
	        return this;
	      }
	    }], [{
	      key: 'check',
	      value: function check(pos, callback) {
	        if (pos instanceof Position) {
	          return pos;
	        }

	        var posObject = new Position(pos);

	        if (pos && pos.relativeTo) {
	          var position = callback(pos.relativeTo);
	          if (position) {
	            posObject.relativeTo(position);
	          }
	        }

	        return posObject;
	      }
	    }]);

	    return Position;
	  }();

	  exports.default = Position;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 56 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports) {

	  /**
	   * Class for managing events.
	   * Can be extended to provide event functionality in other classes.
	   *
	   * @class EventEmitter Manages event registering and emitting.
	   */

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  function EventEmitter() {}

	  // Shortcuts to improve speed and size
	  var proto = EventEmitter.prototype;

	  /**
	   * Finds the index of the listener for the event in its storage array.
	   *
	   * @param {Function[]} listeners Array of listeners to search through.
	   * @param {Function} listener Method to look for.
	   * @return {Number} Index of the specified listener, -1 if not found
	   * @api private
	   */
	  function indexOfListener(listeners, listener) {
	    var i = listeners.length;
	    while (i--) {
	      if (listeners[i].listener === listener) {
	        return i;
	      }
	    }

	    return -1;
	  }

	  /**
	   * Alias a method while keeping the context correct, to allow for overwriting of target method.
	   *
	   * @param {String} name The name of the target method.
	   * @return {Function} The aliased method
	   * @api private
	   */
	  function alias(name) {
	    return function aliasClosure() {
	      return this[name].apply(this, arguments);
	    };
	  }

	  /**
	   * Returns the listener array for the specified event.
	   * Will initialise the event object and listener arrays if required.
	   * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	   * Each property in the object response is an array of listener functions.
	   *
	   * @param {String|RegExp} evt Name of the event to return the listeners from.
	   * @return {Function[]|Object} All listener functions for the event.
	   */
	  proto.getListeners = function getListeners(evt) {
	    var events = this._getEvents();
	    var response;
	    var key;

	    // Return a concatenated array of all matching events if
	    // the selector is a regular expression.
	    if (evt instanceof RegExp) {
	      response = {};
	      for (key in events) {
	        if (events.hasOwnProperty(key) && evt.test(key)) {
	          response[key] = events[key];
	        }
	      }
	    } else {
	      response = events[evt] || (events[evt] = []);
	    }

	    return response;
	  };

	  /**
	   * Takes a list of listener objects and flattens it into a list of listener functions.
	   *
	   * @param {Object[]} listeners Raw listener objects.
	   * @return {Function[]} Just the listener functions.
	   */
	  proto.flattenListeners = function flattenListeners(listeners) {
	    var flatListeners = [];
	    var i;

	    for (i = 0; i < listeners.length; i += 1) {
	      flatListeners.push(listeners[i].listener);
	    }

	    return flatListeners;
	  };

	  /**
	   * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	   *
	   * @param {String|RegExp} evt Name of the event to return the listeners from.
	   * @return {Object} All listener functions for an event in an object.
	   */
	  proto.getListenersAsObject = function getListenersAsObject(evt) {
	    var listeners = this.getListeners(evt);
	    var response;

	    if (listeners instanceof Array) {
	      response = {};
	      response[evt] = listeners;
	    }

	    return response || listeners;
	  };

	  /**
	   * Adds a listener function to the specified event.
	   * The listener will not be added if it is a duplicate.
	   * If the listener returns true then it will be removed after it is called.
	   * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	   *
	   * @param {String|RegExp} evt Name of the event to attach the listener to.
	   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.addListener = function addListener(evt, listener) {
	    var listeners = this.getListenersAsObject(evt);
	    var listenerIsWrapped = (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === 'object';
	    var key;

	    for (key in listeners) {
	      if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
	        listeners[key].push(listenerIsWrapped ? listener : {
	          listener: listener,
	          once: false
	        });
	      }
	    }

	    return this;
	  };

	  /**
	   * Alias of addListener
	   */
	  proto.on = alias('addListener');

	  /**
	   * Semi-alias of addListener. It will add a listener that will be
	   * automatically removed after its first execution.
	   *
	   * @param {String|RegExp} evt Name of the event to attach the listener to.
	   * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.addOnceListener = function addOnceListener(evt, listener) {
	    return this.addListener(evt, {
	      listener: listener,
	      once: true
	    });
	  };

	  /**
	   * Alias of addOnceListener.
	   */
	  proto.once = alias('addOnceListener');

	  /**
	   * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	   * You need to tell it what event names should be matched by a regex.
	   *
	   * @param {String} evt Name of the event to create.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.defineEvent = function defineEvent(evt) {
	    this.getListeners(evt);
	    return this;
	  };

	  /**
	   * Uses defineEvent to define multiple events.
	   *
	   * @param {String[]} evts An array of event names to define.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.defineEvents = function defineEvents(evts) {
	    for (var i = 0; i < evts.length; i += 1) {
	      this.defineEvent(evts[i]);
	    }
	    return this;
	  };

	  /**
	   * Removes a listener function from the specified event.
	   * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	   *
	   * @param {String|RegExp} evt Name of the event to remove the listener from.
	   * @param {Function} listener Method to remove from the event.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.removeListener = function removeListener(evt, listener) {
	    var listeners = this.getListenersAsObject(evt);
	    var index;
	    var key;

	    for (key in listeners) {
	      if (listeners.hasOwnProperty(key)) {
	        index = indexOfListener(listeners[key], listener);

	        if (index !== -1) {
	          listeners[key].splice(index, 1);
	        }
	      }
	    }

	    return this;
	  };

	  /**
	   * Alias of removeListener
	   */
	  proto.off = alias('removeListener');

	  /**
	   * Adds listeners in bulk using the manipulateListeners method.
	   * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	   * You can also pass it a regular expression to add the array of listeners to all events that match it.
	   * Yeah, this function does quite a bit. That's probably a bad thing.
	   *
	   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	   * @param {Function[]} [listeners] An optional array of listener functions to add.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.addListeners = function addListeners(evt, listeners) {
	    // Pass through to manipulateListeners
	    return this.manipulateListeners(false, evt, listeners);
	  };

	  /**
	   * Removes listeners in bulk using the manipulateListeners method.
	   * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	   * You can also pass it an event name and an array of listeners to be removed.
	   * You can also pass it a regular expression to remove the listeners from all events that match it.
	   *
	   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	   * @param {Function[]} [listeners] An optional array of listener functions to remove.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.removeListeners = function removeListeners(evt, listeners) {
	    // Pass through to manipulateListeners
	    return this.manipulateListeners(true, evt, listeners);
	  };

	  /**
	   * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	   * The first argument will determine if the listeners are removed (true) or added (false).
	   * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	   * You can also pass it an event name and an array of listeners to be added/removed.
	   * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	   *
	   * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	   * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	   * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
	    var i;
	    var value;
	    var single = remove ? this.removeListener : this.addListener;
	    var multiple = remove ? this.removeListeners : this.addListeners;

	    // If evt is an object then pass each of its properties to this method
	    if ((typeof evt === 'undefined' ? 'undefined' : _typeof(evt)) === 'object' && !(evt instanceof RegExp)) {
	      for (i in evt) {
	        if (evt.hasOwnProperty(i) && (value = evt[i])) {
	          // Pass the single listener straight through to the singular method
	          if (typeof value === 'function') {
	            single.call(this, i, value);
	          } else {
	            // Otherwise pass back to the multiple function
	            multiple.call(this, i, value);
	          }
	        }
	      }
	    } else {
	      // So evt must be a string
	      // And listeners must be an array of listeners
	      // Loop over it and pass each one to the multiple method
	      i = listeners.length;
	      while (i--) {
	        single.call(this, evt, listeners[i]);
	      }
	    }

	    return this;
	  };

	  /**
	   * Removes all listeners from a specified event.
	   * If you do not specify an event then all listeners will be removed.
	   * That means every event will be emptied.
	   * You can also pass a regex to remove all events that match it.
	   *
	   * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.removeEvent = function removeEvent(evt) {
	    var type = typeof evt === 'undefined' ? 'undefined' : _typeof(evt);
	    var events = this._getEvents();
	    var key;

	    // Remove different things depending on the state of evt
	    if (type === 'string') {
	      // Remove all listeners for the specified event
	      delete events[evt];
	    } else if (evt instanceof RegExp) {
	      // Remove all events matching the regex.
	      for (key in events) {
	        if (events.hasOwnProperty(key) && evt.test(key)) {
	          delete events[key];
	        }
	      }
	    } else {
	      // Remove all listeners in all events
	      delete this._events;
	    }

	    return this;
	  };

	  /**
	   * Alias of removeEvent.
	   *
	   * Added to mirror the node API.
	   */
	  proto.removeAllListeners = alias('removeEvent');

	  /**
	   * Emits an event of your choice.
	   * When emitted, every listener attached to that event will be executed.
	   * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	   * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	   * So they will not arrive within the array on the other side, they will be separate.
	   * You can also pass a regular expression to emit to all events that match it.
	   *
	   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	   * @param {Array} [args] Optional array of arguments to be passed to each listener.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.emitEvent = function emitEvent(evt, args) {
	    var listeners = this.getListenersAsObject(evt);
	    var listener;
	    var i;
	    var key;
	    var response;

	    for (key in listeners) {
	      if (listeners.hasOwnProperty(key)) {
	        i = listeners[key].length;

	        while (i--) {
	          // If the listener returns true then it shall be removed from the event
	          // The function is executed either with a basic call or an apply if there is an args array
	          listener = listeners[key][i];

	          if (listener.once === true) {
	            this.removeListener(evt, listener.listener);
	          }

	          response = listener.listener.apply(this, args || []);

	          if (response === this._getOnceReturnValue()) {
	            this.removeListener(evt, listener.listener);
	          }
	        }
	      }
	    }

	    return this;
	  };

	  /**
	   * Alias of emitEvent
	   */
	  proto.trigger = alias('emitEvent');

	  /**
	   * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	   * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	   *
	   * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	   * @param {...*} Optional additional arguments to be passed to each listener.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.emit = function emit(evt) {
	    var args = Array.prototype.slice.call(arguments, 1);
	    return this.emitEvent(evt, args);
	  };

	  /**
	   * Sets the current value to check against when executing listeners. If a
	   * listeners return value matches the one set here then it will be removed
	   * after execution. This value defaults to true.
	   *
	   * @param {*} value The new value to check for when executing listeners.
	   * @return {Object} Current instance of EventEmitter for chaining.
	   */
	  proto.setOnceReturnValue = function setOnceReturnValue(value) {
	    this._onceReturnValue = value;
	    return this;
	  };

	  /**
	   * Fetches the current value to check against when executing listeners. If
	   * the listeners return value matches this one then it should be removed
	   * automatically. It will return true by default.
	   *
	   * @return {*|Boolean} The current value to check for or the default, true.
	   * @api private
	   */
	  proto._getOnceReturnValue = function _getOnceReturnValue() {
	    if (this.hasOwnProperty('_onceReturnValue')) {
	      return this._onceReturnValue;
	    } else {
	      return true;
	    }
	  };

	  /**
	   * Fetches the events object and creates one if required.
	   *
	   * @return {Object} The events storage object.
	   * @api private
	   */
	  proto._getEvents = function _getEvents() {
	    return this._events || (this._events = {});
	  };

	  exports.default = EventEmitter;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 57 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(56), __webpack_require__(5), __webpack_require__(46)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _EventEmitter2, _graphUtil, _waveform) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

	  var util = _interopRequireWildcard(_graphUtil);

	  var _waveform2 = _interopRequireDefault(_waveform);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var Serie = function (_EventEmitter) {
	    _inherits(Serie, _EventEmitter);

	    _createClass(Serie, null, [{
	      key: 'default',
	      value: function _default() {

	        return {
	          redrawShapesAfterDraw: false
	        };
	      }
	    }]);

	    function Serie(graph, name, options) {
	      _classCallCheck(this, Serie);

	      var _this = _possibleConstructorReturn(this, (Serie.__proto__ || Object.getPrototypeOf(Serie)).apply(this, arguments));

	      _this.graph = graph;
	      _this.name = name;
	      _this.options = Object.assign({}, Serie.default(), _this.constructor.default(), options);

	      //if( new.target.default ) {
	      //console.log( new.target.default() );
	      //}

	      return _this;
	    }

	    _createClass(Serie, [{
	      key: 'draw',
	      value: function draw() {}
	    }, {
	      key: 'beforeDraw',
	      value: function beforeDraw() {}
	    }, {
	      key: 'afterDraw',
	      value: function afterDraw() {

	        if (this.options.redrawShapesAfterDraw) {
	          this.graph.getShapesOfSerie(this).forEach(function (shape) {
	            shape.redraw();
	          });
	        }

	        this.emit('draw');
	      }
	    }, {
	      key: 'setData',
	      value: function setData(data, oneDimensional, type) {

	        if (data instanceof _waveform2.default) {
	          return this.setWaveform(data);
	        }

	        throw 'Setting data other than waveforms in not supported by default. You must implemented this method in the inherited class.';
	      }
	    }, {
	      key: '_addData',
	      value: function _addData(type, howmany) {
	        return [];
	      }
	    }, {
	      key: 'clearData',
	      value: function clearData() {
	        this.setData(new _waveform2.default());
	        return this;
	      }
	    }, {
	      key: 'getData',
	      value: function getData() {
	        return this.data;
	      }
	    }, {
	      key: 'setOptions',
	      value: function setOptions(options) {
	        this.options = options || {};
	      }
	    }, {
	      key: 'setOption',
	      value: function setOption(name, value) {
	        this.options[name] = value;
	      }
	    }, {
	      key: 'kill',
	      value: function kill(noLegendUpdate) {

	        this.graph.removeSerieFromDom(this);
	        this.graph._removeSerie(this);

	        if (this.graph.legend && !noLegendUpdate) {

	          this.graph.legend.update();
	        }

	        this.graph = undefined;
	        return this;
	      }
	    }, {
	      key: 'hide',
	      value: function hide(hideShapes) {
	        var mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


	        this.hidden = true;
	        this.groupMain.setAttribute('display', 'none');

	        this.getSymbolForLegend().setAttribute('opacity', 0.5);
	        this.getTextForLegend().setAttribute('opacity', 0.5);

	        this.hideImpl();

	        if (hideShapes) {
	          var shapes = this.graph.getShapesOfSerie(this);
	          for (var i = 0, l = shapes.length; i < l; i++) {
	            shapes[i].hide();
	          }
	        }

	        if (!mute) {
	          this.emit('hide');
	        }

	        if (this.getXAxis().doesHideWhenNoSeriesShown() || this.getYAxis().doesHideWhenNoSeriesShown()) {
	          this.graph.draw(true);
	        }

	        return this;
	      }
	    }, {
	      key: 'show',
	      value: function show(showShapes) {
	        var mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


	        this.hidden = false;
	        this.groupMain.setAttribute('display', 'block');

	        this.getSymbolForLegend().setAttribute('opacity', 1);
	        this.getTextForLegend().setAttribute('opacity', 1);

	        this.showImpl();

	        this.draw(true);

	        if (showShapes) {
	          var shapes = this.graph.getShapesOfSerie(this);
	          for (var i = 0, l = shapes.length; i < l; i++) {
	            shapes[i].show();
	          }
	        }

	        if (!mute) {
	          this.emit('show');
	        }

	        if (this.getXAxis().doesHideWhenNoSeriesShown() || this.getYAxis().doesHideWhenNoSeriesShown()) {
	          this.graph.draw(true);
	        }
	        return this;
	      }
	    }, {
	      key: 'hideImpl',
	      value: function hideImpl() {}
	    }, {
	      key: 'showImpl',
	      value: function showImpl() {}
	    }, {
	      key: 'toggleDisplay',
	      value: function toggleDisplay() {

	        if (!this.isShown()) {
	          this.show();
	        } else {
	          this.hide();
	        }

	        return this;
	      }
	    }, {
	      key: 'isShown',
	      value: function isShown() {
	        return !this.hidden;
	      }
	    }, {
	      key: 'axisCheck',
	      value: function axisCheck() {

	        if (!this.getXAxis() || !this.getYAxis()) {
	          throw 'No axis exist for this serie. Check that they were properly assigned';
	        }

	        if (isNaN(this.getXAxis().getCurrentMin()) || isNaN(this.getXAxis().getCurrentMax()) || isNaN(this.getYAxis().getCurrentMin()) || isNaN(this.getYAxis().getCurrentMax())) {
	          throw 'Axis min and max values are not defined. Try autoscaling';
	        }
	      }
	    }, {
	      key: 'getX',
	      value: function getX(val) {
	        return (val = this.getXAxis().getPx(val)) - val % 0.2;
	      }
	    }, {
	      key: 'getY',
	      value: function getY(val) {
	        return (val = this.getYAxis().getPx(val)) - val % 0.2;
	      }
	    }, {
	      key: 'isSelected',
	      value: function isSelected() {
	        return this.selected || this.selectionType !== 'unselected';
	      }
	    }, {
	      key: '_checkX',
	      value: function _checkX(val) {
	        this.minX = Math.min(this.minX, val);
	        this.maxX = Math.max(this.maxX, val);
	      }
	    }, {
	      key: '_checkY',
	      value: function _checkY(val) {
	        this.minY = Math.min(this.minY, val);
	        this.maxY = Math.max(this.maxY, val);
	      }
	    }, {
	      key: 'getName',
	      value: function getName() {
	        return this.name;
	      }
	    }, {
	      key: 'autoAxis',
	      value: function autoAxis() {

	        if (this.isFlipped()) {

	          this.setXAxis(this.graph.getYAxis());
	          this.setYAxis(this.graph.getXAxis());
	        } else {

	          this.setXAxis(this.graph.getXAxis());
	          this.setYAxis(this.graph.getYAxis());
	        }

	        // After axes have been assigned, the graph axes should update their min/max
	        this.graph.updateDataMinMaxAxes();
	        return this;
	      }
	    }, {
	      key: 'autoAxes',
	      value: function autoAxes() {
	        return this.autoAxis.apply(this, arguments);
	      }
	    }, {
	      key: 'setXAxis',
	      value: function setXAxis(axis) {

	        if (typeof axis == 'number') {
	          this.xaxis = this.isFlipped() ? this.graph.getYAxis(axis) : this.graph.getXAxis(axis);
	        } else {
	          this.xaxis = axis;
	        }

	        this.graph.updateDataMinMaxAxes();

	        return this;
	      }
	    }, {
	      key: 'setYAxis',
	      value: function setYAxis(axis) {
	        if (typeof axis == 'number') {
	          this.xaxis = this.isFlipped() ? this.graph.getXAxis(axis) : this.graph.getYAxis(axis);
	        } else {
	          this.yaxis = axis;
	        }

	        this.graph.updateDataMinMaxAxes();

	        return this;
	      }
	    }, {
	      key: 'setAxes',
	      value: function setAxes() {

	        for (var i = 0; i < 2; i++) {

	          if (arguments[i]) {
	            this[arguments[i].isX() ? 'setXAxis' : 'setYAxis'](arguments[i]);
	          }
	        }

	        this.graph.updateDataMinMaxAxes();

	        return this;
	      }
	    }, {
	      key: 'getXAxis',
	      value: function getXAxis() {
	        return this.xaxis;
	      }
	    }, {
	      key: 'getYAxis',
	      value: function getYAxis() {
	        return this.yaxis;
	      }
	    }, {
	      key: 'getMinX',
	      value: function getMinX() {
	        return this.minX;
	      }
	    }, {
	      key: 'getMaxX',
	      value: function getMaxX() {
	        return this.maxX;
	      }
	    }, {
	      key: 'getMinY',
	      value: function getMinY() {
	        return this.minY;
	      }
	    }, {
	      key: 'getMaxY',
	      value: function getMaxY() {
	        return this.maxY;
	      }
	    }, {
	      key: 'getWaveform',
	      value: function getWaveform() {
	        return this.waveform;
	      }
	    }, {
	      key: 'getWaveforms',
	      value: function getWaveforms() {
	        return [this.waveform];
	      }
	    }, {
	      key: 'setWaveform',
	      value: function setWaveform(waveform) {

	        if (!(waveform instanceof _waveform2.default)) {
	          console.trace();
	          console.error(waveform);
	          throw new Error('Cannot assign waveform to serie. Waveform is not of the proper Waveform instance');
	        }

	        this.waveform = waveform;

	        this.minX = this.waveform.getXMin();
	        this.maxX = this.waveform.getXMax();
	        this.minY = this.waveform.getMin();
	        this.maxY = this.waveform.getMax();

	        this.graph.updateDataMinMaxAxes();
	        this.dataHasChanged();

	        return this;
	      }
	    }, {
	      key: 'getSymbolForLegend',
	      value: function getSymbolForLegend() {

	        if (!this.lineForLegend) {

	          var line = document.createElementNS(this.graph.ns, 'line');
	          this.applyLineStyle(line);

	          line.setAttribute('x1', 5);
	          line.setAttribute('x2', 25);
	          line.setAttribute('y1', 0);
	          line.setAttribute('y2', 0);

	          line.setAttribute('cursor', 'pointer');

	          this.lineForLegend = line;
	        }

	        return this.lineForLegend;
	      }
	    }, {
	      key: 'setLegendSymbolStyle',
	      value: function setLegendSymbolStyle() {
	        this.applyLineStyle(this.getSymbolForLegend());
	      }
	    }, {
	      key: 'updateStyle',
	      value: function updateStyle() {
	        this.setLegendSymbolStyle();
	        this.graph.updateLegend();
	      }
	    }, {
	      key: 'getTextForLegend',
	      value: function getTextForLegend() {

	        if (!this.textForLegend) {

	          var text = document.createElementNS(this.graph.ns, 'text');
	          text.setAttribute('cursor', 'pointer');
	          text.textContent = this.getLabel();

	          this.textForLegend = text;
	        }

	        return this.textForLegend;
	      }
	    }, {
	      key: 'getIndex',
	      value: function getIndex() {
	        return this.graph.series.indexOf(this);
	      }
	    }, {
	      key: 'getLabel',
	      value: function getLabel() {
	        return this.options.label || this.name;
	      }
	    }, {
	      key: 'setLabel',
	      value: function setLabel(label) {
	        this.options.label = label;

	        if (this.textForLegend) {
	          this.textForLegend.textContent = label;
	        }

	        this.graph.requireLegendUpdate();
	        return this;
	      }
	    }, {
	      key: 'setFlip',
	      value: function setFlip(flipped) {
	        this.options.flip = flipped;
	        return this;
	      }
	    }, {
	      key: 'getFlip',
	      value: function getFlip() {
	        return this.options.flip;
	      }
	    }, {
	      key: 'isFlipped',
	      value: function isFlipped() {
	        return this.options.flip;
	      }
	    }, {
	      key: 'setLayer',
	      value: function setLayer(layerIndex) {
	        var newLayer = parseInt(layerIndex) || 1;

	        if (newLayer !== this.options.layer) {
	          this.options.layer = newLayer;
	          this.graph.appendSerieToDom(this);
	        }

	        return this;
	      }
	    }, {
	      key: 'getLayer',
	      value: function getLayer() {
	        return this.options.layer || 1;
	      }
	    }, {
	      key: 'setStyle',
	      value: function setStyle(style) {
	        var selectionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unselected';

	        this.styles[selectionType] = style;
	        this.styleHasChanged(selectionType);
	      }
	    }, {
	      key: 'styleHasChanged',
	      value: function styleHasChanged() {
	        var selectionType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unselected';

	        this._changedStyles = this._changedStyles || {};

	        if (selectionType === false) {
	          for (var i in this._changedStyles) {
	            this._changedStyles[i] = false;
	          }
	        } else {
	          this._changedStyles[selectionType || 'unselected'] = true;
	        }

	        this.graph.requireLegendUpdate();
	        return this;
	      }
	    }, {
	      key: 'hasStyleChanged',
	      value: function hasStyleChanged(selectionType) {
	        this._changedStyles = this._changedStyles || {};
	        return this._changedStyles[selectionType || 'unselected'];
	      }
	    }, {
	      key: 'dataHasChanged',
	      value: function dataHasChanged(arg) {
	        this._dataHasChanged = arg === undefined || arg;
	        return this;
	      }
	    }, {
	      key: 'hasDataChanged',
	      value: function hasDataChanged() {
	        return this._dataHasChanged;
	      }
	    }, {
	      key: 'setInfo',
	      value: function setInfo(prop, value) {
	        this.infos = this.infos || {};
	        this.infos[prop] = value;
	        return this;
	      }
	    }, {
	      key: 'getInfo',
	      value: function getInfo(prop, value) {
	        return (this.infos || {})[prop];
	      }
	    }, {
	      key: 'setAdditionalData',
	      value: function setAdditionalData(data) {
	        this.additionalData = data;
	        return this;
	      }
	    }, {
	      key: 'getAdditionalData',
	      value: function getAdditionalData() {
	        return this.additionalData;
	      }
	    }, {
	      key: 'select',
	      value: function select() {
	        this.selected = true;
	        return this;
	      }
	    }, {
	      key: 'unselect',
	      value: function unselect() {
	        this.selected = false;
	        return this;
	      }
	    }, {
	      key: 'enableTracking',
	      value: function enableTracking(hoverCallback, outCallback) {
	        this._tracker = true;
	        this._trackingCallback = hoverCallback;
	        this._trackingOutCallback = outCallback;

	        return this;
	      }
	    }, {
	      key: 'disableTracking',
	      value: function disableTracking() {

	        if (this._trackerDom) {
	          this._trackerDom.remove();
	          this._trackerDom = null;
	        }

	        this._tracker = false;
	        this._trackingCallback = null;
	        return this;
	      }
	    }, {
	      key: 'allowTrackingLine',
	      value: function allowTrackingLine(options) {

	        options = options || {};
	        this.graph.addSerieToTrackingLine(this, options);
	      }
	    }, {
	      key: 'getMarkerForLegend',
	      value: function getMarkerForLegend() {
	        return false;
	      }
	    }, {
	      key: 'getType',
	      value: function getType() {
	        return this._type;
	      }
	    }, {
	      key: 'setDataIndices',
	      value: function setDataIndices(categories, nb) {
	        this.categoryIndices = categories;
	        this.nbCategories = nb;
	      }
	    }, {
	      key: 'hasErrors',
	      value: function hasErrors() {
	        if (!this.waveform) {
	          return false;
	        }

	        return this.waveform.hasErrorBars();
	      }
	    }, {
	      key: 'type',
	      get: function get() {
	        return this._type;
	      }
	    }, {
	      key: 'excludedFromLegend',
	      set: function set(bln) {
	        this._excludedFromLegend = bln;
	      },
	      get: function get() {
	        return !!this._excludedFromLegend;
	      }
	    }]);

	    return Serie;
	  }(_EventEmitter3.default);

	  exports.default = Serie;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 58 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || (global[SHARED] = {});
	module.exports = function (key) {
	  return store[key] || (store[key] = {});
	};


	/***/ }),
	/* 59 */
	/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(16);
	var toLength = __webpack_require__(9);
	var toAbsoluteIndex = __webpack_require__(38);
	module.exports = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};


	/***/ }),
	/* 60 */
	/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;


	/***/ }),
	/* 61 */
	/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(20);
	module.exports = Array.isArray || function isArray(arg) {
	  return cof(arg) == 'Array';
	};


	/***/ }),
	/* 62 */
	/***/ (function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(4);
	var cof = __webpack_require__(20);
	var MATCH = __webpack_require__(6)('match');
	module.exports = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};


	/***/ }),
	/* 63 */
	/***/ (function(module, exports, __webpack_require__) {

	var ITERATOR = __webpack_require__(6)('iterator');
	var SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	} catch (e) { /* empty */ }

	module.exports = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};


	/***/ }),
	/* 64 */
	/***/ (function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(1);
	module.exports = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};


	/***/ }),
	/* 65 */
	/***/ (function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(13);
	var redefine = __webpack_require__(14);
	var fails = __webpack_require__(3);
	var defined = __webpack_require__(24);
	var wks = __webpack_require__(6);

	module.exports = function (KEY, length, exec) {
	  var SYMBOL = wks(KEY);
	  var fns = exec(defined, SYMBOL, ''[KEY]);
	  var strfn = fns[0];
	  var rxfn = fns[1];
	  if (fails(function () {
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  })) {
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return rxfn.call(string, this); }
	    );
	  }
	};


	/***/ }),
	/* 66 */
	/***/ (function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject = __webpack_require__(1);
	var aFunction = __webpack_require__(11);
	var SPECIES = __webpack_require__(6)('species');
	module.exports = function (O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};


	/***/ }),
	/* 67 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var $export = __webpack_require__(0);
	var redefine = __webpack_require__(14);
	var redefineAll = __webpack_require__(44);
	var meta = __webpack_require__(32);
	var forOf = __webpack_require__(43);
	var anInstance = __webpack_require__(42);
	var isObject = __webpack_require__(4);
	var fails = __webpack_require__(3);
	var $iterDetect = __webpack_require__(63);
	var setToStringTag = __webpack_require__(47);
	var inheritIfRequired = __webpack_require__(81);

	module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = global[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function (KEY) {
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function (a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a) {
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }

	  setToStringTag(C, NAME);

	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);

	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

	  return C;
	};


	/***/ }),
	/* 68 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var hide = __webpack_require__(13);
	var uid = __webpack_require__(35);
	var TYPED = uid('typed_array');
	var VIEW = uid('view');
	var ABV = !!(global.ArrayBuffer && global.DataView);
	var CONSTR = ABV;
	var i = 0;
	var l = 9;
	var Typed;

	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');

	while (i < l) {
	  if (Typed = global[TypedArrayConstructors[i++]]) {
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}

	module.exports = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};


	/***/ }),
	/* 69 */
	/***/ (function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(36) || !__webpack_require__(3)(function () {
	  var K = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, K, function () { /* empty */ });
	  delete __webpack_require__(2)[K];
	});


	/***/ }),
	/* 70 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = __webpack_require__(0);

	module.exports = function (COLLECTION) {
	  $export($export.S, COLLECTION, { of: function of() {
	    var length = arguments.length;
	    var A = new Array(length);
	    while (length--) A[length] = arguments[length];
	    return new this(A);
	  } });
	};


	/***/ }),
	/* 71 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = __webpack_require__(0);
	var aFunction = __webpack_require__(11);
	var ctx = __webpack_require__(19);
	var forOf = __webpack_require__(43);

	module.exports = function (COLLECTION) {
	  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
	    var mapFn = arguments[1];
	    var mapping, A, n, cb;
	    aFunction(this);
	    mapping = mapFn !== undefined;
	    if (mapping) aFunction(mapFn);
	    if (source == undefined) return new this();
	    A = [];
	    if (mapping) {
	      n = 0;
	      cb = ctx(mapFn, arguments[2], 2);
	      forOf(source, false, function (nextItem) {
	        A.push(cb(nextItem, n++));
	      });
	    } else {
	      forOf(source, false, A.push, A);
	    }
	    return new this(A);
	  } });
	};


	/***/ }),
	/* 72 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(56), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphCore, _EventEmitter2, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphCore2 = _interopRequireDefault(_graphCore);

	  var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  /**
	   * Default graph parameters
	   * @name AxisOptionsDefault
	   * @object
	   * @static
	   * @memberof Axis
	   * @prop {Boolean} display - Whether to display or not the axis
	   * @prop {Boolean} flipped - Flips the axis (maximum and minimum will be inverted)
	   * @prop {Numner} axisDataSpacing.min - The spacing of the at the bottom of the axis. The value is multiplied by the (max - min) values given by the series (0.1 means 10% of the serie width / height).
	   * @prop {Number} axisDataSpacing.max - The spacing of the at the top of the axis. The value is multiplied by the (max - min) values given by the series (0.1 means 10% of the serie width / height).
	   * @prop {String} unitModification - Used to change the units of the axis in a defined way. Currently, "time" and "time:min.sec" are supported. They will display the value in days, hours, minutes and seconds and the data should be expressed in seconds.
	   * @prop {Boolean} primaryGrid - Whether or not to display the primary grid (on the main ticks)
	   * @prop {Boolean} secondaryGrid - Whether or not to display the secondary grid (on the secondary ticks)
	   * @prop {Number} tickPosition - Sets the position of the ticks with regards to the axis ( 1 = inside, 2 = centered, 3 = outside ).
	   * @prop {Number} nbTicksPrimary - The number of primary ticks to use (approximately)
	   * @prop {Number} nbTicksSecondary - The number of secondary ticks to use (approximately)
	   * @prop {Number} ticklabelratio - Scaling factor on the labels under each primary ticks
	   * @prop {Number} exponentialFactor - Scales the labels under each primary ticks by 10^(exponentialFactor)
	   * @prop {Number} exponentialLabelFactor - Scales the axis label by 10^(exponentialFactor)
	   * @prop {Boolean} logScale - Display the axis in log scale (base 10)
	   * @prop {(Number|Boolean)} forcedMin - Use a number to force the minimum value of the axis (becomes independant of its series)
	   * @prop {(Number|Boolean)} forcedMax - Use a number to force the maximum value of the axis (becomes independant of its series)
	   */
	  var defaults = {
	    lineAt: false,
	    display: true,
	    flipped: false,
	    axisDataSpacing: {
	      min: 0.1,
	      max: 0.1
	    },
	    unitModification: false,
	    primaryGrid: true,
	    secondaryGrid: true,

	    primaryGridColor: '#f0f0f0',
	    secondaryGridColor: '#f0f0f0',

	    primaryGridWidth: 1,
	    secondaryGridWidth: 1,

	    hideWhenNoSeriesShown: false,
	    shiftToZero: false,
	    tickPosition: 1,
	    nbTicksPrimary: 3,
	    nbTicksSecondary: 10,
	    ticklabelratio: 1,
	    exponentialFactor: 0,
	    exponentialLabelFactor: 0,
	    logScale: false,
	    forcedMin: false,
	    forcedMax: false,

	    span: [0, 1],
	    marginMin: 0,
	    marginMax: 0,

	    scientificScale: false,
	    scientificScaleExponent: false,
	    engineeringScale: false,

	    unitInTicks: false,
	    unit: false,
	    unitWrapperBefore: '',
	    unitWrapperAfter: '',

	    splitMarks: false,

	    tickLabelOffset: 0,

	    useKatexForLabel: false
	  };

	  /**
	   * Axis constructor. Usually not instanced directly, but for custom made axes, that's possible
	   * @class Axis
	   * @static
	   * @augments EventEmitter
	   * @example function myAxis() {};
	   * myAxis.prototype = new Graph.getConstructor("axis");
	   * graph.setBottomAxis( new myAxis( { } ) );
	   */

	  var Axis = function (_EventEmitter) {
	    _inherits(Axis, _EventEmitter);

	    function Axis() {
	      _classCallCheck(this, Axis);

	      return _possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this));
	    }

	    _createClass(Axis, [{
	      key: 'init',
	      value: function init(graph, options, overwriteoptions) {
	        var _this2 = this;

	        this.unitModificationTimeTicks = [[1, [1, 2, 5, 10, 20, 30]], [60, [1, 2, 5, 10, 20, 30]], [3600, [1, 2, 6, 12]], [3600 * 24, [1, 2, 3, 4, 5, 10, 20, 40]]];

	        this.graph = graph;
	        this.options = util.extend(true, {}, defaults, overwriteoptions, options);

	        this.group = document.createElementNS(this.graph.ns, 'g');
	        this.hasChanged = true;

	        this.rectEvent = document.createElementNS(this.graph.ns, 'rect');
	        this.rectEvent.setAttribute('pointer-events', 'fill');
	        this.rectEvent.setAttribute('fill', 'transparent');
	        this.group.appendChild(this.rectEvent);

	        this.graph.axisGroup.appendChild(this.group); // Adds to the main axiszone

	        // Lines at a certain value
	        this._lines = [];

	        this.line = document.createElementNS(this.graph.ns, 'line');
	        this.line.setAttribute('stroke', 'black');
	        this.line.setAttribute('shape-rendering', 'crispEdges');
	        this.line.setAttribute('stroke-linecap', 'square');
	        this.groupTicks = document.createElementNS(this.graph.ns, 'g');
	        this.groupTickLabels = document.createElementNS(this.graph.ns, 'g');

	        this.group.appendChild(this.groupTicks);
	        this.group.appendChild(this.groupTickLabels);
	        this.group.appendChild(this.line);

	        this.label = document.createElementNS(this.graph.ns, 'text');

	        this.labelTspan = document.createElementNS(this.graph.ns, 'tspan'); // Contains the main label
	        this.preunit = ''; //document.createElementNS( this.graph.ns, 'tspan' ); // Contains the scaling unit
	        this.unitTspan = document.createElementNS(this.graph.ns, 'tspan'); // Contains the unit
	        this.expTspan = document.createElementNS(this.graph.ns, 'tspan'); // Contains the exponent (x10)
	        this.expTspanExp = document.createElementNS(this.graph.ns, 'tspan'); // Contains the exponent value

	        this.label.appendChild(this.labelTspan);
	        //this.label.appendChild( this.preunitTspan );
	        this.label.appendChild(this.unitTspan);
	        this.label.appendChild(this.expTspan);
	        this.label.appendChild(this.expTspanExp);

	        this.expTspan.setAttribute('dx', 6);
	        this.expTspanExp.setAttribute('dy', -5);
	        this.expTspanExp.setAttribute('font-size', '0.8em');

	        this.label.setAttribute('text-anchor', 'middle');

	        this.setTickPosition(this.options.tickPosition);

	        this.gridLinePath = {
	          primary: '',
	          secondary: ''
	        };

	        this.gridPrimary = document.createElementNS(this.graph.ns, 'path');
	        this.gridSecondary = document.createElementNS(this.graph.ns, 'path');

	        this.graph.groupPrimaryGrids.appendChild(this.gridPrimary);
	        this.graph.groupSecondaryGrids.appendChild(this.gridSecondary);

	        this.setGridLinesStyle();

	        this.group.appendChild(this.label);

	        this.groupSeries = document.createElementNS(this.graph.ns, 'g');
	        this.group.appendChild(this.groupSeries);

	        this.widthHeightTick = 0;

	        this.ticks = {};
	        this.ticksLabels = [];
	        this.tickScaling = {
	          1: 3,
	          2: 2,
	          3: 1,
	          4: 0.5
	        };

	        this.currentTick = {};
	        this.lastCurrentTick = {};

	        this.series = [];
	        this.totalDelta = 0;
	        this.currentAction = false;

	        this.group.addEventListener('mousemove', function (e) {
	          e.preventDefault();
	          var coords = _this2.graph._getXY(e);
	          _this2.handleMouseMoveLocal(coords.x, coords.y, e);

	          for (var i = 0, l = _this2.series.length; i < l; i++) {
	            _this2.series[i].handleMouseMove(false, true);
	          }
	        });

	        this.labels = [];
	        this.group.addEventListener('click', function (e) {
	          e.preventDefault();
	          var coords = _this2.graph._getXY(e);
	          _this2.addLabel(_this2.getVal(coords.x - _this2.graph.getPaddingLeft()));
	        });

	        //this.clip = document.createElementNS( this.graph.ns, 'clipPath' );
	        //this.clip.setAttribute( 'id', '_clip' + this.axisRand );
	        //this.graph.defs.appendChild( this.clip );
	        /*
	            this.clipRect = document.createElementNS( this.graph.ns, 'rect' );
	            this.clip.appendChild( this.clipRect );
	            this.clip.setAttribute( 'clipPathUnits', 'userSpaceOnUse' );
	        */
	        this.gridPrimary.setAttribute('clip-path', 'url(#_clipplot' + this.graph._creation + ')');
	        this.gridSecondary.setAttribute('clip-path', 'url(#_clipplot' + this.graph._creation + ')');
	        this.graph._axisHasChanged(this);
	      }
	    }, {
	      key: 'handleMouseMoveLocal',
	      value: function handleMouseMoveLocal() {}
	    }, {
	      key: 'hide',
	      value: function hide() {
	        this.options.display = false;
	        return this;
	      }
	    }, {
	      key: 'show',
	      value: function show() {
	        this.options.display = true;
	        return this;
	      }
	    }, {
	      key: 'setDisplay',
	      value: function setDisplay(bool) {
	        this.options.display = !!bool;
	        return this;
	      }
	    }, {
	      key: 'isDisplayed',
	      value: function isDisplayed() {

	        if (!this.options.hideWhenNoSeriesShown) {
	          return this.options.display;
	        }

	        return this.graph.getSeriesFromAxis(this).reduce(function (accumulator, serie) {
	          return accumulator || serie.isShown();
	        }, false);
	      }
	    }, {
	      key: 'isShown',
	      value: function isShown() {

	        return this.isDisplayed.apply(this, arguments);
	      }
	    }, {
	      key: 'hideGroup',
	      value: function hideGroup() {
	        if (this._hidden) {
	          return;
	        }
	        this._hidden = true;
	        this.group.setAttribute('display', 'none');
	      }
	    }, {
	      key: 'showGroup',
	      value: function showGroup() {
	        if (!this._hidden) {
	          return;
	        }
	        this._hidden = false;
	        this.group.setAttribute('display', 'initial');
	      }
	    }, {
	      key: 'kill',
	      value: function kill(noRedraw, noSerieKill) {
	        this.graph.killAxis(this, noRedraw, noSerieKill);
	      }
	    }, {
	      key: 'setLineAt',
	      value: function setLineAt(atValues) {
	        this.options.lineAt = atValues;
	        return this;
	      }
	    }, {
	      key: 'adaptTo',
	      value: function adaptTo(axis, thisValue, foreignValue, preference) {

	        if (!axis) {
	          this.options.adaptTo = false;
	          return this;
	        }

	        this.options.adaptTo = {
	          axis: axis,
	          thisValue: thisValue,
	          foreignValue: foreignValue,
	          preference: preference
	        };

	        this.adapt();

	        return this;
	      }
	    }, {
	      key: 'adapt',
	      value: function adapt() {

	        if (!this.options.adaptTo) {
	          return;
	        }

	        var axis = this.options.adaptTo.axis,
	            current = this.options.adaptTo.thisValue,
	            foreign = this.options.adaptTo.foreignValue;

	        if (axis.currentAxisMin === undefined || axis.currentAxisMax === undefined) {
	          axis.setMinMaxToFitSeries();
	        }

	        if (this.options.forcedMin !== false && this.options.forcedMax == false || this.options.adaptTo.preference !== 'max') {

	          if (this.options.forcedMin !== false) {
	            this.currentAxisMin = this.options.forcedMin;
	          } else {
	            this.currentAxisMin = this._zoomed ? this.getCurrentMin() : this.getMinValue() - (current - this.getMinValue()) * (this.options.axisDataSpacing.min * (axis.getCurrentMax() - axis.getCurrentMin()) / (foreign - axis.getCurrentMin()));
	          }

	          if (this.currentAxisMin == current) {
	            this.currentAxisMin -= this.options.axisDataSpacing.min * this.getInterval();
	          }

	          var use = this.options.forcedMin !== false ? this.options.forcedMin : this.currentAxisMin;
	          this.currentAxisMax = (current - use) * (axis.getCurrentMax() - axis.getCurrentMin()) / (foreign - axis.getCurrentMin()) + use;
	        } else {

	          if (this.options.forcedMax !== false) {
	            this.currentAxisMax = this.options.forcedMax;
	          } else {
	            this.currentAxisMax = this._zoomed ? this.getCurrentMax() : this.getMaxValue() + (this.getMaxValue() - current) * (this.options.axisDataSpacing.max * (axis.getCurrentMax() - axis.getCurrentMin()) / (axis.getCurrentMax() - foreign));
	          }

	          if (this.currentAxisMax == current) {
	            this.currentAxisMax += this.options.axisDataSpacing.max * this.getInterval();
	          }

	          var use = this.options.forcedMax !== false ? this.options.forcedMax : this.currentAxisMax;

	          this.currentAxisMin = (current - use) * (axis.getCurrentMin() - axis.getCurrentMax()) / (foreign - axis.getCurrentMax()) + use;
	        }

	        this.graph._axisHasChanged(this);
	      }
	    }, {
	      key: 'setFloating',
	      value: function setFloating(axis, value) {

	        this.floating = true;
	        this.floatingAxis = axis;
	        this.floatingValue = value;

	        return this;
	      }
	    }, {
	      key: 'getFloatingAxis',
	      value: function getFloatingAxis() {
	        return this.floatingAxis;
	      }
	    }, {
	      key: 'getFloatingValue',
	      value: function getFloatingValue() {
	        return this.floatingValue;
	      }
	    }, {
	      key: 'setAxisDataSpacing',
	      value: function setAxisDataSpacing(val1, val2) {
	        this.options.axisDataSpacing.min = val1;
	        this.options.axisDataSpacing.max = val2 || val1;
	        return this;
	      }
	    }, {
	      key: 'dataSpacing',
	      value: function dataSpacing() {
	        return this.setAxisDataSpacing.apply(this, arguments);
	      }
	    }, {
	      key: 'setAxisDataSpacingMin',
	      value: function setAxisDataSpacingMin(val) {
	        this.options.axisDataSpacing.min = val;
	      }
	    }, {
	      key: 'setAxisDataSpacingMax',
	      value: function setAxisDataSpacingMax(val) {
	        this.options.axisDataSpacing.max = val;
	      }
	    }, {
	      key: 'setMinPx',
	      value: function setMinPx(px) {

	        this.minPx = px;
	        this.setMinMaxFlipped();
	      }
	    }, {
	      key: 'setMaxPx',
	      value: function setMaxPx(px) {

	        this.maxPx = px;
	        this.setMinMaxFlipped();
	      }
	    }, {
	      key: 'getMinPx',
	      value: function getMinPx() {
	        return this.minPxFlipped;
	      }
	    }, {
	      key: 'getMaxPx',
	      value: function getMaxPx() {
	        return this.maxPxFlipped;
	      }
	    }, {
	      key: 'getMathMaxPx',
	      value: function getMathMaxPx() {
	        return this.maxPx;
	      }
	    }, {
	      key: 'getMathMinPx',
	      value: function getMathMinPx() {
	        return this.minPx;
	      }
	    }, {
	      key: 'getMinValue',
	      value: function getMinValue() {
	        return this.options.forcedMin !== false ? this.options.forcedMin : this.dataMin;
	      }
	    }, {
	      key: 'getMaxValue',
	      value: function getMaxValue() {
	        return this.options.forcedMax !== false ? this.options.forcedMax : this.dataMax;
	      }
	    }, {
	      key: 'setMinValueData',
	      value: function setMinValueData(min) {
	        this.dataMin = min;

	        // 25.10.2017. This is to help in the case there's no autoscaling
	        if (isNaN(this.getCurrentMin())) ;
	      }
	    }, {
	      key: 'setMaxValueData',
	      value: function setMaxValueData(max) {
	        this.dataMax = max;

	        // 25.10.2017. This is to help in the case there's no autoscaling
	        // 02.02.2018. Don't agree with this. Next time, put a link to show the use of this piece of code
	        if (isNaN(this.getCurrentMax())) ;
	      }
	    }, {
	      key: 'getDataMax',
	      value: function getDataMax() {
	        return this.dataMax;
	      }
	    }, {
	      key: 'getDataMin',
	      value: function getDataMin() {
	        return this.dataMin;
	      }
	    }, {
	      key: 'forceMin',
	      value: function forceMin(min) {
	        var noRescale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        this.options.forcedMin = min;
	        this.setCurrentMin(noRescale ? this.getCurrentMin() : undefined);
	        this.graph._axisHasChanged(this);
	        return this;
	      }
	    }, {
	      key: 'forceMax',
	      value: function forceMax(max) {
	        var noRescale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        this.options.forcedMax = max;
	        this.setCurrentMax(noRescale ? this.getCurrentMax() : undefined);
	        this.graph._axisHasChanged(this);
	        return this;
	      }
	    }, {
	      key: 'getForcedMin',
	      value: function getForcedMin() {
	        return this.options.forcedMin;
	      }
	    }, {
	      key: 'getForcedMax',
	      value: function getForcedMax() {
	        return this.options.forcedMax;
	      }
	    }, {
	      key: 'forceToAxis',
	      value: function forceToAxis(axis) {
	        if (axis.getMaxValue && axis.getMinValue) {
	          this.options.forcedMin = axis.getMinValue();
	          this.options.forcedMax = axis.getMaxValue();
	        }

	        return this;
	      }
	    }, {
	      key: 'getNbTicksPrimary',
	      value: function getNbTicksPrimary() {
	        return this.options.nbTicksPrimary;
	      }
	    }, {
	      key: 'setNbTicksPrimary',
	      value: function setNbTicksPrimary(nb) {
	        this.options.nbTicksPrimary = nb;
	      }
	    }, {
	      key: 'getNbTicksSecondary',
	      value: function getNbTicksSecondary() {
	        return this.options.nbTicksSecondary;
	      }
	    }, {
	      key: 'setNbTicksSecondary',
	      value: function setNbTicksSecondary(nb) {
	        this.options.nbTicksSecondary = nb;
	        return this;
	      }
	    }, {
	      key: 'handleMouseMove',
	      value: function handleMouseMove(px) {
	        this.mouseVal = this.getVal(px);
	      }
	    }, {
	      key: 'handleMouseWheel',
	      value: function handleMouseWheel(delta, e, baseline) {

	        delta = Math.min(0.2, Math.max(-0.2, delta));

	        if (baseline == 'min') {
	          baseline = this.getMinValue();
	        } else if (baseline == 'max') {
	          baseline = this.getMaxValue();
	        } else if (!baseline) {
	          baseline = 0;
	        }

	        this._doZoomVal((this.getCurrentMax() - baseline) * (1 + delta) + baseline, (this.getCurrentMin() - baseline) * (1 + delta) + baseline);

	        this.graph.draw();
	        //	this.graph.drawSeries(true);
	      }
	    }, {
	      key: 'zoom',
	      value: function zoom(val1, val2, forceLock) {

	        if (!forceLock && this.zoomLock) {
	          return;
	        }

	        return this._doZoomVal(val1, val2, true);
	      }
	    }, {
	      key: '_doZoomVal',
	      value: function _doZoomVal(val1, val2, mute) {

	        return this._doZoom(this.getPx(val1), this.getPx(val2), val1, val2, mute);
	      }
	    }, {
	      key: '_doZoom',
	      value: function _doZoom(px1, px2, val1, val2, mute) {

	        //if(this.options.display || 1 == 1) {
	        var val1 = val1 !== undefined ? val1 : this.getVal(px1);
	        var val2 = val2 !== undefined ? val2 : this.getVal(px2);

	        this.setCurrentMin(Math.min(val1, val2));
	        this.setCurrentMax(Math.max(val1, val2));

	        this.cacheCurrentMin();
	        this.cacheCurrentMax();
	        this.cacheInterval();

	        this._zoomed = true;

	        this.adapt();

	        this._hasChanged = true;

	        // New method
	        if (!mute) {
	          this.emit('zoom', [this.currentAxisMin, this.currentAxisMax, this]);
	        }

	        return this;
	      }
	    }, {
	      key: 'getSerieShift',
	      value: function getSerieShift() {
	        return this._serieShift;
	      }
	    }, {
	      key: 'getSerieScale',
	      value: function getSerieScale() {
	        return this._serieScale;
	      }
	    }, {
	      key: 'getMouseVal',
	      value: function getMouseVal() {
	        return this.mouseVal;
	      }
	    }, {
	      key: 'getUnitPerTick',
	      value: function getUnitPerTick(px, nbTick, valrange) {

	        var pxPerTick = px / nbTicks; // 1000 / 100 = 10 px per tick
	        if (!nbTick) {
	          nbTick = px / 10;
	        } else {
	          nbTick = Math.min(nbTick, px / 10);
	        }

	        // So now the question is, how many units per ticks ?
	        // Say, we have 0.0004 unit per tick
	        var unitPerTick = valrange / nbTick;

	        switch (this.options.unitModification) {

	          case 'time':
	          case 'time:min.sec':
	            {

	              //const max = this.getModifiedValue( this.getMaxValue() );/*,
	              /*units = [
	                [ 60, 'min' ],
	                [ 3600, 'h' ],
	                [ 3600 * 24, 'd' ]
	              ];*/

	              var i = void 0,
	                  l = void 0,
	                  k = void 0,
	                  m = void 0;
	              var breaked = false;
	              for (i = 0, l = this.unitModificationTimeTicks.length; i < l; i++) {
	                for (k = 0, m = this.unitModificationTimeTicks[i][1].length; k < m; k++) {
	                  if (unitPerTick < this.unitModificationTimeTicks[i][0] * this.unitModificationTimeTicks[i][1][k]) {
	                    breaked = true;
	                    break;
	                  }
	                }
	                if (breaked) {
	                  break;
	                }
	              }

	              //i and k contain the good variable;
	              if (i !== this.unitModificationTimeTicks.length) {
	                unitPerTickCorrect = this.unitModificationTimeTicks[i][0] * this.unitModificationTimeTicks[i][1][k];
	              } else {
	                unitPerTickCorrect = 1;
	              }

	              break;
	            }
	          default:
	            {

	              // We take the log
	              var decimals = Math.floor(Math.log(unitPerTick) / Math.log(10));
	              /*
	              Example:
	              13'453 => Math.log10() = 4.12 => 4
	              0.0000341 => Math.log10() = -4.46 => -5
	              */

	              var numberToNatural = unitPerTick * Math.pow(10, -decimals);

	              /*
	              Example:
	              13'453 (4) => 1.345
	              0.0000341 (-5) => 3.41
	              */

	              this.decimals = -decimals;

	              var possibleTicks = [1, 2, 5, 10];
	              var closest = false;
	              for (var _i = possibleTicks.length - 1; _i >= 0; _i--) {
	                if (!closest || Math.abs(possibleTicks[_i] - numberToNatural) < Math.abs(closest - numberToNatural)) {
	                  closest = possibleTicks[_i];
	                }
	              }

	              // Ok now closest is the number of unit per tick in the natural number
	              /*
	              Example:
	              13'453 (4) (1.345) => 1
	              0.0000341 (-5) (3.41) => 5
	              */

	              // Let's scale it back
	              var unitPerTickCorrect = closest * Math.pow(10, decimals);

	              /*
	              Example:
	              13'453 (4) (1.345) (1) => 10'000
	              0.0000341 (-5) (3.41) (5) => 0.00005
	              */
	              break;
	            }
	        }

	        var nbTicks = valrange / unitPerTickCorrect;

	        var pxPerTick = px / nbTick;
	        return [unitPerTickCorrect, nbTicks, pxPerTick];
	      }
	    }, {
	      key: 'setMinMaxToFitSeries',
	      value: function setMinMaxToFitSeries(noNotify) {

	        var interval = this.getInterval();

	        if (this.options.logScale) {

	          this.currentAxisMin = Math.max(1e-50, this.getMinValue() * 0.9);
	          this.currentAxisMax = Math.max(1e-50, this.getMaxValue() * 1.1);
	        } else {

	          this.currentAxisMin = this.getMinValue();
	          this.currentAxisMax = this.getMaxValue();

	          if (this.getForcedMin() === false) {
	            this.currentAxisMin -= this.options.axisDataSpacing.min * interval;
	          }

	          if (this.getForcedMax() === false) {
	            this.currentAxisMax += this.options.axisDataSpacing.max * interval;
	          }
	        }

	        if (isNaN(this.currentAxisMin) || isNaN(this.currentAxisMax)) {
	          this.currentAxisMax = undefined;
	          this.currentAxisMin = undefined;
	        }

	        this.cache();

	        this._zoomed = false;

	        this.adapt();

	        if (!noNotify) {
	          this.graph._axisHasChanged(this);
	        }

	        this.emit('zoomOutFull', [this.currentAxisMin, this.currentAxisMax, this]);

	        return this;
	      }
	    }, {
	      key: 'getInterval',
	      value: function getInterval() {
	        return this.getMaxValue() - this.getMinValue();
	      }
	    }, {
	      key: 'getCurrentInterval',
	      value: function getCurrentInterval() {
	        return this.cachedInterval;
	      }
	    }, {
	      key: 'getCurrentMin',
	      value: function getCurrentMin() {
	        return this.cachedCurrentMin;
	      }
	    }, {
	      key: 'getCurrentMax',
	      value: function getCurrentMax() {
	        return this.cachedCurrentMax;
	      }
	    }, {
	      key: 'cacheCurrentMin',
	      value: function cacheCurrentMin() {
	        this.cachedCurrentMin = this.currentAxisMin == this.currentAxisMax ? this.options.logScale ? this.currentAxisMin / 10 : this.currentAxisMin - 1 : this.currentAxisMin;
	      }
	    }, {
	      key: 'cacheCurrentMax',
	      value: function cacheCurrentMax() {
	        this.cachedCurrentMax = this.currentAxisMax == this.currentAxisMin ? this.options.logScale ? this.currentAxisMax * 10 : this.currentAxisMax + 1 : this.currentAxisMax;
	      }
	    }, {
	      key: 'cacheInterval',
	      value: function cacheInterval() {
	        this.cachedInterval = this.cachedCurrentMax - this.cachedCurrentMin;
	      }
	    }, {
	      key: 'cache',
	      value: function cache() {
	        this.cacheCurrentMin();
	        this.cacheCurrentMax();
	        this.cacheInterval();
	      }
	    }, {
	      key: 'setCurrentMin',
	      value: function setCurrentMin(val) {

	        if (val === undefined || this.getForcedMin() !== false && (val < this.getForcedMin() || val === undefined)) {
	          val = this.getMinValue();
	        }
	        this.currentAxisMin = val;
	        if (this.options.logScale) {
	          this.currentAxisMin = Math.max(1e-50, val);
	        }

	        this.cacheCurrentMin();
	        this.cacheInterval();

	        this.graph._axisHasChanged(this);
	        return this;
	      }
	    }, {
	      key: 'setCurrentMax',
	      value: function setCurrentMax(val) {

	        if (val === undefined || this.getForcedMax() !== false && (val > this.getForcedMax() || val === undefined)) {
	          val = this.getMaxValue();
	        }

	        this.currentAxisMax = val;

	        if (this.options.logScale) {
	          this.currentAxisMax = Math.max(1e-50, val);
	        }

	        this.cacheCurrentMax();
	        this.cacheInterval();

	        this.graph._axisHasChanged(this);
	      }
	    }, {
	      key: 'flip',
	      value: function flip(_flip) {
	        this.options.flipped = _flip;
	        this.setMinMaxFlipped();
	        return this;
	      }
	    }, {
	      key: 'isFlipped',
	      value: function isFlipped() {
	        return this.options.flipped;
	      }
	    }, {
	      key: '_draw',
	      value: function _draw() {
	        // Redrawing of the axis

	        var self = this;
	        // var visible;

	        //    this.drawInit();

	        if (this.currentAxisMin === undefined || this.currentAxisMax === undefined) {
	          this.setMinMaxToFitSeries(true); // We reset the min max as a function of the series
	        }

	        // this.cache();

	        //   this.setSlaveAxesBoundaries();

	        // The data min max is stored in this.dataMin, this.dataMax

	        //var widthPx = this.maxPx - this.minPx;
	        var widthPx = Math.abs(this.getMaxPx() - this.getMinPx());
	        var valrange = this.getCurrentInterval();

	        /* Number of px per unit */
	        /* Example: width: 1000px
	        /* 			10 - 100 => 11.11
	        /*			0 - 2 => 500
	        /*			0 - 0.00005 => 20'000'000
	        */

	        if (!this.isShown()) {
	          this.line.setAttribute('display', 'none');
	          return 0;
	        }

	        this.line.setAttribute('display', 'block');

	        if (this.options.scientificScale == true) {

	          if (this.options.scientificScaleExponent) {

	            this.scientificExponent = this.options.scientificScaleExponent;
	          } else {
	            this.scientificExponent = Math.floor(Math.log(Math.max(Math.abs(this.getCurrentMax()), Math.abs(this.getCurrentMin()))) / Math.log(10));
	          }
	        } else {
	          this.scientificExponent = 0;
	        }

	        /************************************/
	        /*** DRAWING LABEL ******************/
	        /************************************/

	        this.gridLinePath.primary = '';
	        this.gridLinePath.secondary = '';

	        /*
	        var label;
	        if ( label = this.getLabel() ) {
	          // Sets the label
	          this.labelTspan.textContent = label;
	        }
	        */
	        var letter = void 0;
	        if (!this.options.useKatexForLabel || !this.graph.hasKatexRenderer()) {

	          if (this.options.unitDecade && this.options.unit && this.scientificExponent !== 0 && (this.scientificExponent = this.getEngineeringExponent(this.scientificExponent)) && (letter = this.getExponentGreekLetter(this.scientificExponent))) {

	            this.preunit = letter;
	            this.unitTspan.setAttribute('dx', 0);
	          } else if (this.scientificExponent !== 0 && !isNaN(this.scientificExponent)) {

	            if (this.options.engineeringScale) {
	              this.scientificExponent = this.getEngineeringExponent(this.scientificExponent);
	            }

	            this.preunit = '';

	            this.expTspan.setAttribute('display', 'visible');
	            this.expTspanExp.setAttribute('display', 'visible');

	            this.expTspan.textContent = 'x10';
	            this.expTspanExp.textContent = this.scientificExponent;
	          } else {

	            if (!this.options.unit) {
	              this.unitTspan.setAttribute('display', 'none');
	            }

	            this.preunit = '';
	            this.expTspan.setAttribute('display', 'none');
	            this.expTspanExp.setAttribute('display', 'none');
	          }

	          this.writeUnit();
	        } else {

	          var string = this.getLabel();
	          /*,
	                  domEl;*/

	          if (this.options.unitDecade && this.options.unit && this.scientificExponent !== 0 && (this.scientificExponent = this.getEngineeringExponent(this.scientificExponent)) && (letter = this.getExponentGreekLetter(this.scientificExponent))) {

	            string += letter;
	            this.preunitTspan.innerHTML = letter;
	            this.preunitTspan.setAttribute('display', 'visible');
	            this.unitTspan.setAttribute('dx', 0);

	            string += ' ' + letter + ' ' + this.options.unit;
	          } else if (this.scientificExponent !== 0 && !isNaN(this.scientificExponent)) {

	            if (this.options.engineeringScale) {
	              this.scientificExponent = this.getEngineeringExponent(this.scientificExponent);
	            }
	            string += ' \\cdot 10^' + this.scientificExponent + ' ' + this.options.unit;
	          }

	          this.katexElement = this.graph.renderWithKatex(string, this.katexElement);
	        }

	        if (!this.options.hideTicks) {

	          this.resetTicksLength();

	          if (this.linkedToAxis) {
	            // px defined, linked to another axis

	            this.linkedToAxis.deltaPx = 10;
	            var widthHeight = this.drawLinkedToAxisTicksWrapper(widthPx, valrange);
	          } else if (!this.options.logScale) {
	            // So the setting is: How many ticks in total ? Then we have to separate it

	            var widthHeight = this.drawLinearTicksWrapper(widthPx, valrange);
	          } else {

	            var widthHeight = this.drawLogTicks();
	          }
	        } else {
	          var widthHeight = 0;
	        }

	        this.removeUselessTicks();
	        this.removeUselessTickLabels();

	        this.gridPrimary.setAttribute('d', this.gridLinePath.primary);
	        this.gridSecondary.setAttribute('d', this.gridLinePath.secondary);

	        // Looks for axes linked to this current axis
	        var axes = this.graph.findAxesLinkedTo(this);
	        axes.forEach(function (axis) {

	          if (!axis.linkedToAxis) {
	            return;
	          }
	          axis.setMinPx(self.getMinPx());
	          axis.setMaxPx(self.getMaxPx());

	          axis.draw();
	        });

	        /************************************/
	        /*** DRAW CHILDREN IMPL SPECIFIC ****/
	        /************************************/

	        //   this.drawSpecifics();

	        return widthHeight;
	      }
	    }, {
	      key: 'drawLines',
	      value: function drawLines() {
	        var _this3 = this;

	        if (this.options.lineAt && Array.isArray(this.options.lineAt)) {

	          this.options.lineAt.forEach(function (val, index) {

	            if (!isNaN(val) && _this3.getCurrentMin() <= val && _this3.getCurrentMax() >= val) {

	              _this3._lines[index] = _this3._drawLine(val, _this3._lines[index]);
	            } else {
	              _this3._hideLine(_this3._lines[index]);
	            }
	          });
	        }
	      }
	    }, {
	      key: 'writeUnit',
	      value: function writeUnit() {
	        if (this.options.unit) {

	          this.unitTspan.setAttribute('display', 'visible');
	          this.unitTspan.setAttribute('dx', 5);

	          this.expTspan.setAttribute('display', 'none');
	          this.expTspanExp.setAttribute('display', 'none');
	          this.unitTspan.innerHTML = (this.options.unitWrapperBefore + this.preunit + this.options.unit + this.options.unitWrapperAfter).replace(/\^([-+0-9]*)(.*)/g, "<tspan dy='-5' font-size='0.7em'>$1</tspan><tspan dy='5' font-size='1em'>$2</tspan>");
	        } else {
	          this.unitTspan.setAttribute('display', 'none');
	        }
	      }
	    }, {
	      key: 'getExponentGreekLetter',
	      value: function getExponentGreekLetter(val) {

	        switch (val) {

	          case 3:
	            {
	              return 'k';
	            }

	          case 6:
	            {
	              return 'M';
	            }
	          case 9:
	            {
	              return 'G';
	            }
	          case 12:
	            {
	              return 'T';
	            }
	          case 15:
	            {
	              return 'E';
	            }
	          case -3:
	            {
	              return 'm';
	            }
	          case -6:
	            {
	              return '&mu;';
	            }
	          case -9:
	            {
	              return 'n';
	            }
	          case -12:
	            {
	              return 'p';
	            }
	          case -15:
	            {
	              return 'f';
	            }
	          default:
	            {
	              return '';
	            }
	        }
	      }
	    }, {
	      key: 'drawLinearTicksWrapper',
	      value: function drawLinearTicksWrapper(widthPx, valrange) {

	        var tickPrimaryUnit = void 0;

	        if (this.options.primaryTickUnit) {

	          tickPrimaryUnit = this.options.primaryTickUnit;
	        } else {

	          tickPrimaryUnit = this.getUnitPerTick(widthPx, this.getNbTicksPrimary(), valrange)[0];

	          if (this.options.maxPrimaryTickUnit && this.options.maxPrimaryTickUnit < tickPrimaryUnit) {
	            tickPrimaryUnit = this.options.maxPrimaryTickUnit;
	          } else if (this.options.minPrimaryTickUnit && this.options.minPrimaryTickUnit > tickPrimaryUnit) {
	            tickPrimaryUnit = this.options.minPrimaryTickUnit;
	          }
	        }

	        // We need to get here the width of the ticks to display the axis properly, with the correct shift
	        return this.drawTicks(tickPrimaryUnit, this.secondaryTicks());
	      }
	    }, {
	      key: 'forcePrimaryTickUnit',
	      value: function forcePrimaryTickUnit(primaryInterval) {
	        this.options.primaryTickUnit = primaryInterval;
	      }
	    }, {
	      key: 'forcePrimaryTickUnitMax',
	      value: function forcePrimaryTickUnitMax(value) {
	        this.options.maxPrimaryTickUnit = value;
	      }
	    }, {
	      key: 'forcePrimaryTickUnitMin',
	      value: function forcePrimaryTickUnitMin(value) {
	        this.options.minPrimaryTickUnit = value;
	      }
	    }, {
	      key: 'getPrimaryTickUnit',
	      value: function getPrimaryTickUnit() {
	        return this.incrTick;
	      }
	    }, {
	      key: 'setTickLabelRatio',
	      value: function setTickLabelRatio(tickRatio) {
	        this.options.ticklabelratio = tickRatio;
	      }
	    }, {
	      key: 'doesHideWhenNoSeriesShown',
	      value: function doesHideWhenNoSeriesShown() {
	        return this.options.hideWhenNoSeriesShown;
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {

	        this._widthLabels = 0;
	        var drawn = this._draw();
	        this._widthLabels += drawn;
	        return drawn;
	      }
	    }, {
	      key: 'drawTicks',
	      value: function drawTicks(primary, secondary) {

	        var unitPerTick = primary,
	            min = this.getCurrentMin(),
	            max = this.getCurrentMax(),
	            secondaryIncr,
	            incrTick,
	            subIncrTick,
	            loop = 0;

	        if (secondary) {
	          secondaryIncr = unitPerTick / secondary;
	        }

	        incrTick = this.options.shiftToZero ? this.dataMin - Math.ceil((this.dataMin - min) / unitPerTick) * unitPerTick : Math.floor(min / unitPerTick) * unitPerTick;
	        this.incrTick = primary;

	        while (incrTick <= max) {

	          loop++;
	          if (loop > 200) {
	            break;
	          }

	          if (secondary) {

	            subIncrTick = incrTick + secondaryIncr;
	            this.subIncrTick = subIncrTick;
	            //widthHeight = Math.max(widthHeight, this.drawTick(subIncrTick, 1));
	            var loop2 = 0;

	            while (subIncrTick < incrTick + unitPerTick) {
	              loop2++;
	              if (loop2 > 100) {
	                break;
	              }

	              if (subIncrTick < min || subIncrTick > max) {
	                subIncrTick += secondaryIncr;
	                continue;
	              }

	              this.drawTickWrapper(subIncrTick, false, Math.abs(subIncrTick - incrTick - unitPerTick / 2) < 1e-4 ? 2 : 3);

	              subIncrTick += secondaryIncr;
	            }
	          }

	          if (incrTick < min || incrTick > max) {
	            incrTick += primary;
	            continue;
	          }

	          this.drawTickWrapper(incrTick, true, 1);
	          incrTick += primary;
	        }

	        this.widthHeightTick = this.getMaxSizeTick();
	        return this.widthHeightTick;
	      }
	    }, {
	      key: 'nextTick',
	      value: function nextTick(level, callback) {

	        this.ticks[level] = this.ticks[level] || [];
	        this.lastCurrentTick[level] = this.lastCurrentTick[level] || 0;
	        this.currentTick[level] = this.currentTick[level] || 0;

	        if (this.currentTick[level] >= this.ticks[level].length) {
	          var tick = document.createElementNS(this.graph.ns, 'line');
	          this.groupTicks.appendChild(tick);
	          this.ticks[level].push(tick);

	          callback(tick);
	        }

	        var tick = this.ticks[level][this.currentTick[level]];

	        if (this.currentTick[level] >= this.lastCurrentTick[level]) {
	          tick.setAttribute('display', 'visible');
	        }

	        this.currentTick[level]++;

	        return tick;
	      }
	    }, {
	      key: 'nextTickLabel',
	      value: function nextTickLabel(callback) {

	        this.ticksLabels = this.ticksLabels || [];
	        this.lastCurrentTickLabel = this.lastCurrentTickLabel || 0;
	        this.currentTickLabel = this.currentTickLabel || 0;

	        if (this.currentTickLabel >= this.ticksLabels.length) {

	          var tickLabel = document.createElementNS(this.graph.ns, 'text');
	          this.groupTickLabels.appendChild(tickLabel);
	          this.ticksLabels.push(tickLabel);
	          callback(tickLabel);
	        }

	        var tickLabel = this.ticksLabels[this.currentTickLabel];

	        if (this.currentTickLabel >= this.lastCurrentTickLabel) {
	          tickLabel.setAttribute('display', 'visible');
	        }

	        this.currentTickLabel++;

	        return tickLabel;
	      }
	    }, {
	      key: 'removeUselessTicks',
	      value: function removeUselessTicks() {

	        for (var j in this.currentTick) {

	          for (var i = this.currentTick[j]; i < this.ticks[j].length; i++) {
	            this.ticks[j][i].setAttribute('display', 'none');
	          }

	          this.lastCurrentTick[j] = this.currentTick[j];
	          this.currentTick[j] = 0;
	        }
	      }
	    }, {
	      key: 'removeUselessTickLabels',
	      value: function removeUselessTickLabels() {

	        for (var i = this.currentTickLabel; i < this.ticksLabels.length; i++) {
	          this.ticksLabels[i].setAttribute('display', 'none');
	        }

	        this.lastCurrentTickLabel = this.currentTickLabel;
	        this.currentTickLabel = 0;
	      }
	    }, {
	      key: 'nextGridLine',
	      value: function nextGridLine(primary, x1, x2, y1, y2) {

	        if (!(primary && this.options.primaryGrid || !primary && this.options.secondaryGrid)) {
	          return;
	        }

	        this.gridLinePath[primary ? 'primary' : 'secondary'] += 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2;
	      }
	    }, {
	      key: 'setGridLineStyle',
	      value: function setGridLineStyle(gridLine, primary) {

	        gridLine.setAttribute('shape-rendering', 'crispEdges');
	        gridLine.setAttribute('stroke', primary ? this.getPrimaryGridColor() : this.getSecondaryGridColor());
	        gridLine.setAttribute('stroke-width', primary ? this.getPrimaryGridWidth() : this.getSecondaryGridWidth());
	        gridLine.setAttribute('stroke-opacity', primary ? this.getPrimaryGridOpacity() : this.getSecondaryGridOpacity());

	        var dasharray;
	        if (dasharray = primary ? this.getPrimaryGridDasharray() : this.getSecondaryGridDasharray()) {
	          gridLine.setAttribute('stroke-dasharray', dasharray);
	        }
	      }
	    }, {
	      key: 'setGridLinesStyle',
	      value: function setGridLinesStyle() {
	        this.setGridLineStyle(this.gridPrimary, true);
	        this.setGridLineStyle(this.gridSecondary, false);
	        return this;
	      }
	    }, {
	      key: 'resetTicksLength',
	      value: function resetTicksLength() {}
	    }, {
	      key: 'secondaryTicks',
	      value: function secondaryTicks() {
	        return this.options.nbTicksSecondary;
	      }
	    }, {
	      key: 'drawLogTicks',
	      value: function drawLogTicks() {
	        var min = this.getCurrentMin(),
	            max = this.getCurrentMax();
	        var incr = Math.min(min, max);
	        var max = Math.max(min, max);

	        if (incr < 1e-50) {
	          incr = 1e-50;
	        }

	        if (Math.log(incr) - Math.log(max) > 20) {
	          max = Math.pow(10, Math.log(incr) * 20);
	        }

	        var optsMain = {
	          fontSize: '1.0em',
	          exponential: true,
	          overwrite: false
	        };

	        if (incr < 0) {
	          incr = 0;
	        }

	        var pow = incr == 0 ? 0 : Math.floor(Math.log(incr) / Math.log(10));
	        var incr = 1,
	            val;
	        while ((val = incr * Math.pow(10, pow)) < max) {
	          if (incr == 1) {
	            // Superior power
	            if (val > min) this.drawTickWrapper(val, true, 1, optsMain);
	          }
	          if (incr == 10) {
	            incr = 1;
	            pow++;
	          } else {

	            if (incr != 1 && val > min) {

	              this.drawTickWrapper(val, false, 2, {
	                overwrite: '',
	                fontSize: '0.6em'
	              });
	            }

	            incr++;
	          }
	        }

	        this.widthHeightTick = this.getMaxSizeTick();
	        return this.widthHeightTick;
	      }
	    }, {
	      key: 'drawTickWrapper',
	      value: function drawTickWrapper(value, label, level, options) {

	        //var pos = this.getPos( value );

	        this.drawTick(value, level, options);
	      }
	    }, {
	      key: 'linkToAxis',
	      value: function linkToAxis(axis, scalingFunction, decimals) {

	        this.linkedToAxis = {
	          axis: axis,
	          scalingFunction: scalingFunction,
	          decimals: decimals || 1
	        };
	      }
	    }, {
	      key: 'drawLinkedToAxisTicksWrapper',
	      value: function drawLinkedToAxisTicksWrapper(widthPx, valrange) {

	        var opts = this.linkedToAxis,
	            px = 0,
	            val,
	            t,
	            l,
	            delta2;

	        // Redrawing the main axis ? Why ?
	        //opts.axis.draw();

	        if (!opts.deltaPx) {
	          opts.deltaPx = 10;
	        }

	        do {

	          val = opts.scalingFunction(opts.axis.getVal(px + this.getMinPx()));

	          if (opts.decimals) {
	            this.decimals = opts.decimals;
	          }

	          t = this.drawTick(val, 1, {}, px + this.getMinPx());

	          if (!t) {
	            console.error(val, px, this.getMinPx());
	            throw new Error('Unable to draw tick. Please report the test-case');
	          }

	          l = String(t[1].textContent).length * 8;
	          delta2 = Math.round(l / 5) * 5;

	          if (delta2 > opts.deltaPx) {
	            opts.deltaPx = delta2;
	            //     this.drawInit();
	            this.drawLinkedToAxisTicksWrapper(widthPx, valrange);
	            return;
	          }

	          px += opts.deltaPx;
	        } while (px < widthPx);
	      }
	    }, {
	      key: 'getPos',
	      value: function getPos(value) {
	        return this.getPx(value);
	      }
	    }, {
	      key: 'getPx',
	      value: function getPx(value) {
	        //      if(this.getMaxPx() == undefined)
	        //        console.log(this);
	        //console.log(this.getMaxPx(), this.getMinPx(), this.getCurrentInterval());
	        // Ex 50 / (100) * (1000 - 700) + 700

	        //console.log( value, this.getCurrentMin(), this.getMaxPx(), this.getMinPx(), this.getCurrentInterval() );

	        if (!this.options.logScale) {

	          return (value - this.getCurrentMin()) / this.getCurrentInterval() * (this.getMaxPx() - this.getMinPx()) + this.getMinPx();
	        } else {
	          // 0 if value = min
	          // 1 if value = max

	          if (value < 0) return;

	          var value = (Math.log(value) - Math.log(this.getCurrentMin())) / (Math.log(this.getCurrentMax()) - Math.log(this.getCurrentMin())) * (this.getMaxPx() - this.getMinPx()) + this.getMinPx();

	          return value;
	        }
	      }
	    }, {
	      key: 'getRoundedPx',
	      value: function getRoundedPx(value) {
	        //      if(this.getMaxPx() == undefined)
	        //        console.log(this);
	        //console.log(this.getMaxPx(), this.getMinPx(), this.getCurrentInterval());
	        // Ex 50 / (100) * (1000 - 700) + 700

	        //console.log( value, this.getCurrentMin(), this.getMaxPx(), this.getMinPx(), this.getCurrentInterval() );
	        return Math.round(this.getPx(value) * 10) / 10;
	      }
	    }, {
	      key: 'getVal',
	      value: function getVal(px) {

	        if (!this.options.logScale) {

	          return (px - this.getMinPx()) / (this.getMaxPx() - this.getMinPx()) * this.getCurrentInterval() + this.getCurrentMin();
	        } else {

	          return Math.exp((px - this.getMinPx()) / (this.getMaxPx() - this.getMinPx()) * (Math.log(this.getCurrentMax()) - Math.log(this.getCurrentMin())) + Math.log(this.getCurrentMin()));
	        }
	      }
	    }, {
	      key: 'getRelPx',
	      value: function getRelPx(delta) {

	        return delta / this.getCurrentInterval() * (this.getMaxPx() - this.getMinPx());
	      }
	    }, {
	      key: 'getRelVal',
	      value: function getRelVal(px) {
	        return px / (this.getMaxPx() - this.getMinPx()) * this.getCurrentInterval();
	      }
	    }, {
	      key: 'valueToText',
	      value: function valueToText(value) {

	        if (this.scientificExponent) {

	          value /= Math.pow(10, this.scientificExponent);
	          return value.toFixed(1);
	        } else {

	          value = value * Math.pow(10, this.getExponentialFactor()) * Math.pow(10, this.getExponentialLabelFactor());
	          if (this.options.shiftToZero) {
	            value -= this.dataMin;
	          }
	          if (this.options.ticklabelratio) {
	            value *= this.options.ticklabelratio;
	          }
	          if (this.options.unitModification) {
	            value = this.modifyUnit(value, this.options.unitModification);
	            return value;
	          }

	          var dec = this.decimals - this.getExponentialFactor() - this.getExponentialLabelFactor();

	          if (isNaN(value)) {
	            return '';
	          }

	          if (dec > 0) {
	            value = value.toFixed(dec);
	          } else {
	            value = value.toFixed(0);
	          }

	          if (this.options.unitInTicks && this.options.unit) {
	            value += ' ' + this.options.unit;
	          }

	          return value;
	        }
	      }
	    }, {
	      key: 'valueToHtml',
	      value: function valueToHtml(value, noScaling, noUnits) {

	        var text = this.valueToText(value);
	        var letter;

	        if (this.options.unitDecade && this.options.unit && this.scientificExponent !== 0 && (this.scientificExponent = this.getEngineeringExponent(this.scientificExponent)) && (letter = this.getExponentGreekLetter(this.scientificExponent))) {

	          text += letter;
	        } else if (this.scientificExponent !== 0 && !isNaN(this.scientificExponent) && !noScaling) {
	          text += 'x10';
	          text += '<sup>' + this.scientificExponent + '</sup>';
	        }

	        if (this.options.unit && !noUnits) {

	          text += this.options.unit.replace(/\^([-+0-9]*)/g, '<sup>$1</sup>');
	        }

	        return text;
	      }
	    }, {
	      key: 'getModifiedValue',
	      value: function getModifiedValue(value) {
	        if (this.options.ticklabelratio) {
	          value *= this.options.ticklabelratio;
	        }

	        if (this.options.shiftToZero) {
	          value -= this.getMinValue() * (this.options.ticklabelratio || 1);
	        }

	        return value;
	      }
	    }, {
	      key: 'modifyUnit',
	      value: function modifyUnit(value, mode) {

	        var text = '';
	        var incr = this.incrTick;
	        var umin;

	        switch (mode) {

	          case 'time':
	            // val must be in seconds => transform in hours / days / months
	            var max = this.getModifiedValue(this.getMaxValue()),
	                units = [[60, 'min'], [3600, 'h'], [3600 * 24, 'd']];

	            if (max < 3600) {
	              // to minutes
	              umin = 0;
	            } else if (max < 3600 * 24) {
	              umin = 1;
	            } else if (max < 3600 * 24 * 30) {
	              umin = 2;
	            }

	            if (!units[umin]) {
	              return false;
	            }

	            value = value / units[umin][0];
	            var valueRounded = Math.floor(value);
	            text = valueRounded + units[umin][1];

	            // Addind lower unit for precision
	            umin--;
	            while (incr < 1 * units[umin + 1][0] && umin > -1) {

	              value = (value - valueRounded) * units[umin + 1][0] / units[umin][0];
	              valueRounded = Math.round(value);
	              text += ' ' + valueRounded + units[umin][1];
	              umin--;
	            }

	            break;

	          case 'time:min.sec':
	            value = value / 60;
	            var valueRounded = Math.floor(value);
	            var s = Math.round((value - valueRounded) * 60) + '';
	            s = s.length == 1 ? '0' + s : s;
	            text = valueRounded + '.' + s;
	            break;

	          default:
	            break;
	        }

	        return text;
	      }
	    }, {
	      key: 'getExponentialFactor',
	      value: function getExponentialFactor() {
	        return this.options.exponentialFactor;
	      }
	    }, {
	      key: 'setExponentialFactor',
	      value: function setExponentialFactor(value) {
	        this.options.exponentialFactor = value;
	      }
	    }, {
	      key: 'setExponentialLabelFactor',
	      value: function setExponentialLabelFactor(value) {
	        this.options.exponentialLabelFactor = value;
	      }
	    }, {
	      key: 'getExponentialLabelFactor',
	      value: function getExponentialLabelFactor() {
	        return this.options.exponentialLabelFactor;
	      }
	    }, {
	      key: 'setLabel',
	      value: function setLabel(label) {
	        this.options.labelValue = label;
	        return this;
	      }
	    }, {
	      key: 'setLabelFont',
	      value: function setLabelFont(font) {
	        this.options.labelFont = font;
	        return this;
	      }
	    }, {
	      key: 'getLabel',
	      value: function getLabel() {
	        return this.options.labelValue;
	      }
	    }, {
	      key: 'setSpan',
	      value: function setSpan(_from, _to) {

	        this.options.span = [_from, _to];
	        return this;
	      }
	    }, {
	      key: 'getSpan',
	      value: function getSpan() {
	        return this.options.span;
	      }
	    }, {
	      key: 'setLevel',
	      value: function setLevel(level) {
	        this._level = level;
	        return this;
	      }
	    }, {
	      key: 'getLevel',
	      value: function getLevel() {
	        return this._level;
	      }
	    }, {
	      key: 'setShift',
	      value: function setShift(shift) {
	        this.shift = shift;
	      }
	    }, {
	      key: 'getShift',
	      value: function getShift() {
	        return this.shift;
	      }
	    }, {
	      key: 'setTickPosition',
	      value: function setTickPosition(pos) {
	        switch (pos) {
	          case 3:
	          case 'outside':
	          case _graphCore2.default.TICKS_OUTSIDE:
	            {
	              pos = 3;
	              break;
	            }

	          case 2:
	          case 'centered':
	          case _graphCore2.default.TICKS_CENTERED:
	            {
	              pos = 2;
	              break;
	            }

	          case 1:
	          case 'inside':
	          case _graphCore2.default.TICKS_INSIDE:
	          default:
	            {
	              pos = 1;
	              break;
	            }
	        }

	        this.options.tickPosition = pos;

	        switch (this.options.tickPosition) {
	          case 3:
	            this.tickPx1 = -2;
	            this.tickPx2 = 0;
	            break;

	          case 2:
	            this.tickPx1 = -1;
	            this.tickPx2 = 1;
	            break;

	          default:
	          case 1:
	            this.tickPx1 = 0;
	            this.tickPx2 = 2;
	            break;
	        }

	        return this;
	      }
	    }, {
	      key: 'setGrids',
	      value: function setGrids(on) {
	        this.options.primaryGrid = on;
	        this.options.secondaryGrid = on;
	        return this;
	      }
	    }, {
	      key: 'setPrimaryGrid',
	      value: function setPrimaryGrid(on) {
	        this.options.primaryGrid = on;
	        return this;
	      }
	    }, {
	      key: 'setSecondaryGrid',
	      value: function setSecondaryGrid(on) {
	        this.options.secondaryGrid = on;
	        return this;
	      }
	    }, {
	      key: 'primaryGridOn',
	      value: function primaryGridOn() {
	        return this.setPrimaryGrid(true);
	      }
	    }, {
	      key: 'primaryGridOff',
	      value: function primaryGridOff() {
	        return this.setPrimaryGrid(false);
	      }
	    }, {
	      key: 'secondaryGridOn',
	      value: function secondaryGridOn() {
	        return this.setSecondaryGrid(true);
	      }
	    }, {
	      key: 'secondaryGridOff',
	      value: function secondaryGridOff() {
	        return this.setSecondaryGrid(false);
	      }
	    }, {
	      key: 'gridsOn',
	      value: function gridsOn() {
	        return this.setGrids(true);
	      }
	    }, {
	      key: 'gridsOff',
	      value: function gridsOff() {
	        return this.setGrids(false);
	      }
	    }, {
	      key: 'turnGridsOff',
	      value: function turnGridsOff() {
	        return this.gridsOff.apply(this, arguments);
	      }
	    }, {
	      key: 'turnGridsOn',
	      value: function turnGridsOn() {
	        return this.gridsOn.apply(this, arguments);
	      }
	    }, {
	      key: 'setAxisColor',
	      value: function setAxisColor(color) {
	        this.options.axisColor = color;
	        return this;
	      }
	    }, {
	      key: 'getAxisColor',
	      value: function getAxisColor() {
	        return this.options.axisColor || 'black';
	      }
	    }, {
	      key: 'setTickLabelOffset',
	      value: function setTickLabelOffset(offsetValue) {
	        this.options.tickLabelOffset = offsetValue;
	        return this;
	      }
	    }, {
	      key: 'setPrimaryTicksColor',
	      value: function setPrimaryTicksColor(color) {
	        this.options.primaryTicksColor = color;
	        return this;
	      }
	    }, {
	      key: 'getPrimaryTicksColor',
	      value: function getPrimaryTicksColor() {
	        return this.options.primaryTicksColor || 'black';
	      }
	    }, {
	      key: 'setSecondaryTicksColor',
	      value: function setSecondaryTicksColor(color) {
	        this.options.secondaryTicksColor = color;
	        return this;
	      }
	    }, {
	      key: 'getSecondaryTicksColor',
	      value: function getSecondaryTicksColor() {
	        return this.options.secondaryTicksColor || 'black';
	      }
	    }, {
	      key: 'setTicksLabelColor',
	      value: function setTicksLabelColor(color) {
	        this.options.ticksLabelColor = color;
	        if (Array.isArray(this.ticksLabels)) {
	          this.ticksLabels.forEach(function (tick) {
	            tick.setAttribute('fill', color);
	          });
	        }
	        return this;
	      }
	    }, {
	      key: 'getTicksLabelColor',
	      value: function getTicksLabelColor() {
	        return this.options.ticksLabelColor || 'black';
	      }
	    }, {
	      key: 'setPrimaryGridColor',
	      value: function setPrimaryGridColor(color) {
	        this.options.primaryGridColor = color;
	        this.setGridLinesStyle();
	        return this;
	      }
	    }, {
	      key: 'getPrimaryGridColor',
	      value: function getPrimaryGridColor() {
	        return this.options.primaryGridColor;
	      }
	    }, {
	      key: 'setSecondaryGridColor',
	      value: function setSecondaryGridColor(color) {
	        this.options.secondaryGridColor = color;
	        this.setGridLinesStyle();
	        return this;
	      }
	    }, {
	      key: 'getSecondaryGridColor',
	      value: function getSecondaryGridColor() {
	        return this.options.secondaryGridColor;
	      }
	    }, {
	      key: 'setPrimaryGridWidth',
	      value: function setPrimaryGridWidth(width) {
	        this.options.primaryGridWidth = width;
	        this.setGridLinesStyle();
	        return this;
	      }
	    }, {
	      key: 'getPrimaryGridWidth',
	      value: function getPrimaryGridWidth() {
	        return this.options.primaryGridWidth;
	      }
	    }, {
	      key: 'setSecondaryGridWidth',
	      value: function setSecondaryGridWidth(width) {
	        this.options.secondaryGridWidth = width;
	        this.setGridLinesStyle();
	        return this;
	      }
	    }, {
	      key: 'getSecondaryGridWidth',
	      value: function getSecondaryGridWidth() {
	        return this.options.secondaryGridWidth;
	      }
	    }, {
	      key: 'setPrimaryGridOpacity',
	      value: function setPrimaryGridOpacity(opacity) {
	        this.options.primaryGridOpacity = opacity;
	        return this;
	      }
	    }, {
	      key: 'getPrimaryGridOpacity',
	      value: function getPrimaryGridOpacity() {
	        return this.options.primaryGridOpacity;
	      }
	    }, {
	      key: 'setSecondaryGridOpacity',
	      value: function setSecondaryGridOpacity(opacity) {
	        this.options.secondaryGridOpacity = opacity;
	        return this;
	      }
	    }, {
	      key: 'getSecondaryGridOpacity',
	      value: function getSecondaryGridOpacity() {
	        return this.options.secondaryGridOpacity;
	      }
	    }, {
	      key: 'setPrimaryGridDasharray',
	      value: function setPrimaryGridDasharray(dasharray) {
	        this.options.primaryGridDasharray = dasharray;
	        return this;
	      }
	    }, {
	      key: 'getPrimaryGridDasharray',
	      value: function getPrimaryGridDasharray() {
	        return this.options.primaryGridDasharray;
	      }
	    }, {
	      key: 'setSecondaryGridDasharray',
	      value: function setSecondaryGridDasharray(dasharray) {
	        this.options.secondaryGridDasharray = dasharray;
	        return this;
	      }
	    }, {
	      key: 'getSecondaryGridDasharray',
	      value: function getSecondaryGridDasharray() {
	        return this.options.secondaryGridDasharray;
	      }
	    }, {
	      key: 'setLabelColor',
	      value: function setLabelColor(color) {
	        this.options.labelColor = color;
	        return this;
	      }
	    }, {
	      key: 'getLabelColor',
	      value: function getLabelColor() {
	        return this.options.labelColor;
	      }
	    }, {
	      key: 'setTickContent',
	      value: function setTickContent(dom, val, options) {
	        if (!options) options = {};

	        if (options.overwrite || !options.exponential) {

	          dom.textContent = options.overwrite || this.valueToText(val);
	        } else {
	          var log = Math.round(Math.log(val) / Math.log(10));
	          var unit = Math.floor(val * Math.pow(10, -log));

	          dom.textContent = unit != 1 ? unit + 'x10' : '10';
	          var tspan = document.createElementNS(this.graph.ns, 'tspan');
	          tspan.textContent = log;
	          tspan.setAttribute('font-size', '0.7em');
	          tspan.setAttribute('dy', -5);
	          dom.appendChild(tspan);
	        }

	        if (options.fontSize) {
	          dom.setAttribute('font-size', options.fontSize);
	        }
	      }
	    }, {
	      key: 'isX',
	      value: function isX() {
	        return false;
	      }
	    }, {
	      key: 'isY',
	      value: function isY() {
	        return false;
	      }
	    }, {
	      key: 'setUnit',
	      value: function setUnit(unit) {
	        this.options.unit = unit;
	        return this;
	      }
	    }, {
	      key: 'setUnitInTicks',
	      value: function setUnitInTicks(bool) {
	        this.options.unitInTicks = bool;
	        return this;
	      }
	    }, {
	      key: 'setUnitWrapper',
	      value: function setUnitWrapper(before, after) {
	        this.options.unitWrapperBefore = before;
	        this.options.unitWrapperAfter = after;
	        return this;
	      }
	    }, {
	      key: 'setUnitDecade',
	      value: function setUnitDecade(on) {
	        this.options.unitDecade = on;
	        return this;
	      }
	    }, {
	      key: 'setScientific',
	      value: function setScientific(on) {
	        this.options.scientificScale = on;
	        return this;
	      }
	    }, {
	      key: 'setScientificScaleExponent',
	      value: function setScientificScaleExponent(scientificScaleExponent) {
	        this.options.scientificScaleExponent = scientificScaleExponent;
	        return this;
	      }
	    }, {
	      key: 'setEngineering',
	      value: function setEngineering(engineeringScaling) {
	        //bool
	        this.options.scientificScale = engineeringScaling;
	        this.options.engineeringScale = engineeringScaling;
	        return this;
	      }
	    }, {
	      key: 'getEngineeringExponent',
	      value: function getEngineeringExponent(scientificExponent) {

	        if (scientificExponent > 0) {
	          scientificExponent -= scientificExponent % 3;
	        } else {
	          scientificExponent -= (3 - -scientificExponent % 3) % 3;
	        }

	        return scientificExponent;
	      }
	    }, {
	      key: 'setLogScale',
	      value: function setLogScale(log) {
	        this.options.logScale = log;
	        return this;
	      }
	    }, {
	      key: 'isZoomed',
	      value: function isZoomed() {
	        return !(this.currentAxisMin == this.getMinValue() || this.currentAxisMax == this.getMaxValue());
	      }
	    }, {
	      key: 'hasAxis',
	      value: function hasAxis() {
	        return false;
	      }
	    }, {
	      key: 'getType',
	      value: function getType() {
	        return null;
	      }
	    }, {
	      key: 'useKatexForLabel',
	      value: function useKatexForLabel() {
	        var use = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	        this.options.useKatexForLabel = use;
	        return this;
	      }
	    }, {
	      key: 'zoomLock',
	      set: function set(bln) {
	        this._zoomLocked = bln;
	      },
	      get: function get() {
	        return this._zoomLocked || false;
	      }
	    }]);

	    return Axis;
	  }(_EventEmitter3.default);

	  /**
	   *  @alias Axis#getVal
	   */
	  Axis.prototype.getValue = Axis.prototype.getVal;

	  /**
	   *  @alias Axis#getRelPx
	   */
	  Axis.prototype.getDeltaPx = Axis.prototype.getRelPx;

	  exports.default = Axis;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 73 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  var ErrorBarMixin = {
	    /*
	      doErrorDraw: function( orientation, error, originVal, originPx, xpx, ypx ) {
	         if ( !( error instanceof Array ) ) {
	          error = [ error ];
	        }
	         var functionName = orientation == 'y' ? 'getY' : 'getX';
	        var bars = orientation == 'y' ? [ 'top', 'bottom' ] : [ 'left', 'right' ];
	        var j;
	         if ( isNaN( xpx ) || isNaN( ypx ) ) {
	          return;
	        }
	         for ( var i = 0, l = error.length; i < l; i++ ) {
	           if ( error[ i ] instanceof Array ) { // TOP
	             j = bars[ 0 ];
	            this.errorstyles[ i ].paths[ j ] += " M " + xpx + " " + ypx;
	            this.errorstyles[ i ].paths[ j ] += this.makeError( orientation, i, this[ functionName ]( originVal + error[ i ][ 0 ] ), originPx, j );
	             j = bars[ 1 ];
	            this.errorstyles[ i ].paths[ j ] += " M " + xpx + " " + ypx;
	            this.errorstyles[ i ].paths[ j ] += this.makeError( orientation, i, this[ functionName ]( originVal - error[ i ][ 1 ] ), originPx, j );
	           } else {
	             j = bars[ 0 ];
	             this.errorstyles[ i ].paths[ j ] += " M " + xpx + " " + ypx;
	            this.errorstyles[ i ].paths[ j ] += this.makeError( orientation, i, this[ functionName ]( originVal + error[ i ] ), originPx, j );
	            j = bars[ 1 ];
	            this.errorstyles[ i ].paths[ j ] += " M " + xpx + " " + ypx;
	            this.errorstyles[ i ].paths[ j ] += this.makeError( orientation, i, this[ functionName ]( originVal - error[ i ] ), originPx, j );
	          }
	        }
	      },
	    */

	    /*
	      makeError: function( orientation, type, coord, origin, quadOrientation ) {
	         var method;
	        switch ( this.errorstyles[ level ].type ) {
	          case 'bar':
	            method = "makeBar";
	            break;
	           case 'box':
	            method = "makeBox";
	            break;
	        }
	         return this[ method + orientation.toUpperCase() ]( coord, origin, this.errorstyles[ level ][ quadOrientation ] );
	       },*/

	    makeBarY: function makeBarY(coordY, origin, style) {
	      if (!coordY || style === undefined) {
	        return;
	      }
	      var width = !util.isNumeric(style.width) ? 10 : style.width;
	      return ' V ' + coordY + ' m -' + width / 2 + ' 0 h ' + width + ' m -' + width / 2 + ' 0 V ' + origin + ' ';
	    },

	    makeBoxY: function makeBoxY(coordY, origin, style) {
	      if (!coordY || style === undefined) {
	        return;
	      }
	      return ' m 5 0 V ' + coordY + ' h -10 V ' + origin + ' m 5 0 ';
	    },

	    makeBarX: function makeBarX(coordX, origin, style) {
	      if (!coordX || style === undefined) {
	        return;
	      }
	      var height = !util.isNumeric(style.width) ? 10 : style.width;
	      return ' H ' + coordX + ' m 0 -' + height / 2 + ' v ' + height + ' m 0 -' + height / 2 + ' H ' + origin + ' ';
	    },

	    makeBoxX: function makeBoxX(coordX, origin, style) {
	      if (!coordX || style === undefined) {
	        return;
	      }
	      return ' v 5 H ' + coordX + ' v -10 H ' + origin + ' v 5 ';
	    },
	    /*
	      check: function( index, valY, valX ) {
	         var dx, dy;
	         if ( ( this.getType() == Graph.SERIE_LINE || this.getType() == Graph.SERIE_SCATTER ) ) {
	           if ( !( dx = this.data[ index * 2 ] ) || !( dy = this.data[ index * 2 + 1 ] ) ) { //
	            return;
	          }
	        }
	         if ( dx === undefined ) {
	          return;
	        }
	         for ( var i = 0, l = valY.length; i < l; i++ ) {
	           if ( Array.isArray( valY[ i ] ) ) {
	             if ( !isNaN( valY[ i ][ 0 ] ) ) {
	              this._checkY( dy + valY[ i ][ 0 ] );
	            }
	             if ( !isNaN( valY[ i ][ 1 ] ) ) {
	              this._checkY( dy - valY[ i ][ 1 ] );
	            }
	           } else {
	             if ( !isNaN( valY[ i ] ) ) {
	              this._checkY( dy + valY[ i ] );
	              this._checkY( dy - valY[ i ] );
	            }
	          }
	        }
	         for ( var i = 0, l = valX.length; i < l; i++ ) {
	           if ( Array.isArray( valX[ i ] ) ) {
	             if ( !isNaN( valX[ i ][ 0 ] ) ) {
	              this._checkX( dx - valX[ i ][ 0 ] );
	            }
	             if ( !isNaN( valX[ i ][ 1 ] ) ) {
	              this._checkX( dx + valX[ i ][ 1 ] );
	            }
	           } else {
	             if ( !isNaN( valY[ i ] ) ) {
	              this._checkX( dx - valX[ i ] );
	              this._checkX( dx + valX[ i ] );
	            }
	          }
	        }
	       },
	    */

	    /**
	     *
	     *  @example serie.setErrorStyle( [ { type: 'bar', x: {} }, { type: 'box', top: { strokeColor: 'green', fillColor: 'olive' }, bottom: { strokeColor: 'red', fillColor: "#800000" }  } ] );
	     */
	    setErrorBarStyle: function setErrorBarStyle(errorstyle) {

	      this.errorbarStyle = this._setErrorStyle(errorstyle);
	      return this;
	    },

	    setErrorBoxStyle: function setErrorBoxStyle(errorstyle) {

	      this.errorboxStyle = this._setErrorStyle(errorstyle);
	      return this;
	    },

	    _setErrorStyle: function _setErrorStyle() {
	      var _this = this;

	      var errorstyles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


	      var styles = [];
	      var pairs = [['y', 'top', 'bottom'], ['x', 'left', 'right']];

	      var makePath = function makePath(style) {

	        style.dom = document.createElementNS(_this.graph.ns, 'path');
	        style.dom.setAttribute('fill', style.fillColor || 'none');
	        style.dom.setAttribute('stroke', style.strokeColor || 'black');
	        style.dom.setAttribute('stroke-opacity', style.strokeOpacity || 1);
	        style.dom.setAttribute('fill-opacity', style.fillOpacity || 1);
	        style.dom.setAttribute('stroke-width', style.strokeWidth || 1);

	        _this.groupMain.appendChild(style.dom);
	      };
	      // i is bar or box

	      var styles = {};

	      if (typeof errorstyles == 'string') {
	        errorstyles = {};
	      }

	      for (var j = 0, l = pairs.length; j < l; j++) {

	        if (errorstyles.all) {

	          errorstyles[pairs[j][1]] = util.extend(true, {}, errorstyles.all);
	          errorstyles[pairs[j][2]] = util.extend(true, {}, errorstyles.all);
	        }

	        if (errorstyles[pairs[j][0]]) {
	          //.x, .y

	          errorstyles[pairs[j][1]] = util.extend(true, {}, errorstyles[pairs[j][0]]);
	          errorstyles[pairs[j][2]] = util.extend(true, {}, errorstyles[pairs[j][0]]);
	        }

	        for (var k = 1; k <= 2; k++) {

	          if (errorstyles[pairs[j][k]]) {

	            styles[pairs[j][k]] = errorstyles[pairs[j][k]];
	            makePath(styles[pairs[j][k]]);
	          }
	        }
	      }

	      return styles;
	    },


	    errorDrawInit: function errorDrawInit() {
	      //  var pathError = "M 0 0 ";

	      if (this.errorboxStyle) {

	        this.errorboxStyle.paths = {
	          top: '',
	          bottom: '',
	          left: '',
	          right: ''
	        };
	      }

	      if (this.errorbarStyle) {

	        this.errorbarStyle.paths = {
	          top: '',
	          bottom: '',
	          left: '',
	          right: ''
	        };
	      }
	    },

	    errorAddPoint: function errorAddPoint(index, dataX, dataY, xpx, ypx) {

	      /* eslint-disable no-cond-assign */
	      var error = void 0;
	      if (error = this.waveform.getErrorBarXBelow(index)) {
	        this.errorbarStyle.paths.left += ' M ' + xpx + ' ' + ypx;
	        this.errorbarStyle.paths.left += this.makeBarX(this.getX(dataX - error), xpx, this.errorbarStyle.left);
	      }

	      if (error = this.waveform.getErrorBarXAbove(index)) {
	        this.errorbarStyle.paths.right += ' M ' + xpx + ' ' + ypx;
	        this.errorbarStyle.paths.right += this.makeBarX(this.getX(dataX + error), xpx, this.errorbarStyle.right);
	      }

	      if (error = this.waveform.getErrorBarYBelow(index)) {
	        this.errorbarStyle.paths.bottom += ' M ' + xpx + ' ' + ypx;
	        this.errorbarStyle.paths.bottom += this.makeBarY(this.getY(dataY - error), ypx, this.errorbarStyle.bottom);
	      }

	      if (error = this.waveform.getErrorBarYAbove(index)) {
	        this.errorbarStyle.paths.top += ' M ' + xpx + ' ' + ypx;
	        this.errorbarStyle.paths.top += this.makeBarY(this.getY(dataY + error), ypx, this.errorbarStyle.top);
	      }

	      if (error = this.waveform.getErrorBoxXBelow(index)) {
	        this.errorboxStyle.paths.left += ' M ' + xpx + ' ' + ypx;
	        this.errorboxStyle.paths.left += this.makeBoxX(this.getX(dataX - error), xpx, this.errorboxStyle.left);
	      }

	      if (error = this.waveform.getErrorBoxXAbove(index)) {
	        this.errorboxStyle.paths.right += ' M ' + xpx + ' ' + ypx;

	        this.errorboxStyle.paths.right += this.makeBoxX(this.getX(dataX + error), xpx, this.errorboxStyle.right);
	      }

	      if (error = this.waveform.getErrorBoxYBelow(index)) {
	        this.errorboxStyle.paths.bottom += ' M ' + xpx + ' ' + ypx;
	        this.errorboxStyle.paths.bottom += this.makeBoxY(this.getY(dataY - error), ypx, this.errorboxStyle.bottom);
	      }

	      if (error = this.waveform.getErrorBoxYAbove(index)) {
	        this.errorboxStyle.paths.top += ' M ' + xpx + ' ' + ypx;
	        this.errorboxStyle.paths.top += this.makeBoxY(this.getY(dataY + error), ypx, this.errorboxStyle.top);
	      }
	      /* eslint-enable */
	    },

	    errorAddPointBarChart: function errorAddPointBarChart(j, posY, xpx, ypx) {
	      var error;
	      if (this.error && (error = this.error[j])) {
	        this.doErrorDraw('y', error, posY, ypx, xpx, ypx);
	      }
	    },

	    errorDraw: function errorDraw() {

	      if (this.errorbarStyle) {

	        for (var j in this.errorbarStyle.paths) {

	          if (this.errorbarStyle[j] && this.errorbarStyle[j].dom) {
	            this.errorbarStyle[j].dom.setAttribute('d', this.errorbarStyle.paths[j]);
	          }
	        }
	      }

	      if (this.errorboxStyle) {

	        for (var j in this.errorboxStyle.paths) {

	          if (this.errorboxStyle[j] && this.errorboxStyle[j].dom) {
	            this.errorboxStyle[j].dom.setAttribute('d', this.errorboxStyle.paths[j]);
	          }
	        }
	      }
	    }
	  };

	  exports.default = ErrorBarMixin;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 74 */
	/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(4);
	var document = __webpack_require__(2).document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	  return is ? document.createElement(it) : {};
	};


	/***/ }),
	/* 75 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var core = __webpack_require__(22);
	var LIBRARY = __webpack_require__(36);
	var wksExt = __webpack_require__(105);
	var defineProperty = __webpack_require__(8).f;
	module.exports = function (name) {
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};


	/***/ }),
	/* 76 */
	/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(58)('keys');
	var uid = __webpack_require__(35);
	module.exports = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};


	/***/ }),
	/* 77 */
	/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');


	/***/ }),
	/* 78 */
	/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(2).document;
	module.exports = document && document.documentElement;


	/***/ }),
	/* 79 */
	/***/ (function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(4);
	var anObject = __webpack_require__(1);
	var check = function (O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = __webpack_require__(19)(Function.call, __webpack_require__(17).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};


	/***/ }),
	/* 80 */
	/***/ (function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


	/***/ }),
	/* 81 */
	/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(4);
	var setPrototypeOf = __webpack_require__(79).set;
	module.exports = function (that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  } return that;
	};


	/***/ }),
	/* 82 */
	/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(25);
	var defined = __webpack_require__(24);

	module.exports = function repeat(count) {
	  var str = String(defined(this));
	  var res = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
	  return res;
	};


	/***/ }),
	/* 83 */
	/***/ (function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};


	/***/ }),
	/* 84 */
	/***/ (function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;


	/***/ }),
	/* 85 */
	/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(25);
	var defined = __webpack_require__(24);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};


	/***/ }),
	/* 86 */
	/***/ (function(module, exports, __webpack_require__) {

	var LIBRARY = __webpack_require__(36);
	var $export = __webpack_require__(0);
	var redefine = __webpack_require__(14);
	var hide = __webpack_require__(13);
	var has = __webpack_require__(12);
	var Iterators = __webpack_require__(49);
	var $iterCreate = __webpack_require__(87);
	var setToStringTag = __webpack_require__(47);
	var getPrototypeOf = __webpack_require__(18);
	var ITERATOR = __webpack_require__(6)('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};


	/***/ }),
	/* 87 */
	/***/ (function(module, exports, __webpack_require__) {

	var create = __webpack_require__(39);
	var descriptor = __webpack_require__(34);
	var setToStringTag = __webpack_require__(47);
	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(13)(IteratorPrototype, __webpack_require__(6)('iterator'), function () { return this; });

	module.exports = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};


	/***/ }),
	/* 88 */
	/***/ (function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(62);
	var defined = __webpack_require__(24);

	module.exports = function (that, searchString, NAME) {
	  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};


	/***/ }),
	/* 89 */
	/***/ (function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(6)('match');
	module.exports = function (KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch (f) { /* empty */ }
	  } return true;
	};


	/***/ }),
	/* 90 */
	/***/ (function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators = __webpack_require__(49);
	var ITERATOR = __webpack_require__(6)('iterator');
	var ArrayProto = Array.prototype;

	module.exports = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};


	/***/ }),
	/* 91 */
	/***/ (function(module, exports, __webpack_require__) {

	var $defineProperty = __webpack_require__(8);
	var createDesc = __webpack_require__(34);

	module.exports = function (object, index, value) {
	  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};


	/***/ }),
	/* 92 */
	/***/ (function(module, exports, __webpack_require__) {

	var classof = __webpack_require__(54);
	var ITERATOR = __webpack_require__(6)('iterator');
	var Iterators = __webpack_require__(49);
	module.exports = __webpack_require__(22).getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};


	/***/ }),
	/* 93 */
	/***/ (function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(237);

	module.exports = function (original, length) {
	  return new (speciesConstructor(original))(length);
	};


	/***/ }),
	/* 94 */
	/***/ (function(module, exports, __webpack_require__) {
	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

	var toObject = __webpack_require__(10);
	var toAbsoluteIndex = __webpack_require__(38);
	var toLength = __webpack_require__(9);
	module.exports = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var aLen = arguments.length;
	  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};


	/***/ }),
	/* 95 */
	/***/ (function(module, exports, __webpack_require__) {

	var addToUnscopables = __webpack_require__(33);
	var step = __webpack_require__(121);
	var Iterators = __webpack_require__(49);
	var toIObject = __webpack_require__(16);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(86)(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');


	/***/ }),
	/* 96 */
	/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(19);
	var invoke = __webpack_require__(111);
	var html = __webpack_require__(78);
	var cel = __webpack_require__(74);
	var global = __webpack_require__(2);
	var process = global.process;
	var setTask = global.setImmediate;
	var clearTask = global.clearImmediate;
	var MessageChannel = global.MessageChannel;
	var Dispatch = global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (__webpack_require__(20)(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	    defer = function (id) {
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in cel('script')) {
	    defer = function (id) {
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set: setTask,
	  clear: clearTask
	};


	/***/ }),
	/* 97 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var macrotask = __webpack_require__(96).set;
	var Observer = global.MutationObserver || global.WebKitMutationObserver;
	var process = global.process;
	var Promise = global.Promise;
	var isNode = __webpack_require__(20)(process) == 'process';

	module.exports = function () {
	  var head, last, notify;

	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise && Promise.resolve) {
	    var promise = Promise.resolve();
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }

	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};


	/***/ }),
	/* 98 */
	/***/ (function(module, exports, __webpack_require__) {

	// 25.4.1.5 NewPromiseCapability(C)
	var aFunction = __webpack_require__(11);

	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}

	module.exports.f = function (C) {
	  return new PromiseCapability(C);
	};


	/***/ }),
	/* 99 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var DESCRIPTORS = __webpack_require__(7);
	var LIBRARY = __webpack_require__(36);
	var $typed = __webpack_require__(68);
	var hide = __webpack_require__(13);
	var redefineAll = __webpack_require__(44);
	var fails = __webpack_require__(3);
	var anInstance = __webpack_require__(42);
	var toInteger = __webpack_require__(25);
	var toLength = __webpack_require__(9);
	var toIndex = __webpack_require__(130);
	var gOPN = __webpack_require__(40).f;
	var dP = __webpack_require__(8).f;
	var arrayFill = __webpack_require__(94);
	var setToStringTag = __webpack_require__(47);
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length!';
	var WRONG_INDEX = 'Wrong index!';
	var $ArrayBuffer = global[ARRAY_BUFFER];
	var $DataView = global[DATA_VIEW];
	var Math = global.Math;
	var RangeError = global.RangeError;
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = global.Infinity;
	var BaseBuffer = $ArrayBuffer;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var BUFFER = 'buffer';
	var BYTE_LENGTH = 'byteLength';
	var BYTE_OFFSET = 'byteOffset';
	var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
	var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
	var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

	// IEEE754 conversions based on https://github.com/feross/ieee754
	function packIEEE754(value, mLen, nBytes) {
	  var buffer = new Array(nBytes);
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var i = 0;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  var e, m, c;
	  value = abs(value);
	  // eslint-disable-next-line no-self-compare
	  if (value != value || value === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	}
	function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = eLen - 7;
	  var i = nBytes - 1;
	  var s = buffer[i--];
	  var e = s & 127;
	  var m;
	  s >>= 7;
	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	}

	function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	}
	function packI8(it) {
	  return [it & 0xff];
	}
	function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	}
	function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	}
	function packF64(it) {
	  return packIEEE754(it, 52, 8);
	}
	function packF32(it) {
	  return packIEEE754(it, 23, 4);
	}

	function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
	}

	function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	}
	function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = conversion(+value);
	  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	}

	if (!$typed.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    this._b = arrayFill.call(new Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH];
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };

	  if (DESCRIPTORS) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }

	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!fails(function () {
	    $ArrayBuffer(1);
	  }) || !fails(function () {
	    new $ArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new
	    new $ArrayBuffer(1.5); // eslint-disable-line no-new
	    new $ArrayBuffer(NaN); // eslint-disable-line no-new
	    return $ArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new BaseBuffer(toIndex(length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
	    }
	    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;


	/***/ }),
	/* 100 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var navigator = global.navigator;

	module.exports = navigator && navigator.userAgent || '';


	/***/ }),
	/* 101 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(72)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphAxis) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphAxis2 = _interopRequireDefault(_graphAxis);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var AxisX = function (_Axis) {
	    _inherits(AxisX, _Axis);

	    function AxisX(graph, topbottom) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      _classCallCheck(this, AxisX);

	      var _this = _possibleConstructorReturn(this, (AxisX.__proto__ || Object.getPrototypeOf(AxisX)).call(this, graph, topbottom, options));

	      _this.top = topbottom == 'top';
	      return _this;
	    }

	    /**
	     *  @private
	     *  Returns the position of the axis, used by refreshDrawingZone in core module
	     */


	    _createClass(AxisX, [{
	      key: 'getAxisPosition',
	      value: function getAxisPosition() {

	        if (!this.options.display) {
	          return 0;
	        }

	        var size = void 0;

	        if (this.options.tickLabelOffset == 0) {
	          // Normal mode, no offset
	          size = this.options.tickPosition == 1 ? 8 : 20;
	          size += this.graph.options.fontSize * 1;
	        } else {
	          // With an offset, and ticks inside, axis position is actually 0. Otherwise, it's the heights of the ticks
	          size = this.options.tickPosition == 1 ? 0 : 12;
	        }

	        if (this.getLabel()) {
	          size += this.graph.options.fontSize;
	        }

	        return size;
	      }
	    }, {
	      key: 'isX',
	      value: function isX() {
	        return true;
	      }
	    }, {
	      key: 'isY',
	      value: function isY() {
	        return false;
	      }
	    }, {
	      key: 'setShift',
	      value: function setShift(shift) {

	        this.shift = shift;
	        if (this.getShift() === undefined || !this.graph.getDrawingHeight()) {
	          return;
	        }

	        this.group.setAttribute('transform', 'translate(0 ' + (this.floating ? this.getShift() : this.top ? this.shift : this.graph.getDrawingHeight() - this.shift) + ')');
	      }
	    }, {
	      key: 'getMaxSizeTick',
	      value: function getMaxSizeTick() {
	        return (this.top ? -1 : 1) * (this.options.tickPosition == 1 ? 10 : 10);
	      }
	    }, {
	      key: 'drawTick',
	      value: function drawTick(value, level, options, forcedPos) {
	        var _this2 = this;

	        var self = this,
	            val;

	        val = forcedPos || this.getPos(value);

	        if (val == undefined || isNaN(val)) {
	          return;
	        }

	        var tick = this.nextTick(level, function (tick) {

	          tick.setAttribute('y1', (self.top ? 1 : -1) * self.tickPx1 * self.tickScaling[level]);
	          tick.setAttribute('y2', (self.top ? 1 : -1) * self.tickPx2 * self.tickScaling[level]);

	          if (level == 1) {
	            tick.setAttribute('stroke', self.getPrimaryTicksColor());
	          } else {
	            tick.setAttribute('stroke', self.getSecondaryTicksColor());
	          }
	        });

	        //      tick.setAttribute( 'shape-rendering', 'crispEdges' );
	        tick.setAttribute('x1', val);
	        tick.setAttribute('x2', val);

	        this.nextGridLine(level == 1, val, val, 0, this.graph.getDrawingHeight());

	        //  this.groupTicks.appendChild( tick );
	        if (level == 1) {
	          var tickLabel = this.nextTickLabel(function (tickLabel) {

	            tickLabel.setAttribute('y', (self.top ? -1 : 1) * ((self.options.tickPosition == 1 ? 8 : 20) + (self.top ? 10 : 0)) + _this2.options.tickLabelOffset);
	            tickLabel.setAttribute('text-anchor', 'middle');
	            if (self.getTicksLabelColor() !== 'black') {
	              tickLabel.setAttribute('fill', self.getTicksLabelColor());
	            }
	            tickLabel.style.dominantBaseline = 'hanging';
	          });

	          tickLabel.setAttribute('x', val);
	          this.setTickContent(tickLabel, value, options);
	        }
	        //    this.ticks.push( tick );

	        return [tick, tickLabel];
	      }
	    }, {
	      key: 'drawLabel',
	      value: function drawLabel() {
	        // Place label correctly

	        if (this.getLabelColor() !== 'black') {
	          this.label.setAttribute('fill', this.getLabelColor());
	        }

	        if (this.options.labelFont) {
	          this.label.setAttribute('font-family', this.options.labelFont);
	        }

	        this.label.setAttribute('text-anchor', 'middle');
	        this.label.setAttribute('style', 'display: initial;');
	        this.label.setAttribute('x', Math.abs(this.getMaxPx() + this.getMinPx()) / 2);
	        this.label.setAttribute('y', (this.top ? -1 : 1) * ((this.options.tickPosition == 1 ? 10 : 25) + this.graph.options.fontSize));
	        this.labelTspan.textContent = this.getLabel();
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {
	        var tickWidth = _get(AxisX.prototype.__proto__ || Object.getPrototypeOf(AxisX.prototype), 'draw', this).apply(this, arguments);
	        this.drawSpecifics();

	        return tickWidth;
	      }
	    }, {
	      key: 'drawSpecifics',
	      value: function drawSpecifics() {

	        // Adjusts group shift
	        //this.group.setAttribute('transform', 'translate(0 ' + this.getShift() + ')');

	        this.drawLabel();

	        this.line.setAttribute('x1', this.getMinPx());
	        this.line.setAttribute('x2', this.getMaxPx());
	        this.line.setAttribute('y1', 0);
	        this.line.setAttribute('y2', 0);

	        this.line.setAttribute('stroke', this.getAxisColor());

	        if (!this.top) {

	          this.labelTspan.style.dominantBaseline = 'hanging';
	          this.expTspan.style.dominantBaseline = 'hanging';
	          this.expTspanExp.style.dominantBaseline = 'hanging';

	          this.unitTspan.style.dominantBaseline = 'hanging';
	          //  this.preunitTspan.style.dominantBaseline = 'hanging';
	        }

	        var span = this.getSpan();
	        this.line.setAttribute('marker-start', !this.options.splitMarks || span[0] == 0 ? '' : 'url(#horionzalsplit_' + this.graph.getId() + ')');
	        this.line.setAttribute('marker-end', !this.options.splitMarks || span[1] == 1 ? '' : 'url(#horionzalsplit_' + this.graph.getId() + ')');
	      }
	    }, {
	      key: '_drawLine',
	      value: function _drawLine(pos, line) {

	        var px = this.getPx(pos);

	        if (!line) {
	          line = document.createElementNS(this.graph.ns, 'line');
	        } else {
	          line.setAttribute('display', 'initial');
	        }

	        line.setAttribute('x1', px);
	        line.setAttribute('x2', px);

	        line.setAttribute('y1', 0);
	        line.setAttribute('y2', this.graph.drawingSpaceHeight);

	        line.setAttribute('stroke', 'black');
	        this.group.appendChild(line);

	        return line;
	      }
	    }, {
	      key: '_hideLine',
	      value: function _hideLine(line) {
	        if (!line) {
	          return;
	        }
	        line.setAttribute('display', 'none');
	      }
	    }, {
	      key: 'handleMouseMoveLocal',
	      value: function handleMouseMoveLocal(x) {
	        // handleMouseMoveLocal( x, y, e )
	        x -= this.graph.getPaddingLeft();
	        this.mouseVal = this.getVal(x);
	      }
	    }, {
	      key: 'setMinMaxFlipped',
	      value: function setMinMaxFlipped() {

	        var interval = this.maxPx - this.minPx;

	        if (isNaN(interval)) {
	          return;
	        }

	        var maxPx = interval * this.options.span[1] + this.minPx - this.options.marginMax;
	        var minPx = interval * this.options.span[0] + this.minPx + this.options.marginMin;

	        this.minPxFlipped = this.isFlipped() ? maxPx : minPx;
	        this.maxPxFlipped = this.isFlipped() ? minPx : maxPx;
	      }
	    }, {
	      key: 'getZProj',
	      value: function getZProj(zValue) {
	        return zValue * this.graph.options.zAxis.shiftX;
	      }
	    }]);

	    return AxisX;
	  }(_graphAxis2.default);

	  exports.default = AxisX;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 102 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShape) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeLine = function (_GraphShape) {
	    _inherits(ShapeLine, _GraphShape);

	    function ShapeLine(graph, options) {
	      _classCallCheck(this, ShapeLine);

	      return _possibleConstructorReturn(this, (ShapeLine.__proto__ || Object.getPrototypeOf(ShapeLine)).call(this, graph, options));
	    }

	    /**
	     * Creates the DOM
	     * @private
	     * @return {Shape} The current shape
	     */


	    _createClass(ShapeLine, [{
	      key: 'createDom',
	      value: function createDom() {

	        this._dom = document.createElementNS(this.graph.ns, 'line');

	        if (!this.getStrokeColor()) {
	          this.setStrokeColor('black');
	        }

	        if (!this.getStrokeWidth()) {
	          this.setStrokeWidth(1);
	        }
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {

	        this._createHandles(2, 'rect', {
	          transform: 'translate(-3 -3)',
	          width: 6,
	          height: 6,
	          stroke: 'black',
	          fill: 'white',
	          cursor: 'nwse-resize'
	        });
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        var position = this.calculatePosition(0);
	        var position2 = this.calculatePosition(1);

	        if (!position || !position.x || !position.y) {
	          return;
	        }

	        this.setDom('x2', position.x);
	        this.setDom('y2', position.y);

	        this.setDom('y1', position2.y);
	        this.setDom('x1', position2.x);

	        this.currentPos2x = position2.x;
	        this.currentPos2y = position2.y;

	        this.currentPos1x = position.x;
	        this.currentPos1y = position.y;

	        return true;
	      }
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

	        if (this.isLocked()) {
	          return;
	        }

	        var pos = this.getPosition(0);
	        var pos2 = this.getPosition(1);

	        var posToChange;
	        if (this.handleSelected == 1) {

	          posToChange = pos;
	        } else if (this.handleSelected == 2) {

	          posToChange = pos2;
	        }

	        if (posToChange) {

	          if (!this._data.vertical) {
	            posToChange.deltaPosition('x', deltaX, this.getXAxis());
	          }

	          if (!this._data.horizontal) {
	            posToChange.deltaPosition('y', deltaY, this.getYAxis());
	          }
	        }

	        if (this.moving) {
	          console.log(this._data);
	          // If the pos2 is defined by a delta, no need to move them
	          if (pos.x && !this._data.noX) {
	            pos.deltaPosition('x', deltaX, this.getXAxis());
	          }
	          if (pos.y && !this._data.noY) {
	            pos.deltaPosition('y', deltaY, this.getYAxis());
	          }

	          // If the pos2 is defined by a delta, no need to move them
	          if (pos2.x && !this._data.noX) {
	            pos2.deltaPosition('x', deltaX, this.getXAxis());
	          }
	          if (pos2.y && !this._data.noY) {
	            pos2.deltaPosition('y', deltaY, this.getYAxis());
	          }
	        }

	        if (this._data.forcedCoords) {

	          var forced = this._data.forcedCoords;

	          if (forced.y !== undefined) {

	            if (typeof forced.y == 'function') {
	              pos2.y = pos.y = forced.y(this);
	            } else {
	              pos2.y = forced.y;
	              pos.y = forced.y;
	            }
	          }

	          if (forced.x !== undefined) {

	            if (typeof forced.x == 'function') {
	              pos2.x = pos.x = forced.x(this);
	            } else {
	              pos2.x = forced.x;
	              pos.x = forced.x;
	            }
	          }
	        }

	        if (this.rectEvent) {
	          this.setEventReceptacle();
	        }

	        this.redraw();
	        this.changed();
	        this.setHandles();

	        return true;
	      }
	    }, {
	      key: 'setHandles',
	      value: function setHandles() {

	        if (!this.areHandlesInDom()) {
	          return;
	        }

	        if (isNaN(this.currentPos1x)) {
	          return;
	        }

	        this.handles[1].setAttribute('x', this.currentPos1x);
	        this.handles[1].setAttribute('y', this.currentPos1y);

	        this.handles[2].setAttribute('x', this.currentPos2x);
	        this.handles[2].setAttribute('y', this.currentPos2y);
	      }
	    }, {
	      key: 'setEventReceptacle',
	      value: function setEventReceptacle() {

	        if (!this.currentPos1x) {
	          return;
	        }

	        if (!this.rectEvent) {
	          this.rectEvent = document.createElementNS(this.graph.ns, 'line');
	          this.rectEvent.setAttribute('pointer-events', 'stroke');
	          this.rectEvent.setAttribute('stroke', 'transparent');
	          this.rectEvent.jsGraphIsShape = this;
	          this.group.appendChild(this.rectEvent);
	        }

	        this.rectEvent.setAttribute('x1', this.currentPos1x);
	        this.rectEvent.setAttribute('y1', this.currentPos1y);
	        this.rectEvent.setAttribute('x2', this.currentPos2x);
	        this.rectEvent.setAttribute('y2', this.currentPos2y);
	        this.rectEvent.setAttribute('stroke-width', this.getProp('strokeWidth') + 2);
	      }
	    }]);

	    return ShapeLine;
	  }(_graphShape2.default);

	  exports.default = ShapeLine;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 103 */
	/***/ (function(module, exports) {

	var g;

	// This works in non-strict mode
	g = (function() {
		return this;
	})();

	try {
		// This works if eval is allowed (see CSP)
		g = g || Function("return this")() || (0, eval)("this");
	} catch(e) {
		// This works if the window reference is available
		if(typeof window === "object")
			g = window;
	}

	// g can still be undefined, but nothing to do about it...
	// We return undefined, instead of nothing here, so it's
	// easier to handle this case. if(!global) { ...}

	module.exports = g;


	/***/ }),
	/* 104 */
	/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(7) && !__webpack_require__(3)(function () {
	  return Object.defineProperty(__webpack_require__(74)('div'), 'a', { get: function () { return 7; } }).a != 7;
	});


	/***/ }),
	/* 105 */
	/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(6);


	/***/ }),
	/* 106 */
	/***/ (function(module, exports, __webpack_require__) {

	var has = __webpack_require__(12);
	var toIObject = __webpack_require__(16);
	var arrayIndexOf = __webpack_require__(59)(false);
	var IE_PROTO = __webpack_require__(76)('IE_PROTO');

	module.exports = function (object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};


	/***/ }),
	/* 107 */
	/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(8);
	var anObject = __webpack_require__(1);
	var getKeys = __webpack_require__(37);

	module.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};


	/***/ }),
	/* 108 */
	/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(16);
	var gOPN = __webpack_require__(40).f;
	var toString = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


	/***/ }),
	/* 109 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys = __webpack_require__(37);
	var gOPS = __webpack_require__(60);
	var pIE = __webpack_require__(53);
	var toObject = __webpack_require__(10);
	var IObject = __webpack_require__(52);
	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(3)(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;


	/***/ }),
	/* 110 */
	/***/ (function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(11);
	var isObject = __webpack_require__(4);
	var invoke = __webpack_require__(111);
	var arraySlice = [].slice;
	var factories = {};

	var construct = function (F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};

	module.exports = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function (/* args... */) {
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};


	/***/ }),
	/* 111 */
	/***/ (function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};


	/***/ }),
	/* 112 */
	/***/ (function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(2).parseInt;
	var $trim = __webpack_require__(48).trim;
	var ws = __webpack_require__(80);
	var hex = /^[-+]?0[xX]/;

	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;


	/***/ }),
	/* 113 */
	/***/ (function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(2).parseFloat;
	var $trim = __webpack_require__(48).trim;

	module.exports = 1 / $parseFloat(__webpack_require__(80) + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;


	/***/ }),
	/* 114 */
	/***/ (function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(20);
	module.exports = function (it, msg) {
	  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
	  return +it;
	};


	/***/ }),
	/* 115 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(4);
	var floor = Math.floor;
	module.exports = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};


	/***/ }),
	/* 116 */
	/***/ (function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};


	/***/ }),
	/* 117 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var sign = __webpack_require__(83);
	var pow = Math.pow;
	var EPSILON = pow(2, -52);
	var EPSILON32 = pow(2, -23);
	var MAX32 = pow(2, 127) * (2 - EPSILON32);
	var MIN32 = pow(2, -126);

	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	module.exports = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = sign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};


	/***/ }),
	/* 118 */
	/***/ (function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(1);
	module.exports = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};


	/***/ }),
	/* 119 */
	/***/ (function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(11);
	var toObject = __webpack_require__(10);
	var IObject = __webpack_require__(52);
	var toLength = __webpack_require__(9);

	module.exports = function (that, callbackfn, aLen, memo, isRight) {
	  aFunction(callbackfn);
	  var O = toObject(that);
	  var self = IObject(O);
	  var length = toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};


	/***/ }),
	/* 120 */
	/***/ (function(module, exports, __webpack_require__) {
	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

	var toObject = __webpack_require__(10);
	var toAbsoluteIndex = __webpack_require__(38);
	var toLength = __webpack_require__(9);

	module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};


	/***/ }),
	/* 121 */
	/***/ (function(module, exports) {

	module.exports = function (done, value) {
	  return { value: value, done: !!done };
	};


	/***/ }),
	/* 122 */
	/***/ (function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if (__webpack_require__(7) && /./g.flags != 'g') __webpack_require__(8).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(64)
	});


	/***/ }),
	/* 123 */
	/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};


	/***/ }),
	/* 124 */
	/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(1);
	var isObject = __webpack_require__(4);
	var newPromiseCapability = __webpack_require__(98);

	module.exports = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};


	/***/ }),
	/* 125 */
	/***/ (function(module, exports, __webpack_require__) {

	var strong = __webpack_require__(126);
	var validate = __webpack_require__(50);
	var MAP = 'Map';

	// 23.1 Map Objects
	module.exports = __webpack_require__(67)(MAP, function (get) {
	  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = strong.getEntry(validate(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, strong, true);


	/***/ }),
	/* 126 */
	/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(8).f;
	var create = __webpack_require__(39);
	var redefineAll = __webpack_require__(44);
	var ctx = __webpack_require__(19);
	var anInstance = __webpack_require__(42);
	var forOf = __webpack_require__(43);
	var $iterDefine = __webpack_require__(86);
	var step = __webpack_require__(121);
	var setSpecies = __webpack_require__(41);
	var DESCRIPTORS = __webpack_require__(7);
	var fastKey = __webpack_require__(32).fastKey;
	var validate = __webpack_require__(50);
	var SIZE = DESCRIPTORS ? '_s' : 'size';

	var getEntry = function (that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};

	module.exports = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._t = NAME;         // collection type
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = validate(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        validate(this, NAME);
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(validate(this, NAME), key);
	      }
	    });
	    if (DESCRIPTORS) dP(C.prototype, 'size', {
	      get: function () {
	        return validate(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function (C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function (iterated, kind) {
	      this._t = validate(iterated, NAME); // target
	      this._k = kind;                     // kind
	      this._l = undefined;                // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) entry = entry.p;
	      // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return step(0, entry.k);
	      if (kind == 'values') return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};


	/***/ }),
	/* 127 */
	/***/ (function(module, exports, __webpack_require__) {

	var strong = __webpack_require__(126);
	var validate = __webpack_require__(50);
	var SET = 'Set';

	// 23.2 Set Objects
	module.exports = __webpack_require__(67)(SET, function (get) {
	  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, strong);


	/***/ }),
	/* 128 */
	/***/ (function(module, exports, __webpack_require__) {

	var each = __webpack_require__(27)(0);
	var redefine = __webpack_require__(14);
	var meta = __webpack_require__(32);
	var assign = __webpack_require__(109);
	var weak = __webpack_require__(129);
	var isObject = __webpack_require__(4);
	var fails = __webpack_require__(3);
	var validate = __webpack_require__(50);
	var WEAK_MAP = 'WeakMap';
	var getWeak = meta.getWeak;
	var isExtensible = Object.isExtensible;
	var uncaughtFrozenStore = weak.ufstore;
	var tmp = {};
	var InternalMap;

	var wrapper = function (get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};

	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return weak.def(validate(this, WEAK_MAP), key, value);
	  }
	};

	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(67)(WEAK_MAP, wrapper, methods, weak, true, true);

	// IE11 WeakMap frozen keys fix
	if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
	  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype;
	    var method = proto[key];
	    redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (isObject(a) && !isExtensible(a)) {
	        if (!this._f) this._f = new InternalMap();
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}


	/***/ }),
	/* 129 */
	/***/ (function(module, exports, __webpack_require__) {

	var redefineAll = __webpack_require__(44);
	var getWeak = __webpack_require__(32).getWeak;
	var anObject = __webpack_require__(1);
	var isObject = __webpack_require__(4);
	var anInstance = __webpack_require__(42);
	var forOf = __webpack_require__(43);
	var createArrayMethod = __webpack_require__(27);
	var $has = __webpack_require__(12);
	var validate = __webpack_require__(50);
	var arrayFind = createArrayMethod(5);
	var arrayFindIndex = createArrayMethod(6);
	var id = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function () {
	  this.a = [];
	};
	var findUncaughtFrozen = function (store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};

	module.exports = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._t = NAME;      // collection type
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var data = getWeak(anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};


	/***/ }),
	/* 130 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/ecma262/#sec-toindex
	var toInteger = __webpack_require__(25);
	var toLength = __webpack_require__(9);
	module.exports = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};


	/***/ }),
	/* 131 */
	/***/ (function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN = __webpack_require__(40);
	var gOPS = __webpack_require__(60);
	var anObject = __webpack_require__(1);
	var Reflect = __webpack_require__(2).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
	  var keys = gOPN.f(anObject(it));
	  var getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};


	/***/ }),
	/* 132 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var isArray = __webpack_require__(61);
	var isObject = __webpack_require__(4);
	var toLength = __webpack_require__(9);
	var ctx = __webpack_require__(19);
	var IS_CONCAT_SPREADABLE = __webpack_require__(6)('isConcatSpreadable');

	function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
	  var element, spreadable;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      spreadable = false;
	      if (isObject(element)) {
	        spreadable = element[IS_CONCAT_SPREADABLE];
	        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
	      }

	      if (spreadable && depth > 0) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	}

	module.exports = flattenIntoArray;


	/***/ }),
	/* 133 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(9);
	var repeat = __webpack_require__(82);
	var defined = __webpack_require__(24);

	module.exports = function (that, maxLength, fillString, left) {
	  var S = String(defined(that));
	  var stringLength = S.length;
	  var fillStr = fillString === undefined ? ' ' : String(fillString);
	  var intMaxLength = toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') return S;
	  var fillLen = intMaxLength - stringLength;
	  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


	/***/ }),
	/* 134 */
	/***/ (function(module, exports, __webpack_require__) {

	var getKeys = __webpack_require__(37);
	var toIObject = __webpack_require__(16);
	var isEnum = __webpack_require__(53).f;
	module.exports = function (isEntries) {
	  return function (it) {
	    var O = toIObject(it);
	    var keys = getKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) if (isEnum.call(O, key = keys[i++])) {
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};


	/***/ }),
	/* 135 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(54);
	var from = __webpack_require__(136);
	module.exports = function (NAME) {
	  return function toJSON() {
	    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};


	/***/ }),
	/* 136 */
	/***/ (function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(43);

	module.exports = function (iter, ITERATOR) {
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


	/***/ }),
	/* 137 */
	/***/ (function(module, exports) {

	// https://rwaldron.github.io/proposal-math-extensions/
	module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  if (
	    arguments.length === 0
	      // eslint-disable-next-line no-self-compare
	      || x != x
	      // eslint-disable-next-line no-self-compare
	      || inLow != inLow
	      // eslint-disable-next-line no-self-compare
	      || inHigh != inHigh
	      // eslint-disable-next-line no-self-compare
	      || outLow != outLow
	      // eslint-disable-next-line no-self-compare
	      || outHigh != outHigh
	  ) return NaN;
	  if (x === Infinity || x === -Infinity) return x;
	  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
	};


	/***/ }),
	/* 138 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }

	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  var FitHost = function () {
	    function FitHost(options) {
	      _classCallCheck(this, FitHost);

	      this.DELTAP = 1e-6;
	      this.BIGVAL = 9e99;
	      this.WEIGHT = 1.0;

	      this.setYData(options.dataY);
	      this.setXData(options.dataX);
	      this.setWeight(options.weight);
	      this.setInitialParams(options.params);

	      if (options.subsetIndex) {
	        this.setSubset.apply(this, _toConsumableArray(options.subsetIndex));
	      }

	      this.setFunction(options.function);

	      if (options.progress) {
	        this.hookIteration(options.progress);
	      }

	      this.options = options;
	    }

	    //[ [ x1, y1 ], [ x2, y2 ] ]


	    _createClass(FitHost, [{
	      key: 'setYData',
	      value: function setYData(data) {
	        // Waveform instance
	        this.data = data;
	      }
	    }, {
	      key: 'setXData',
	      value: function setXData(data) {
	        // Waveform instance
	        this.dataX = data;
	      }
	    }, {
	      key: 'setWeight',
	      value: function setWeight(weight) {
	        // Waveform instance
	        this.weight = weight;
	      }
	    }, {
	      key: 'setInitialParams',
	      value: function setInitialParams(params) {
	        var _this = this;

	        this.parms = params;

	        this.parms = this.parms.map(function (el) {
	          if (typeof el == 'function') {
	            return el(_this.data, _this.dataX);
	          } else {
	            return el;
	          }
	        });
	        this.NPARMS = params.length;
	      }
	    }, {
	      key: 'setSubset',
	      value: function setSubset(fromIndex, toIndex) {
	        if (fromIndex !== undefined && toIndex !== undefined) {
	          this._from = fromIndex;
	          this._to = toIndex;
	        }
	      }
	    }, {
	      key: 'hookIteration',
	      value: function hookIteration(f) {
	        var _this2 = this;

	        this._hookIteration = function (params) {
	          var data = _this2.buildFit(params, 200);
	          f(data);
	        };
	      }
	    }, {
	      key: 'setFunction',
	      value: function setFunction(func) {
	        this._func = func;
	      }
	    }, {
	      key: 'init',
	      value: function init() {
	        var _this3 = this;

	        // Get data length
	        if (this._from !== undefined && this._to !== undefined) {

	          if (this._from >= this._to) {
	            throw 'Impossible to fit negative subranges. The starting index must be lower than the ending index';
	          }

	          this.NPTS = this._to - this._from + 1;

	          if (this.data && this.data.getLength() <= this._to) {
	            throw 'Wave Y has not enough point to be fitted to subrange [' + this._from + ', ' + this._to + ']';
	          }

	          if (this._from < 0) {
	            throw 'Impossible to fit a subrange with negative indices';
	          }
	        } else {

	          this.NPTS = this.data.getLength();
	          this._from = 0;
	          this._to = this.data.getLength() - 1;
	        }

	        if (this.dataX && this.dataX.getLength() <= this._to) {
	          throw 'Wave X has not enough point to be fitted to subrange [' + this._from + ', ' + this._to + ']';
	        }

	        this.arrY = this.data.getDataY();

	        if (this.dataX) {
	          this.arrX = this.dataX.getDataY();
	        } else {
	          this.arrX = this.data.getDataX();
	        }

	        this.resid = new Array(this.NPTS).fill(0);
	        this.jac = new Array(this.NPTS).fill(0);
	        this.jac = this.jac.map(function (el) {
	          return new Array(_this3.NPARMS);
	        });
	      }
	    }, {
	      key: 'fit',
	      value: function fit() {

	        this.log('Starting the fit with initial parameter list {' + this.parms.join() + '};');
	        new LM(this, this.NPARMS, this.NPTS, this._hookIteration);
	        this.log('Fit successful. Output parameters {' + this.parms.join() + '};');

	        this._result = this.buildFit(this.parms, 200);

	        if (this.options.done) {
	          this.options.done(this.parms, this._result);
	        }

	        return this._result;
	      }
	    }, {
	      key: 'func',
	      value: function func(x, param) {
	        return this._func(x, param);
	      }
	    }, {
	      key: 'computeResiduals',
	      value: function computeResiduals() {
	        var sumsq = 0;
	        for (var i = 0; i < this.NPTS; i++) {
	          this.resid[i] = (this.func(this.arrX[i + this._from], this.parms) - this.arrY[i + this._from]) * this.WEIGHT;
	          sumsq += this.resid[i] * this.resid[i];
	        }

	        return sumsq;
	      }
	    }, {
	      key: 'log',
	      value: function log(message) {
	        if (this.options.log) {
	          console.log(message);
	        }
	      }
	    }, {
	      key: 'nudge',
	      value: function nudge(dp) {

	        for (var j = 0; j < this.NPARMS; j++) {
	          this.parms[j] += dp[j];
	        }
	        return this.computeResiduals();
	      }
	    }, {
	      key: 'buildJacobian',
	      value: function buildJacobian() {
	        // Allows LM to compute a new Jacobian.
	        // Uses current parms[] and two-sided finite difference.
	        // If current parms[] is bad, returns false.
	        var delta = new Array(this.NPARMS);
	        var FACTOR = 0.5 / this.DELTAP;
	        var d = 0;

	        for (var j = 0; j < this.NPARMS; j++) {
	          for (var k = 0; k < this.NPARMS; k++) {
	            delta[k] = k == j ? this.DELTAP : 0.0;
	          }d = this.nudge(delta); // resid at pplus
	          if (d == this.BIGVAL) {
	            throw 'Bad dBuildJacobian() exit 2';
	          }

	          for (var i = 0; i < this.NPTS; i++) {
	            this.jac[i][j] = this.getResidualElement(i);
	          }

	          for (var k = 0; k < this.NPARMS; k++) {
	            delta[k] = k == j ? -2 * this.DELTAP : 0.0;
	          }

	          d = this.nudge(delta); // resid at pminus
	          if (d == this.BIGVAL) {
	            throw 'Bad dBuildJacobian(). exit 3';
	          }

	          for (var i = 0; i < this.NPTS; i++) {
	            this.jac[i][j] -= this.getResidualElement(i);
	          } // fetches resid[]

	          for (var i = 0; i < this.NPTS; i++) {
	            this.jac[i][j] *= FACTOR;
	          }for (var k = 0; k < this.NPARMS; k++) {
	            delta[k] = k == j ? this.DELTAP : 0.0;
	          }d = this.nudge(delta);
	          if (d == this.BIGVAL) {
	            throw 'Bad dBuildJacobian(). exit 4';
	          }
	        }
	        return true;
	      }
	    }, {
	      key: 'getResidualElement',
	      value: function getResidualElement(i) {
	        // Allows LM to see one element of the resid[] vector.
	        return this.resid[i];
	      }
	    }, {
	      key: 'getJacobianElement',
	      value: function getJacobianElement(i, j) {
	        // Allows LM to see one element of the Jacobian matrix.
	        return this.jac[i][j];
	      }
	    }, {
	      key: 'buildFit',
	      value: function buildFit(parms, length) {
	        var x = void 0;

	        if (!length) {
	          x = this.arrX;
	        } else {

	          var xmin = this.dataX.getMin(this._from, this._to);
	          var xmax = this.dataX.getMax(this._from, this._to);

	          x = new Array(length).fill(0).map(function (el, index) {
	            return index * (xmax - xmin) / (length - 1) + xmin;
	          });
	        }

	        var fit = new Array(x.length);
	        for (var i = 0, l = x.length; i < l; i++) {
	          fit[i] = this.func(x[i], this.parms);
	        }

	        var waveformResult = this.options.waveform;
	        waveformResult.setData(fit, x);
	        //waveformResult.setXWaveform( x );

	        return waveformResult;
	      }
	    }]);

	    return FitHost;
	  }();

	  var LM = function () {
	    function LM(gH, gnadj, gnpnts, hook) {
	      var _this4 = this;

	      _classCallCheck(this, LM);

	      this.LMITER = 100; // max number of L-M iterations
	      this.LMBOOST = 2.0; // damping increase per failed step
	      this.LMSHRINK = 0.10; // damping decrease per successful step
	      this.LAMBDAZERO = 0.001; // initial damping
	      this.LAMBDAMAX = 1E9; // max damping
	      this.LMTOL = 1E-12; // exit tolerance
	      this.BIGVAL = 9e99; // trouble flag

	      this.sos;
	      this.sosprev;
	      this.lambda;

	      this.myH = null; // overwritten by constructor
	      this.nadj = 0; // overwritten by constructor
	      this.npts = 0; // overwritten by constructor

	      this.delta; // local parm change
	      this.beta;
	      this.alpha;
	      this.amatrix;

	      // Constructor sets up fields and drives iterations.
	      this.myH = gH;
	      this.nadj = gnadj;
	      this.npts = gnpnts;

	      this.delta = new Array(this.nadj).fill(0);
	      this.beta = new Array(this.nadj).fill(0);

	      this.alpha = new Array(this.nadj).fill(0);
	      this.amatrix = new Array(this.nadj).fill(0);

	      this.alpha = this.alpha.map(function () {
	        return new Array(_this4.nadj);
	      });
	      this.amatrix = this.amatrix.map(function () {
	        return new Array(_this4.nadj);
	      });

	      this.lambda = this.LAMBDAZERO;

	      var niter = 0;
	      var done = false;
	      do {
	        done = this.bLMiter();

	        if (hook) {
	          hook(this.myH.params);
	        }

	        niter++;
	      } while (!done && niter < this.LMITER);
	    }

	    _createClass(LM, [{
	      key: 'bLMiter',
	      value: function bLMiter() {
	        // Each call performs one LM iteration.
	        // Returns true if done with iterations; false=wants more.
	        // Global nadj, npts; needs nadj, myH to be preset.
	        // Ref: M.Lampton, Computers in Physics v.11 pp.110-115 1997.
	        for (var k = 0; k < this.nadj; k++) {
	          this.delta[k] = 0.0;
	        }this.sos = this.myH.nudge(this.delta);
	        if (this.sos == this.BIGVAL) {
	          console.error('  bLMiter finds faulty initial nudge()');
	          return false;
	        }
	        this.sosprev = this.sos;

	        this.myH.log('  bLMiter..SumOfSquares= ' + this.sos);
	        if (!this.myH.buildJacobian()) {
	          console.error('  bLMiter finds buildJacobian()=false');
	          return false;
	        }

	        for (var k = 0; k < this.nadj; k++) // get downhill gradient beta
	        {
	          this.beta[k] = 0.0;
	          for (var i = 0; i < this.npts; i++) {
	            this.beta[k] -= this.myH.getResidualElement(i) * this.myH.getJacobianElement(i, k);
	          }
	        }

	        for (var k = 0; k < this.nadj; k++) {
	          // get curvature matrix alpha
	          for (var j = 0; j < this.nadj; j++) {
	            this.alpha[j][k] = 0.0;
	            for (var i = 0; i < this.npts; i++) {
	              this.alpha[j][k] += this.myH.getJacobianElement(i, j) * this.myH.getJacobianElement(i, k);
	            }
	          }
	        }var rrise = 0;
	        do // inner damping loop searches for one downhill step
	        {
	          for (var k = 0; k < this.nadj; k++) {
	            // copy and damp it
	            for (var j = 0; j < this.nadj; j++) {
	              this.amatrix[j][k] = this.alpha[j][k] + (j == k ? this.lambda : 0.0);
	            }
	          }

	          this.gaussj(this.amatrix, this.nadj); // invert

	          for (var k = 0; k < this.nadj; k++) // compute delta[]
	          {
	            this.delta[k] = 0.0;
	            for (var j = 0; j < this.nadj; j++) {
	              this.delta[k] += this.amatrix[j][k] * this.beta[j];
	            }
	          }
	          this.sos = this.myH.nudge(this.delta); // try it out.
	          if (this.sos == this.BIGVAL) {
	            console.error('  LMinner failed SOS step');
	            return false;
	          }
	          rrise = (this.sos - this.sosprev) / (1 + this.sos);
	          if (rrise <= 0.0) // good step!
	            {
	              this.lambda *= this.LMSHRINK; // shrink lambda
	              break; // leave lmInner.
	            }
	          for (var q = 0; q < this.nadj; q++) {
	            // reverse course!
	            this.delta[q] *= -1.0;
	          }
	          this.myH.nudge(this.delta); // sosprev should still be OK
	          if (rrise < this.LMTOL) {
	            // finished but keep prev parms
	            break; // leave inner loop
	          }
	          this.lambda *= this.LMBOOST; // else try more damping.
	        } while (this.lambda < this.LAMBDAMAX);
	        return rrise > -this.LMTOL || this.lambda > this.LAMBDAMAX;
	      }
	    }, {
	      key: 'gaussj',
	      value: function gaussj(a, N) {
	        // Inverts the double array a[N][N] by Gauss-Jordan method
	        // M.Lampton UCB SSL (c)2003, 2005

	        var det = 1.0,
	            big,
	            save;
	        var i, j, k, L;
	        var ik = new Array(100);
	        var jk = new Array(100);

	        for (k = 0; k < N; k++) {
	          big = 0.0;
	          for (i = k; i < N; i++) {
	            for (j = k; j < N; j++) {
	              // find biggest element
	              if (Math.abs(big) <= Math.abs(a[i][j])) {
	                big = a[i][j];
	                ik[k] = i;
	                jk[k] = j;
	              }
	            }
	          }if (big == 0.0) return 0.0;
	          i = ik[k];
	          if (i > k) for (j = 0; j < N; j++) // exchange rows
	          {
	            save = a[k][j];
	            a[k][j] = a[i][j];
	            a[i][j] = -save;
	          }
	          j = jk[k];
	          if (j > k) for (i = 0; i < N; i++) {
	            save = a[i][k];
	            a[i][k] = a[i][j];
	            a[i][j] = -save;
	          }
	          for (i = 0; i < N; i++) {
	            // build the inverse
	            if (i != k) a[i][k] = -a[i][k] / big;
	          }for (i = 0; i < N; i++) {
	            for (j = 0; j < N; j++) {
	              if (i != k && j != k) a[i][j] += a[i][k] * a[k][j];
	            }
	          }for (j = 0; j < N; j++) {
	            if (j != k) a[k][j] /= big;
	          }a[k][k] = 1.0 / big;
	          det *= big; // bomb point
	        } // end k loop
	        for (L = 0; L < N; L++) {
	          k = N - L - 1;
	          j = ik[k];
	          if (j > k) for (i = 0; i < N; i++) {
	            save = a[i][k];
	            a[i][k] = -a[i][j];
	            a[i][j] = save;
	          }
	          i = jk[k];
	          if (i > k) for (j = 0; j < N; j++) {
	            save = a[k][j];
	            a[k][j] = -a[i][j];
	            a[i][j] = save;
	          }
	        }
	        return det;
	      }
	    }]);

	    return LM;
	  }();

	  exports.default = FitHost;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 139 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(72)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphAxis) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphAxis2 = _interopRequireDefault(_graphAxis);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var AxisY = function (_Axis) {
	    _inherits(AxisY, _Axis);

	    function AxisY(graph, leftright, options) {
	      _classCallCheck(this, AxisY);

	      var _this = _possibleConstructorReturn(this, (AxisY.__proto__ || Object.getPrototypeOf(AxisY)).call(this, graph, leftright, options));

	      _this.leftright = leftright;
	      _this.left = leftright == 'left';

	      return _this;
	    }

	    /**
	     *  @private
	     */


	    _createClass(AxisY, [{
	      key: 'setAxisPosition',
	      value: function setAxisPosition(shift) {
	        this.shiftPosition = shift;
	      }
	    }, {
	      key: 'getAxisPosition',
	      value: function getAxisPosition() {
	        return this.shiftPosition || 0;
	      }
	    }, {
	      key: 'getAdditionalWidth',
	      value: function getAdditionalWidth() {
	        var pos = 0;
	        if (this.getLabel()) {
	          pos += this.graph.options.fontSize;
	        }

	        if (this.isShown()) {
	          pos += Math.abs(this.tickMargin);
	        }
	        return pos;
	      }
	    }, {
	      key: 'isX',
	      value: function isX() {
	        return false;
	      }
	    }, {
	      key: 'isY',
	      value: function isY() {
	        return true;
	      }
	    }, {
	      key: 'resetTicksLength',
	      value: function resetTicksLength() {
	        this.longestTick = [false, 0];
	      }
	    }, {
	      key: 'getMaxSizeTick',
	      value: function getMaxSizeTick() {
	        // Gives an extra margin of 5px
	        return this.longestTick && this.longestTick[0] ? this.longestTick[0].getComputedTextLength() + 5 : 0; //(this.left ? 10 : 0);
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {

	        this.tickMargin = this.left ? -5 - this.tickPx1 * this.tickScaling[1] : 2 - this.tickPx1 * this.tickScaling[1];
	        var tickWidth = _get(AxisY.prototype.__proto__ || Object.getPrototypeOf(AxisY.prototype), 'draw', this).apply(this, arguments);
	        tickWidth += this.getAdditionalWidth();
	        this.drawSpecifics(tickWidth);

	        this.fullwidthlabel = tickWidth;

	        return tickWidth;
	      }
	    }, {
	      key: 'equalizePosition',
	      value: function equalizePosition(width) {

	        this.placeLabel(this.left ? -width : width);

	        if (this.getLabel()) {
	          return width + this.graph.options.fontSize;
	        }

	        return 0;
	      }
	    }, {
	      key: 'drawTick',
	      value: function drawTick(value, level, options, forcedPos) {
	        var _this2 = this;

	        var pos = void 0,
	            tick = void 0,
	            tickLabel = void 0;

	        pos = forcedPos || this.getPos(value);

	        if (pos == undefined || isNaN(pos)) {
	          return;
	        }

	        tick = this.nextTick(level, function (tick) {

	          tick.setAttribute('x1', (_this2.left ? 1 : -1) * _this2.tickPx1 * _this2.tickScaling[level]);
	          tick.setAttribute('x2', (_this2.left ? 1 : -1) * _this2.tickPx2 * _this2.tickScaling[level]);

	          if (level == 1) {
	            tick.setAttribute('stroke', _this2.getPrimaryTicksColor());
	          } else {
	            tick.setAttribute('stroke', _this2.getSecondaryTicksColor());
	          }
	        });

	        tick.setAttribute('y1', pos);
	        tick.setAttribute('y2', pos);

	        this.nextGridLine(level == 1, 0, this.graph.getDrawingWidth(), pos, pos);

	        //  this.groupTicks.appendChild( tick );
	        if (level == 1) {
	          tickLabel = this.nextTickLabel(function (tickLabel) {

	            tickLabel.setAttribute('x', _this2.tickMargin + _this2.options.tickLabelOffset);
	            if (_this2.getTicksLabelColor() !== 'black') {
	              tickLabel.setAttribute('fill', _this2.getTicksLabelColor());
	            }

	            if (_this2.left) {
	              tickLabel.setAttribute('text-anchor', 'end');
	            } else {
	              tickLabel.setAttribute('text-anchor', 'start');
	            }
	            tickLabel.style.dominantBaseline = 'central';
	          });

	          tickLabel.setAttribute('y', pos);
	          this.setTickContent(tickLabel, value, options);

	          if (String(tickLabel.textContent).length >= this.longestTick[1]) {
	            this.longestTick[0] = tickLabel;
	            this.longestTick[1] = String(tickLabel.textContent).length;
	          }
	        }
	      }
	    }, {
	      key: 'drawLabel',
	      value: function drawLabel() {

	        if (this.getLabelColor() !== 'black') {
	          this.label.setAttribute('fill', this.getLabelColor());
	        }

	        this.label.setAttribute('dominant-baseline', !this.left ? 'auto' : 'auto');
	        this.labelTspan.textContent = this.getLabel();
	      }
	    }, {
	      key: 'placeLabel',
	      value: function placeLabel(y) {
	        this.label.setAttribute('transform', 'translate(' + y + ', ' + Math.abs(this.getMaxPx() + this.getMinPx()) / 2 + ') rotate(-90)');
	      }
	    }, {
	      key: 'drawSpecifics',
	      value: function drawSpecifics() {
	        // Place label correctly
	        //this.label.setAttribute('x', (this.getMaxPx() - this.getMinPx()) / 2);
	        /*
	        if ( !this.left ) {
	           this.labelTspan.style.dominantBaseline = 'hanging';
	          this.expTspan.style.dominantBaseline = 'hanging';
	          this.expTspanExp.style.dominantBaseline = 'hanging';
	           this.unitTspan.style.dominantBaseline = 'hanging';
	          this.preunitTspan.style.dominantBaseline = 'hanging';
	        }
	        */
	        this.line.setAttribute('y1', this.getMinPx());
	        this.line.setAttribute('y2', this.getMaxPx());
	        this.line.setAttribute('x1', 0);
	        this.line.setAttribute('x2', 0);

	        this.line.setAttribute('stroke', this.getAxisColor());

	        var span = this.getSpan();
	        this.line.setAttribute('marker-start', !this.options.splitMarks || span[0] == 0 ? '' : 'url(#verticalsplit_' + this.graph.getId() + ')');
	        this.line.setAttribute('marker-end', !this.options.splitMarks || span[1] == 1 ? '' : 'url(#verticalsplit_' + this.graph.getId() + ')');
	      }
	    }, {
	      key: 'setShift',
	      value: function setShift(shift) {

	        this.shift = shift;

	        if (!this.shift || !this.graph.getWidth()) {
	          return;
	        }

	        var xshift = this.shift;
	        xshift = this.floating ? xshift : this.isLeft() ? xshift : this.graph.getWidth() - this.graph.getPaddingRight() - this.graph.getPaddingLeft() - xshift;
	        this.group.setAttribute('transform', 'translate( ' + xshift + ' 0 )');
	        this.drawLabel();
	      }
	    }, {
	      key: 'isLeft',
	      value: function isLeft() {
	        return this.left;
	      }
	    }, {
	      key: 'isRight',
	      value: function isRight() {
	        return !this.left;
	      }
	    }, {
	      key: 'isFlipped',
	      value: function isFlipped() {
	        return !this.options.flipped;
	      }
	    }, {
	      key: '_drawLine',
	      value: function _drawLine(pos, line) {

	        var px = this.getPx(pos);

	        if (!line) {
	          line = document.createElementNS(this.graph.ns, 'line');
	        } else {
	          line.setAttribute('display', 'initial');
	        }

	        line.setAttribute('y1', px);
	        line.setAttribute('y2', px);

	        line.setAttribute('x1', 0);
	        line.setAttribute('x2', this.graph.drawingSpaceWidth);

	        line.setAttribute('stroke', 'black');
	        this.group.appendChild(line);

	        return line;
	      }
	    }, {
	      key: '_hideLine',
	      value: function _hideLine(line) {
	        if (!line) {
	          return;
	        }

	        line.setAttribute('display', 'none');
	      }
	    }, {
	      key: 'handleMouseMoveLocal',
	      value: function handleMouseMoveLocal(x, y) {
	        y -= this.graph.getPaddingTop();
	        this.mouseVal = this.getVal(y);
	      }
	    }, {
	      key: 'scaleToFitAxis',
	      value: function scaleToFitAxis(axis, excludeSerie, start, end, min, max) {
	        //console.log( axis instanceof GraphAxis );
	        if (!axis || !axis.isX()) {
	          axis = this.graph.getXAxis();
	        }

	        if (isNaN(start)) {
	          start = axis.getCurrentMin();
	        }

	        if (isNaN(end)) {
	          end = axis.getCurrentMax();
	        }

	        if (min === undefined) {
	          min = true;
	        }

	        if (max === undefined) {
	          max = true;
	        }

	        if (typeof excludeSerie == 'number') {
	          end = start;
	          start = excludeSerie;
	          excludeSerie = false;
	        }

	        var maxV = -Infinity,
	            minV = Infinity,
	            j = 0;

	        for (var i = 0, l = this.graph.series.length; i < l; i++) {

	          if (!this.graph.series[i].isShown()) {
	            continue;
	          }

	          if (this.graph.series[i] == excludeSerie) {
	            continue;
	          }

	          if (!(this.graph.series[i].getXAxis() == axis) || this.graph.series[i].getYAxis() !== this) {
	            continue;
	          }

	          j++;

	          maxV = max ? Math.max(maxV, this.graph.series[i].getMax(start, end)) : 0;
	          minV = min ? Math.min(minV, this.graph.series[i].getMin(start, end)) : 0;
	        }

	        if (j == 0) {

	          this.setMinMaxToFitSeries(); // No point was found
	        } else {

	          // If we wanted originally to resize min and max. Otherwise we use the current value
	          minV = min ? minV : this.getCurrentMin();
	          maxV = max ? maxV : this.getCurrentMax();

	          var interval = maxV - minV;

	          minV -= this.options.axisDataSpacing.min * interval;
	          maxV += this.options.axisDataSpacing.max * interval;

	          this._doZoomVal(minV, maxV);
	        }

	        return this;
	      }
	    }, {
	      key: 'setMinMaxFlipped',
	      value: function setMinMaxFlipped() {

	        var interval = this.maxPx - this.minPx;

	        if (isNaN(interval)) {
	          return;
	        }

	        var maxPx = this.maxPx - interval * this.options.span[0] - this.options.marginMin;
	        var minPx = this.maxPx - interval * this.options.span[1] + this.options.marginMax;

	        this.minPxFlipped = this.isFlipped() ? maxPx : minPx;
	        this.maxPxFlipped = this.isFlipped() ? minPx : maxPx;
	      }
	    }, {
	      key: 'getZProj',
	      value: function getZProj(zValue) {
	        return zValue * this.graph.options.zAxis.shiftY;
	      }
	    }]);

	    return AxisY;
	  }(_graphAxis2.default);

	  exports.default = AxisY;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 140 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  var Serie3DMixin = {

	    /**
	     * Returns the x position of a certain value in pixels position, based on the serie's axis
	     * @memberof Serie
	     * @param {Number} val - Value to convert to pixels position
	     * @returns {Number} The x position in px corresponding to the x value
	     */
	    getX: function getX(val) {
	      return (val = this.getXAxis().getPx(val)) - val % 0.2 + this.getXAxis().getZProj(this.options.zpos);
	    },

	    /**
	     * Returns the y position of a certain value in pixels position, based on the serie's axis
	     * @memberof Serie3DMixin
	     * @param {Number} val - Value to convert to pixels position
	     * @returns {Number} The y position in px corresponding to the y value
	     */
	    getY: function getY(val) {
	      return (val = this.getYAxis().getPx(val)) - val % 0.2 + this.getYAxis().getZProj(this.options.zpos);
	    },

	    getZPos: function getZPos() {
	      return this.options.zpos;
	    },

	    /**
	     * @returns {Number} Lowest x value of the serie's data
	     * @memberof Serie
	     */
	    getMinX: function getMinX(useZValues) {
	      if (!useZValues) {
	        return this.minX;
	      }

	      return getZCorrectedValue(this, true, true);
	    },

	    /**
	     * @returns {Number} Highest x value of the serie's data
	     * @memberof Serie
	     */
	    getMaxX: function getMaxX(useZValues) {

	      if (!useZValues) {
	        return this.maxX;
	      }
	      return getZCorrectedValue(this, true, false);
	    },

	    /**
	     * @returns {Number} Lowest y value of the serie's data
	     * @memberof Serie
	     */
	    getMinY: function getMinY(useZValues) {

	      if (!useZValues) {
	        return this.minY;
	      }
	      return getZCorrectedValue(this, false, true);
	    },

	    /**
	     * @returns {Number} Highest y value of the serie's data
	     * @memberof Serie
	     */
	    getMaxY: function getMaxY(useZValues) {

	      if (!useZValues) {
	        return this.maxY;
	      }
	      return getZCorrectedValue(this, false, false);
	    }

	  };

	  function getZCorrectedValue(serie, x, min) {

	    var i = void 0,
	        l = void 0,
	        data = void 0,
	        val = void 0,
	        valFinal = void 0;
	    var wf = serie.getWaveforms();

	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = wf[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var wave = _step.value;


	        i = 0;
	        l = wave.getLength();
	        data = wave.getData();

	        for (; i < l; i += 1) {

	          if (x) {
	            val = serie.getXAxis().getVal(serie.getX(wave.getX(i, true)));
	          } else {
	            val = serie.getYAxis().getVal(serie.getY(data[i]));
	          }

	          if (i == 0) {
	            valFinal = val;
	          } else {

	            if (min) {
	              valFinal = Math.min(valFinal, val);
	            } else {
	              valFinal = Math.max(valFinal, val);
	            }
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    return valFinal;
	  }

	  exports.default = Serie3DMixin;
	  module.exports = exports["default"];
	});

	/***/ }),
	/* 141 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(57), __webpack_require__(5), __webpack_require__(73)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphSerie, _graphUtil, _graphMixinErrorbars) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphSerie2 = _interopRequireDefault(_graphSerie);

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphMixinErrorbars2 = _interopRequireDefault(_graphMixinErrorbars);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var type = 'scatter';

	  /**
	   * @static
	   * @augments Serie
	   * @example graph.newSerie( name, options, "scatter" );
	   * @see Graph#newSerie
	   */

	  var SerieScatter = function (_Serie) {
	    _inherits(SerieScatter, _Serie);

	    function SerieScatter(graph, name, options) {
	      _classCallCheck(this, SerieScatter);

	      var _this = _possibleConstructorReturn(this, (SerieScatter.__proto__ || Object.getPrototypeOf(SerieScatter)).apply(this, arguments));

	      _this.id = Math.random() + Date.now();
	      _this.shapes = []; // Stores all shapes
	      _this.shown = true;
	      _this.data = [];

	      _this.shapesDetails = [];
	      _this.shapes = [];

	      _this._type = type;

	      util.mapEventEmission(_this.options, _this);

	      _this._isMinOrMax = {
	        x: {
	          min: false,
	          max: false
	        },
	        y: {
	          min: false,
	          max: false
	        }
	      };

	      _this.groupPoints = document.createElementNS(_this.graph.ns, 'g');
	      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');

	      _this.additionalData = {};

	      _this.selectedStyleGeneral = {};
	      _this.selectedStyleModifiers = {};

	      _this.groupPoints.addEventListener('mouseover', function (e) {
	        var id = parseInt(e.target.parentElement.getAttribute('data-shapeid'));
	        _this.emit('mouseover', id, _this.waveform.getX(id), _this.waveform.getY(id));
	      });

	      _this.groupPoints.addEventListener('mouseout', function (e) {
	        var id = parseInt(e.target.parentElement.getAttribute('data-shapeid'));
	        _this.emit('mouseout', id, _this.waveform.getX(id), _this.waveform.getY(id));
	      });

	      _this.minX = Number.MAX_VALUE;
	      _this.minY = Number.MAX_VALUE;
	      _this.maxX = Number.MIN_VALUE;
	      _this.maxY = Number.MIN_VALUE;

	      _this.groupMain.appendChild(_this.groupPoints);
	      _this.currentAction = false;

	      if (_this.initExtended1) {
	        _this.initExtended1();
	      }

	      _this.styles = {};
	      _this.styles.unselected = {};
	      _this.styles.selected = {};

	      _this.styles.unselected.default = {
	        shape: 'circle',
	        cx: 0,
	        cy: 0,
	        r: 3,
	        stroke: 'transparent',
	        fill: 'black'
	      };

	      _this.styles.selected.default = {
	        shape: 'circle',
	        cx: 0,
	        cy: 0,
	        r: 4,
	        stroke: 'transparent',
	        fill: 'black'
	      };

	      return _this;
	    }

	    /**
	     * Applies for x as the category axis
	     * @example serie.setDataCategory( { x: "someName", y: Waveform } );
	     */


	    _createClass(SerieScatter, [{
	      key: 'setDataCategory',
	      value: function setDataCategory(data) {

	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var dataCategory = _step.value;


	            this._checkY(dataCategory.y.getMaxY());
	            this._checkY(dataCategory.y.getMinY());
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }

	        this.data = data;
	        this.dataHasChanged();
	        this.graph.updateDataMinMaxAxes();
	        return this;
	      }
	    }, {
	      key: 'empty',
	      value: function empty() {

	        while (this.groupPoints.firstChild) {
	          this.groupPoints.removeChild(this.groupPoints.firstChild);
	        }
	      }
	    }, {
	      key: 'getSymbolForLegend',
	      value: function getSymbolForLegend() {

	        if (this.symbol) {
	          return this.symbol;
	        }

	        var g = document.createElementNS(this.graph.ns, 'g');
	        g.setAttribute('data-shapeid', -1);
	        var shape = this.doShape(g, this.styles.unselected.default);

	        var style = this.getStyle('unselected', -1, true);

	        for (var i in style[-1]) {
	          if (i == 'shape') {
	            continue;
	          }
	          shape.setAttribute(i, style[-1][i]);
	        }

	        return g;
	      }
	    }, {
	      key: 'setStyle',
	      value: function setStyle(all, modifiers) {
	        var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unselected';


	        if (typeof modifiers == 'string') {
	          mode = modifiers;
	          modifiers = false;
	        }

	        /*
	        if( ! this.styles[ mode ] ) {
	         }
	         if ( mode !== "selected" && mode !== "unselected" ) {
	          throw "Style mode is not correct. Should be selected or unselected";
	        }
	        */

	        this.styles[mode] = this.styles[mode] || {};
	        this.styles[mode].all = all;
	        this.styles[mode].modifiers = modifiers;

	        this.styleHasChanged(mode);

	        return this;
	      }
	    }, {
	      key: 'draw',
	      value: function draw(force) {
	        // Serie redrawing

	        if (!force && !this.hasDataChanged() && !this.hasStyleChanged('unselected')) {
	          return;
	        }

	        var xpx,
	            ypx,
	            j = 0;

	        var isCategory = this.getXAxis().getType() == 'category';

	        this._drawn = true;

	        this.dataHasChanged(false);
	        this.styleHasChanged(false);
	        this.groupMain.removeChild(this.groupPoints);

	        var keys = [];

	        j = 0;

	        if (this.hasErrors()) {
	          this.errorDrawInit();
	        }

	        if (isCategory) {

	          var _k = 0;

	          for (; j < this.data.length; j++) {

	            if (!this.categoryIndices.hasOwnProperty(this.data[j].x)) {
	              continue;
	            }

	            if (this.error) ;

	            for (var n = 0, l = this.data[j].y.getLength(); n < l; n++) {

	              //let xpos = i / ( l - 1 ) * ( position[ 1 ] ) + position[ 0 ];

	              ypx = this.getY(this.data[j].y.getY(n));
	              xpx = this.getX(n / (l - 1) * (0.8 / this.nbCategories) + this.categoryIndices[this.data[j].x] + 0.1 / this.nbCategories);
	              n++;

	              this.shapesDetails[_k] = this.shapesDetails[_k] || [];
	              this.shapesDetails[_k][0] = xpx;
	              this.shapesDetails[_k][1] = ypx;
	              keys.push(_k);
	              _k++;
	            }
	          }
	        } else {

	          for (; j < this.waveform.getLength(); j++) {

	            if (this.waveform.getX(j) < this.getXAxis().getCurrentMin() || this.waveform.getX(j) > this.getXAxis().getCurrentMax() || this.waveform.getY(j) < this.getYAxis().getCurrentMin() || this.waveform.getY(j) > this.getYAxis().getCurrentMax()) {

	              if (this.shapes[j]) {
	                this.shapes[j].setAttribute('display', 'none');
	              }
	              continue;
	            }

	            if (this.shapes[j]) {
	              this.shapes[j].setAttribute('display', 'initial');
	            }

	            xpx = this.getX(this.waveform.getX(j));
	            ypx = this.getY(this.waveform.getY(j));

	            if (this.hasErrors()) {
	              this.errorAddPoint(j, this.waveform.getX(j), this.waveform.getY(j), xpx, ypx);
	            }

	            this.shapesDetails[j] = this.shapesDetails[j] || [];
	            this.shapesDetails[j][0] = xpx;
	            this.shapesDetails[j][1] = ypx;
	            keys.push(j);

	            //this.shapes[ j / 2 ] = this.shapes[ j / 2 ] || undefined;
	          }
	        }

	        if (this.hasErrors()) {
	          this.errorDraw();
	        }

	        // This will automatically create the shapes
	        this.applyStyle('unselected', keys);

	        this.groupMain.appendChild(this.groupPoints);
	      }
	    }, {
	      key: '_addPoint',
	      value: function _addPoint(xpx, ypx, k) {

	        var shape = void 0;
	        var g = document.createElementNS(this.graph.ns, 'g');
	        g.setAttribute('transform', 'translate(' + xpx + ', ' + ypx + ')');
	        g.setAttribute('data-shapeid', k);

	        if (this.extraStyle && this.extraStyle[k]) {

	          shape = this.doShape(g, this.extraStyle[k]);
	        } else if (this.stdStylePerso) {

	          shape = this.doShape(g, this.stdStylePerso);
	        } else {

	          shape = this.doShape(g, this.stdStyle);
	        }

	        this.shapes[k] = shape;
	        this.groupPoints.appendChild(g);
	      }
	    }, {
	      key: 'doShape',
	      value: function doShape(group, shape) {
	        var el = document.createElementNS(this.graph.ns, shape.shape);
	        group.appendChild(el);
	        return el;
	      }
	    }, {
	      key: 'getStyle',
	      value: function getStyle(selection, index, noSetPosition) {

	        var selection = selection || 'unselected';
	        var indices;

	        var styles = {};

	        if (typeof index == 'number') {
	          indices = [index];
	        } else if (Array.isArray(index)) {
	          indices = index;
	        }

	        var shape, index, modifier, style; // loop variables
	        var styleAll;

	        if (this.styles[selection].all !== undefined) {

	          styleAll = this.styles[selection].all;

	          if (typeof styleAll == 'function') {

	            styleAll = styleAll();
	          } else if (styleAll === false) {

	            styleAll = {};
	          }
	        }

	        var i = 0,
	            l = indices.length;

	        for (; i < l; i++) {

	          index = indices[i];
	          shape = this.shapes[index];

	          if ((modifier = this.styles[selection].modifiers) && (typeof modifier == 'function' || modifier[index])) {

	            if (typeof modifier == 'function') {

	              style = modifier(index, shape);
	            } else if (modifier[index]) {

	              style = modifier[index];
	            }

	            styles[index] = Object.assign({}, styleAll, style);
	          } else if (styleAll !== undefined) {

	            styles[index] = styleAll;
	          } else {

	            styles[index] = this.styles[selection].default;
	          }

	          if (!styles[index]) {
	            styles[index] = styleAll;
	          }

	          if (!shape) {
	            // Shape doesn't exist, let's create it

	            if (!styles[index].shape) {
	              console.error(style);
	              throw 'No shape was defined with this style.';
	            }

	            var g = document.createElementNS(this.graph.ns, 'g');
	            g.setAttribute('data-shapeid', index);
	            this.shapes[index] = this.doShape(g, styles[index]);
	            this.groupPoints.appendChild(g);
	            shape = this.shapes[index];
	          }

	          if (!noSetPosition) {
	            shape.parentNode.setAttribute('transform', 'translate(' + this.shapesDetails[index][0] + ', ' + this.shapesDetails[index][1] + ')');
	          }
	        }

	        return styles;
	      }
	    }, {
	      key: 'applyStyle',
	      value: function applyStyle(selection, index, noSetPosition) {

	        var i, j;
	        var styles = this.getStyle(selection, index, noSetPosition);

	        for (i in styles) {

	          for (j in styles[i]) {

	            if (j !== 'shape') {

	              if (styles[i][j]) {

	                this.shapes[i].setAttribute(j, styles[i][j]);
	              } else {

	                this.shapes[i].removeAttribute(j);
	              }
	            }
	          }
	        }
	      }
	    }, {
	      key: 'unselectPoint',
	      value: function unselectPoint(index) {
	        this.selectPoint(index, false);
	      }
	    }, {
	      key: 'selectPoint',
	      value: function selectPoint(index, setOn, selectionType) {

	        if (this.shapesDetails[index][2] && this.shapesDetails[index][2] == selectionType) {
	          return;
	        }

	        if (typeof setOn == 'string') {
	          selectionType = setOn;
	          setOn = undefined;
	        }

	        if (Array.isArray(index)) {
	          return this.selectPoints(index);
	        }

	        if (this.shapes[index] && this.shapesDetails[index]) {

	          if ((this.shapesDetails[index][2] || setOn === false) && setOn !== true) {

	            var selectionStyle = this.shapesDetails[index][2];
	            this.shapesDetails[index][2] = false;

	            var allStyles = this.getStyle(selectionStyle, index, true);
	            for (var i in allStyles[index]) {
	              this.shapes[index].removeAttribute(i);
	            }

	            this.applyStyle('unselected', index, true);
	          } else {

	            selectionType = selectionType || 'selected';
	            this.shapesDetails[index][2] = selectionType;

	            this.applyStyle(selectionType, index, true);
	          }
	        }
	      }
	    }, {
	      key: 'getUsedCategories',
	      value: function getUsedCategories() {

	        if (_typeof(this.data[0]) == 'object') {
	          return this.data.map(function (d) {
	            return d.x;
	          });
	        }

	        return [];
	      }
	    }]);

	    return SerieScatter;
	  }(_graphSerie2.default);

	  util.mix(SerieScatter, _graphMixinErrorbars2.default);

	  exports.default = SerieScatter;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 142 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(57), __webpack_require__(46), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphSerie, _waveform, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphSerie2 = _interopRequireDefault(_graphSerie);

	  var _waveform2 = _interopRequireDefault(_waveform);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieZone = function (_Serie) {
	    _inherits(SerieZone, _Serie);

	    _createClass(SerieZone, null, [{
	      key: 'default',
	      value: function _default() {
	        return {
	          fillColor: 'rgba( 0, 0, 0, 0.1 )',
	          lineColor: 'rgba( 0, 0, 0, 1 )',
	          lineWidth: '1px'
	        };
	      }
	    }]);

	    function SerieZone(graph, name, options) {
	      _classCallCheck(this, SerieZone);

	      var _this = _possibleConstructorReturn(this, (SerieZone.__proto__ || Object.getPrototypeOf(SerieZone)).apply(this, arguments));

	      _this.selectionType = 'unselected';
	      _this.id = (0, _graphUtil.guid)();

	      _this.groupZones = document.createElementNS(_this.graph.ns, 'g');
	      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');
	      _this.lineZone = document.createElementNS(_this.graph.ns, 'path');
	      _this.lineZone.setAttribute('stroke', 'black');
	      _this.lineZone.setAttribute('stroke-width', '1px');

	      _this.groupMain.appendChild(_this.groupZones);
	      _this.groupZones.appendChild(_this.lineZone);

	      _this.applyLineStyle(_this.lineZone);
	      _this.styleHasChanged();

	      _this.clip = document.createElementNS(_this.graph.ns, 'clipPath');
	      _this.clipId = (0, _graphUtil.guid)();
	      _this.clip.setAttribute('id', _this.clipId);

	      _this.graph.defs.appendChild(_this.clip);

	      return _this;
	    }

	    /**
	     * Assigns a collection of waveforms that make up the zone
	     * The waveforms will appended one after the other, without break
	     * @param {...Waveform} waveforms - The collection of waveforms
	     * @return {SerieZone} - The current serie zone instance
	     * @memberof SerieZone
	     */


	    _createClass(SerieZone, [{
	      key: 'setWaveform',
	      value: function setWaveform() {
	        var _this2 = this;

	        for (var _len = arguments.length, waveforms = Array(_len), _key = 0; _key < _len; _key++) {
	          waveforms[_key] = arguments[_key];
	        }

	        this.waveforms = waveforms;

	        this.waveforms = this.waveforms.map(function (wave) {

	          if (!(wave instanceof _waveform2.default)) {
	            return new _waveform2.default(wave);
	          } else {
	            return wave;
	          }
	        });

	        this.minX = this.waveforms[0].getXMin();
	        this.maxX = this.waveforms[0].getXMax();
	        this.minY = this.waveforms[0].getMin();
	        this.maxY = this.waveforms[0].getMax();

	        this.waveforms.map(function (wave) {

	          _this2.minX = Math.min(wave.getXMin(), _this2.minX);
	          _this2.maxX = Math.max(wave.getXMin(), _this2.maxX);
	          _this2.minY = Math.min(wave.getMin(), _this2.minY);
	          _this2.maxY = Math.max(wave.getMax(), _this2.maxY);
	        });

	        this.graph.updateDataMinMaxAxes();
	        this.dataHasChanged();
	        return this;
	      }
	    }, {
	      key: 'setWaveforms',
	      value: function setWaveforms() {
	        return this.setWaveform.apply(this, arguments);
	      }
	    }, {
	      key: 'getWaveforms',
	      value: function getWaveforms() {
	        return this.waveforms;
	      }
	    }, {
	      key: 'setMinMaxWaveforms',
	      value: function setMinMaxWaveforms(min, max) {
	        this.waveforms = [min, max.reverse()];
	        return this;
	      }
	    }, {
	      key: 'empty',
	      value: function empty() {

	        while (this.group.firstChild) {
	          this.group.removeChild(this.group.firstChild);
	        }
	      }
	    }, {
	      key: 'draw',
	      value: function draw(force) {
	        // Serie redrawing

	        if (force || this.hasDataChanged()) {

	          if (!this.waveforms) {
	            return;
	          }

	          var dataX = 0,
	              dataY = 0,
	              xpx = 0,
	              ypx = 0,
	              j = 0,
	              line = '',
	              buffer = void 0,
	              move = false;

	          var xminpx = this.getXAxis().getMinPx(),
	              xmaxpx = this.getXAxis().getMaxPx(),
	              yminpx = this.getYAxis().getMinPx(),
	              ymaxpx = this.getYAxis().getMaxPx();

	          var xmin = this.getXAxis().getCurrentMin(),
	              xmax = this.getXAxis().getCurrentMax(),
	              ymin = this.getYAxis().getCurrentMin(),
	              ymax = this.getYAxis().getCurrentMax();

	          //this.clipRect.setAttribute( "x", Math.min( xmin, xmax ) );
	          //this.clipRect.setAttribute( "y", Math.min( ymin, ymax ) );
	          //this.clipRect.setAttribute( "width", Math.abs( xmax - xmin ) );
	          //this.clipRect.setAttribute( "height", Math.abs( ymax - ymin ) );

	          this.groupMain.removeChild(this.groupZones);

	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;

	          try {
	            for (var _iterator = this.waveforms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var waveform = _step.value;


	              for (j = 0; j < waveform.getLength(); j += 1) {
	                dataX = waveform.getX(j, true);
	                dataY = waveform.getY(j, true);

	                // The y axis in screen coordinate is inverted vs cartesians
	                if (dataY[j] < ymin) {
	                  ypx = this.getY(ymin);
	                } else if (dataY[j] > ymax) {
	                  ypx = this.getY(ymax);
	                }

	                if (dataX !== dataX) {
	                  continue;
	                }

	                if (dataY !== dataY) {
	                  // Let's make a new line

	                  if (line.length == 0) {
	                    continue;
	                  }

	                  line += 'L ' + xpx + ', ' + this.getY(waveform.getMinY());
	                  move = true;
	                  continue;
	                }

	                ypx = this.getY(dataY);
	                xpx = this.getX(dataX);

	                if (dataX < xmin || dataX > xmax) {
	                  buffer = [dataX, dataY[j], xpx, ypx];
	                  continue;
	                }

	                if (move) {
	                  line += ' M ' + xpx + ', ' + this.getY(waveform.getMinY()) + ' ';
	                  move = false;
	                }

	                if (line.length > 0) {
	                  line += ' L ';
	                }

	                if (buffer) {
	                  line += buffer[2] + ',' + buffer[3] + ' ';
	                  buffer = false;
	                } else {
	                  line += xpx + ',' + ypx + ' ';
	                }
	              }
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }

	          if (line !== '') {
	            this.lineZone.setAttribute('d', 'M ' + line + ' z');
	          } else {
	            this.lineZone.setAttribute('d', '');
	          }
	          this.groupMain.appendChild(this.groupZones);
	        }

	        if (this.hasStyleChanged(this.selectionType)) {
	          this.applyLineStyle(this.lineZone);
	          this.styleHasChanged(false);
	        }
	      }
	    }, {
	      key: 'applyLineStyle',
	      value: function applyLineStyle(line) {

	        line.setAttribute('stroke', this.getLineColor());
	        line.setAttribute('stroke-width', this.getLineWidth());
	        line.setAttribute('fill', this.getFillColor());
	        line.setAttribute('fill-opacity', this.getFillOpacity());
	        line.setAttribute('stroke-opacity', this.getLineOpacity());
	      }
	    }, {
	      key: 'setLineWidth',
	      value: function setLineWidth(width) {
	        this.options.lineWidth = width;
	        this.styleHasChanged();
	        return this;
	      }
	    }, {
	      key: 'getLineWidth',
	      value: function getLineWidth() {
	        return this.options.lineWidth;
	      }
	    }, {
	      key: 'setLineOpacity',
	      value: function setLineOpacity(opacity) {
	        this.options.lineOpacity = opacity;
	        this.styleHasChanged();
	        return this;
	      }
	    }, {
	      key: 'getLineOpacity',
	      value: function getLineOpacity() {
	        return this.options.lineOpacity;
	      }
	    }, {
	      key: 'setLineColor',
	      value: function setLineColor(color) {
	        this.options.lineColor = color;
	        this.styleHasChanged();
	        return this;
	      }
	    }, {
	      key: 'getLineColor',
	      value: function getLineColor() {
	        return this.options.lineColor;
	      }
	    }, {
	      key: 'setFillOpacity',
	      value: function setFillOpacity(opacity) {
	        this.options.fillOpacity = opacity;
	        this.styleHasChanged();
	        return this;
	      }
	    }, {
	      key: 'getFillOpacity',
	      value: function getFillOpacity() {
	        return this.options.fillOpacity;
	      }
	    }, {
	      key: 'setFillColor',
	      value: function setFillColor(color) {
	        this.options.fillColor = color;
	        this.styleHasChanged();
	        return this;
	      }
	    }, {
	      key: 'getFillColor',
	      value: function getFillColor() {
	        return this.options.fillColor;
	      }
	    }]);

	    return SerieZone;
	  }(_graphSerie2.default);

	  exports.default = SerieZone;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 143 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShape, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeRectangle = function (_GraphShape) {
	    _inherits(ShapeRectangle, _GraphShape);

	    function ShapeRectangle(graph, options) {
	      _classCallCheck(this, ShapeRectangle);

	      return _possibleConstructorReturn(this, (ShapeRectangle.__proto__ || Object.getPrototypeOf(ShapeRectangle)).call(this, graph, options));
	    }

	    /**
	     * Creates the DOM
	     * @private
	     * @return {Shape} The current shape
	     */


	    _createClass(ShapeRectangle, [{
	      key: 'createDom',
	      value: function createDom() {
	        this._dom = document.createElementNS(this.graph.ns, 'rect');

	        if (!this.getStrokeColor()) {
	          this.setStrokeColor('black');
	        }

	        if (!this.getStrokeWidth()) {
	          this.setStrokeWidth(1);
	        }

	        if (!this.getFillColor()) {
	          this.setFillColor('transparent');
	        }

	        return this;
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {
	        if (!this.hasHandles()) {
	          return;
	        }

	        /*
	              this._data.handles = this._data.handles || {
	                type: 'corners'
	              };
	        */

	        var handles = this.getProp('handles');

	        if ((typeof handles === 'undefined' ? 'undefined' : _typeof(handles)) != 'object') {
	          handles = {};
	        }

	        if (!handles.type) {
	          handles.type = 'corners';
	        }

	        switch (handles.type) {

	          case 'sides':

	            util.extend(handles, {
	              sides: {
	                top: true,
	                bottom: true,
	                left: true,
	                right: true
	              }
	            });

	            var j = 0;
	            for (var i in handles.sides) {
	              if (handles.sides[i]) {
	                j++;
	              }
	            }

	            this._createHandles(j, 'g').map(function (g) {

	              var r = document.createElementNS(self.graph.ns, 'rect');
	              r.setAttribute('x', '-3');
	              r.setAttribute('width', '6');
	              r.setAttribute('y', '-6');
	              r.setAttribute('height', '12');
	              r.setAttribute('stroke', 'black');
	              r.setAttribute('fill', 'white');
	              r.setAttribute('cursor', 'pointer');

	              g.appendChild(r);
	            });

	            var j = 1;

	            for (var i in handles.sides) {
	              if (handles.sides[i]) {
	                this.handles[i] = this['handle' + j];
	                this.sides[j] = i;
	                j++;
	              }
	            }

	            break;

	          case 'corners':
	            this._createHandles(4, 'rect', {
	              transform: 'translate(-3 -3)',
	              width: 6,
	              height: 6,
	              stroke: 'black',
	              fill: 'white'
	            });

	            if (this.handles) {
	              this.handles[2].setAttribute('cursor', 'nesw-resize');
	              this.handles[4].setAttribute('cursor', 'nesw-resize');

	              this.handles[1].setAttribute('cursor', 'nwse-resize');
	              this.handles[3].setAttribute('cursor', 'nwse-resize');
	            }

	            break;

	          case 'seamlessX':

	            this._createHandles(2, 'rect', {
	              transform: 'translate(-3 -3)',
	              stroke: 'transparent',
	              fill: 'transparent',
	              width: '20px',
	              cursor: 'ew-resize'
	            });

	            break;
	        }

	        _get(ShapeRectangle.prototype.__proto__ || Object.getPrototypeOf(ShapeRectangle.prototype), 'createHandles', this).call(this);

	        return this;
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        var pos = this.computePosition(0),
	            pos2 = this.computePosition(1),
	            x,
	            y,
	            width,
	            height;

	        if (pos.x < pos2.x) {
	          x = pos.x;
	          width = pos2.x - pos.x;
	        } else {
	          x = pos2.x;
	          width = pos.x - pos2.x;
	        }

	        if (pos.y < pos2.y) {
	          y = pos.y;
	          height = pos2.y - pos.y;
	        } else {
	          y = pos2.y;
	          height = pos.y - pos2.y;
	        }

	        this.currentX = x;
	        this.currentY = y;
	        this.currentW = width;
	        this.currentH = height;

	        if (!isNaN(x) && !isNaN(y) && x !== false && y !== false) {

	          this.setDom('width', width);
	          this.setDom('height', height);
	          this.setDom('x', x);
	          this.setDom('y', y);

	          this.setHandles();
	          this.updateMask();

	          return true;
	        }

	        return false;
	      }
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

	        var handles = this.getProp('handles');

	        if (!this.moving && !this.handleSelected) {
	          return;
	        }

	        var pos = this.getPosition(0);
	        var pos2 = this.getPosition(1);

	        var invX = this.getXAxis().isFlipped(),
	            invY = this.getYAxis().isFlipped(),
	            posX = pos.x,
	            posY = pos.y,
	            pos2X = pos2.x,
	            pos2Y = pos2.y;

	        if (this.moving) {

	          pos.deltaPosition('x', deltaX, this.getXAxis());
	          pos.deltaPosition('y', deltaY, this.getYAxis());

	          pos2.deltaPosition('x', deltaX, this.getXAxis());
	          pos2.deltaPosition('y', deltaY, this.getYAxis());
	        } else {

	          switch (handles.type) {

	            case 'seamlessX':
	              // Do nothing for now

	              switch (this.handleSelected) {

	                case 1:
	                  pos.deltaPosition('x', deltaX, this.getXAxis());
	                  break;

	                case 2:
	                  pos2.deltaPosition('x', deltaX, this.getXAxis());
	                  break;
	              }

	              break;

	            case 'sides':
	              // Do nothing for now

	              switch (this.sides[this.handleSelected]) {

	                case 'left':
	                  pos.deltaPosition('x', deltaX, this.getXAxis());
	                  break;

	                case 'right':
	                  pos2.deltaPosition('x', deltaX, this.getXAxis());
	                  break;

	                case 'top':
	                  pos.deltaPosition('y', deltaY, this.getYAxis());
	                  break;

	                case 'bottom':
	                  pos2.deltaPosition('y', deltaY, this.getYAxis());
	                  break;

	              }

	              break;

	            case 'corners':
	            default:

	              if (this.handleSelected == 1) {

	                pos.deltaPosition('x', deltaX, this.getXAxis());
	                pos.deltaPosition('y', deltaY, this.getYAxis());
	              } else if (this.handleSelected == 2) {

	                pos2.deltaPosition('x', deltaX, this.getXAxis());
	                pos.deltaPosition('y', deltaY, this.getYAxis());
	              } else if (this.handleSelected == 3) {

	                pos2.deltaPosition('y', deltaY, this.getYAxis());
	                pos2.deltaPosition('x', deltaX, this.getXAxis());
	              } else if (this.handleSelected == 4) {

	                pos.deltaPosition('x', deltaX, this.getXAxis());
	                pos2.deltaPosition('y', deltaY, this.getYAxis());
	              }

	              break;

	          }
	        }

	        this.redraw();
	        this.changed();
	        this.setHandles();

	        return true;
	      }
	    }, {
	      key: 'setHandles',
	      value: function setHandles() {

	        if (this.isLocked() || !this.isSelectable() && !this._staticHandles) {
	          return;
	        }

	        if (!this.handlesInDom) {
	          return;
	        }

	        var pos = this.computePosition(0);
	        var pos2 = this.computePosition(1);

	        var handles = this.getProp('handles');

	        switch (handles.type) {

	          case 'seamlessX':

	            if (this.handles[1]) {
	              this.handles[1].setAttribute('transform', 'translate(-10) translate(' + pos.x + ')');
	              this.handles[1].setAttribute('height', Math.abs(pos2.y - pos.y));
	              this.handles[1].setAttribute('y', Math.min(pos2.y, pos.y));
	            }

	            if (this.handles[2]) {
	              this.handles[2].setAttribute('transform', 'translate(-10)  translate(' + pos2.x + ')');
	              this.handles[2].setAttribute('height', Math.abs(pos2.y - pos.y));
	              this.handles[2].setAttribute('y', Math.min(pos2.y, pos.y));
	            }

	            break;

	          case 'sides':

	            if (this.handles.left) {
	              this.handles.left.setAttribute('transform', 'translate(' + this.currentX + ' ' + (this.currentY + this.currentH / 2) + ')');
	            }

	            if (this.handles.right) {
	              this.handles.right.setAttribute('transform', 'translate( ' + (this.currentX + this.currentW) + ' ' + (this.currentY + this.currentH / 2) + ')');
	            }

	            if (this.handles.top) {
	              this.handles.top.setAttribute('transform', 'translate( ' + (this.currentX + this.currentW / 2) + ' ' + this.currentY + ')');
	            }

	            if (this.handles.bottom) {
	              this.handles.bottom.setAttribute('transform', 'translate( ' + (this.currentX + this.currentW / 2) + ' ' + (this.currentY + this.currentH) + ')');
	            }

	            break;

	          case 'corners':
	          default:

	            this.handles[1].setAttribute('x', pos.x);
	            this.handles[1].setAttribute('y', pos.y);

	            this.handles[2].setAttribute('x', pos2.x);
	            this.handles[2].setAttribute('y', pos.y);

	            this.handles[3].setAttribute('x', pos2.x);
	            this.handles[3].setAttribute('y', pos2.y);

	            this.handles[4].setAttribute('x', pos.x);
	            this.handles[4].setAttribute('y', pos2.y);

	            break;

	        }
	      }
	    }]);

	    return ShapeRectangle;
	  }(_graphShape2.default);

	  exports.default = ShapeRectangle;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 144 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(145);
	module.exports = __webpack_require__(347);


	/***/ }),
	/* 145 */
	/***/ (function(module, exports, __webpack_require__) {
	/* WEBPACK VAR INJECTION */(function(global) {

	__webpack_require__(146);

	__webpack_require__(343);

	__webpack_require__(344);

	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;

	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}

	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);

	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103)));

	/***/ }),
	/* 146 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(147);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(158);
	__webpack_require__(159);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(162);
	__webpack_require__(163);
	__webpack_require__(165);
	__webpack_require__(166);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(173);
	__webpack_require__(174);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(186);
	__webpack_require__(187);
	__webpack_require__(188);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);
	__webpack_require__(194);
	__webpack_require__(195);
	__webpack_require__(196);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(206);
	__webpack_require__(207);
	__webpack_require__(208);
	__webpack_require__(209);
	__webpack_require__(210);
	__webpack_require__(211);
	__webpack_require__(212);
	__webpack_require__(213);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(216);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(219);
	__webpack_require__(220);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(223);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(95);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(122);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(125);
	__webpack_require__(127);
	__webpack_require__(128);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(260);
	__webpack_require__(261);
	__webpack_require__(262);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(268);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(290);
	__webpack_require__(291);
	__webpack_require__(292);
	__webpack_require__(293);
	__webpack_require__(294);
	__webpack_require__(295);
	__webpack_require__(296);
	__webpack_require__(297);
	__webpack_require__(298);
	__webpack_require__(299);
	__webpack_require__(300);
	__webpack_require__(301);
	__webpack_require__(302);
	__webpack_require__(303);
	__webpack_require__(304);
	__webpack_require__(305);
	__webpack_require__(306);
	__webpack_require__(307);
	__webpack_require__(308);
	__webpack_require__(309);
	__webpack_require__(310);
	__webpack_require__(311);
	__webpack_require__(312);
	__webpack_require__(313);
	__webpack_require__(314);
	__webpack_require__(315);
	__webpack_require__(316);
	__webpack_require__(317);
	__webpack_require__(318);
	__webpack_require__(319);
	__webpack_require__(320);
	__webpack_require__(321);
	__webpack_require__(322);
	__webpack_require__(323);
	__webpack_require__(324);
	__webpack_require__(325);
	__webpack_require__(326);
	__webpack_require__(327);
	__webpack_require__(328);
	__webpack_require__(329);
	__webpack_require__(330);
	__webpack_require__(331);
	__webpack_require__(332);
	__webpack_require__(333);
	__webpack_require__(334);
	__webpack_require__(335);
	__webpack_require__(336);
	__webpack_require__(337);
	__webpack_require__(338);
	__webpack_require__(339);
	__webpack_require__(340);
	__webpack_require__(341);
	__webpack_require__(342);
	module.exports = __webpack_require__(22);


	/***/ }),
	/* 147 */
	/***/ (function(module, exports, __webpack_require__) {

	// ECMAScript 6 symbols shim
	var global = __webpack_require__(2);
	var has = __webpack_require__(12);
	var DESCRIPTORS = __webpack_require__(7);
	var $export = __webpack_require__(0);
	var redefine = __webpack_require__(14);
	var META = __webpack_require__(32).KEY;
	var $fails = __webpack_require__(3);
	var shared = __webpack_require__(58);
	var setToStringTag = __webpack_require__(47);
	var uid = __webpack_require__(35);
	var wks = __webpack_require__(6);
	var wksExt = __webpack_require__(105);
	var wksDefine = __webpack_require__(75);
	var enumKeys = __webpack_require__(148);
	var isArray = __webpack_require__(61);
	var anObject = __webpack_require__(1);
	var isObject = __webpack_require__(4);
	var toIObject = __webpack_require__(16);
	var toPrimitive = __webpack_require__(23);
	var createDesc = __webpack_require__(34);
	var _create = __webpack_require__(39);
	var gOPNExt = __webpack_require__(108);
	var $GOPD = __webpack_require__(17);
	var $DP = __webpack_require__(8);
	var $keys = __webpack_require__(37);
	var gOPD = $GOPD.f;
	var dP = $DP.f;
	var gOPN = gOPNExt.f;
	var $Symbol = global.Symbol;
	var $JSON = global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE = 'prototype';
	var HIDDEN = wks('_hidden');
	var TO_PRIMITIVE = wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = shared('symbol-registry');
	var AllSymbols = shared('symbols');
	var OPSymbols = shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
	  return _create(dP({}, 'a', {
	    get: function () { return dP(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _create(D, { enumerable: createDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = toPrimitive(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f = $defineProperty;
	  __webpack_require__(40).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(53).f = $propertyIsEnumerable;
	  __webpack_require__(60).f = $getOwnPropertySymbols;

	  if (DESCRIPTORS && !__webpack_require__(36)) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function (name) {
	    return wrap(wks(name));
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

	for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(13)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);


	/***/ }),
	/* 148 */
	/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(37);
	var gOPS = __webpack_require__(60);
	var pIE = __webpack_require__(53);
	module.exports = function (it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = pIE.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};


	/***/ }),
	/* 149 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', { create: __webpack_require__(39) });


	/***/ }),
	/* 150 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperty: __webpack_require__(8).f });


	/***/ }),
	/* 151 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperties: __webpack_require__(107) });


	/***/ }),
	/* 152 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(16);
	var $getOwnPropertyDescriptor = __webpack_require__(17).f;

	__webpack_require__(26)('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});


	/***/ }),
	/* 153 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(10);
	var $getPrototypeOf = __webpack_require__(18);

	__webpack_require__(26)('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return $getPrototypeOf(toObject(it));
	  };
	});


	/***/ }),
	/* 154 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(10);
	var $keys = __webpack_require__(37);

	__webpack_require__(26)('keys', function () {
	  return function keys(it) {
	    return $keys(toObject(it));
	  };
	});


	/***/ }),
	/* 155 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(26)('getOwnPropertyNames', function () {
	  return __webpack_require__(108).f;
	});


	/***/ }),
	/* 156 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(4);
	var meta = __webpack_require__(32).onFreeze;

	__webpack_require__(26)('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});


	/***/ }),
	/* 157 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(4);
	var meta = __webpack_require__(32).onFreeze;

	__webpack_require__(26)('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});


	/***/ }),
	/* 158 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(4);
	var meta = __webpack_require__(32).onFreeze;

	__webpack_require__(26)('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});


	/***/ }),
	/* 159 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(4);

	__webpack_require__(26)('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});


	/***/ }),
	/* 160 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(4);

	__webpack_require__(26)('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});


	/***/ }),
	/* 161 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(4);

	__webpack_require__(26)('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});


	/***/ }),
	/* 162 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(0);

	$export($export.S + $export.F, 'Object', { assign: __webpack_require__(109) });


	/***/ }),
	/* 163 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(0);
	$export($export.S, 'Object', { is: __webpack_require__(164) });


	/***/ }),
	/* 164 */
	/***/ (function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};


	/***/ }),
	/* 165 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(0);
	$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(79).set });


	/***/ }),
	/* 166 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(54);
	var test = {};
	test[__webpack_require__(6)('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  __webpack_require__(14)(Object.prototype, 'toString', function toString() {
	    return '[object ' + classof(this) + ']';
	  }, true);
	}


	/***/ }),
	/* 167 */
	/***/ (function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(0);

	$export($export.P, 'Function', { bind: __webpack_require__(110) });


	/***/ }),
	/* 168 */
	/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(8).f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(7) && dP(FProto, NAME, {
	  configurable: true,
	  get: function () {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});


	/***/ }),
	/* 169 */
	/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(4);
	var getPrototypeOf = __webpack_require__(18);
	var HAS_INSTANCE = __webpack_require__(6)('hasInstance');
	var FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(8).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
	  if (typeof this != 'function' || !isObject(O)) return false;
	  if (!isObject(this.prototype)) return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
	  return false;
	} });


	/***/ }),
	/* 170 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $parseInt = __webpack_require__(112);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


	/***/ }),
	/* 171 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $parseFloat = __webpack_require__(113);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


	/***/ }),
	/* 172 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var has = __webpack_require__(12);
	var cof = __webpack_require__(20);
	var inheritIfRequired = __webpack_require__(81);
	var toPrimitive = __webpack_require__(23);
	var fails = __webpack_require__(3);
	var gOPN = __webpack_require__(40).f;
	var gOPD = __webpack_require__(17).f;
	var dP = __webpack_require__(8).f;
	var $trim = __webpack_require__(48).trim;
	var NUMBER = 'Number';
	var $Number = global[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = cof(__webpack_require__(39)(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype;

	// 7.1.3 ToNumber(argument)
	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default: return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = __webpack_require__(7) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++) {
	    if (has(Base, key = keys[j]) && !has($Number, key)) {
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(14)(global, NUMBER, $Number);
	}


	/***/ }),
	/* 173 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toInteger = __webpack_require__(25);
	var aNumberValue = __webpack_require__(114);
	var repeat = __webpack_require__(82);
	var $toFixed = 1.0.toFixed;
	var floor = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';

	var multiply = function (n, c) {
	  var i = -1;
	  var c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function (n) {
	  var i = 6;
	  var c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function () {
	  var i = 6;
	  var s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(3)(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = aNumberValue(this, ERROR);
	    var f = toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) throw RangeError(ERROR);
	    // eslint-disable-next-line no-self-compare
	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});


	/***/ }),
	/* 174 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $fails = __webpack_require__(3);
	var aNumberValue = __webpack_require__(114);
	var $toPrecision = 1.0.toPrecision;

	$export($export.P + $export.F * ($fails(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});


	/***/ }),
	/* 175 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(0);

	$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


	/***/ }),
	/* 176 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export = __webpack_require__(0);
	var _isFinite = __webpack_require__(2).isFinite;

	$export($export.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});


	/***/ }),
	/* 177 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(0);

	$export($export.S, 'Number', { isInteger: __webpack_require__(115) });


	/***/ }),
	/* 178 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(0);

	$export($export.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});


	/***/ }),
	/* 179 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export = __webpack_require__(0);
	var isInteger = __webpack_require__(115);
	var abs = Math.abs;

	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});


	/***/ }),
	/* 180 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(0);

	$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


	/***/ }),
	/* 181 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(0);

	$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


	/***/ }),
	/* 182 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $parseFloat = __webpack_require__(113);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


	/***/ }),
	/* 183 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $parseInt = __webpack_require__(112);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


	/***/ }),
	/* 184 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(0);
	var log1p = __webpack_require__(116);
	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;

	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});


	/***/ }),
	/* 185 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(0);
	var $asinh = Math.asinh;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}

	// Tor Browser bug: Math.asinh(0) -> -0
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


	/***/ }),
	/* 186 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(0);
	var $atanh = Math.atanh;

	// Tor Browser bug: Math.atanh(-0) -> 0
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});


	/***/ }),
	/* 187 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(0);
	var sign = __webpack_require__(83);

	$export($export.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});


	/***/ }),
	/* 188 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});


	/***/ }),
	/* 189 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(0);
	var exp = Math.exp;

	$export($export.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});


	/***/ }),
	/* 190 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(0);
	var $expm1 = __webpack_require__(84);

	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


	/***/ }),
	/* 191 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', { fround: __webpack_require__(117) });


	/***/ }),
	/* 192 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
	var $export = __webpack_require__(0);
	var abs = Math.abs;

	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});


	/***/ }),
	/* 193 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(0);
	var $imul = Math.imul;

	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(3)(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});


	/***/ }),
	/* 194 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});


	/***/ }),
	/* 195 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', { log1p: __webpack_require__(116) });


	/***/ }),
	/* 196 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});


	/***/ }),
	/* 197 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', { sign: __webpack_require__(83) });


	/***/ }),
	/* 198 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(0);
	var expm1 = __webpack_require__(84);
	var exp = Math.exp;

	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(3)(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});


	/***/ }),
	/* 199 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(0);
	var expm1 = __webpack_require__(84);
	var exp = Math.exp;

	$export($export.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = expm1(x = +x);
	    var b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});


	/***/ }),
	/* 200 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});


	/***/ }),
	/* 201 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toAbsoluteIndex = __webpack_require__(38);
	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});


	/***/ }),
	/* 202 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toIObject = __webpack_require__(16);
	var toLength = __webpack_require__(9);

	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = toIObject(callSite.raw);
	    var len = toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});


	/***/ }),
	/* 203 */
	/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(48)('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});


	/***/ }),
	/* 204 */
	/***/ (function(module, exports, __webpack_require__) {

	var $at = __webpack_require__(85)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(86)(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});


	/***/ }),
	/* 205 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $at = __webpack_require__(85)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});


	/***/ }),
	/* 206 */
	/***/ (function(module, exports, __webpack_require__) {
	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

	var $export = __webpack_require__(0);
	var toLength = __webpack_require__(9);
	var context = __webpack_require__(88);
	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];

	$export($export.P + $export.F * __webpack_require__(89)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = context(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});


	/***/ }),
	/* 207 */
	/***/ (function(module, exports, __webpack_require__) {
	// 21.1.3.7 String.prototype.includes(searchString, position = 0)

	var $export = __webpack_require__(0);
	var context = __webpack_require__(88);
	var INCLUDES = 'includes';

	$export($export.P + $export.F * __webpack_require__(89)(INCLUDES), 'String', {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});


	/***/ }),
	/* 208 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);

	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(82)
	});


	/***/ }),
	/* 209 */
	/***/ (function(module, exports, __webpack_require__) {
	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

	var $export = __webpack_require__(0);
	var toLength = __webpack_require__(9);
	var context = __webpack_require__(88);
	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];

	$export($export.P + $export.F * __webpack_require__(89)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = context(this, searchString, STARTS_WITH);
	    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});


	/***/ }),
	/* 210 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(15)('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});


	/***/ }),
	/* 211 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.3 String.prototype.big()
	__webpack_require__(15)('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});


	/***/ }),
	/* 212 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.4 String.prototype.blink()
	__webpack_require__(15)('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});


	/***/ }),
	/* 213 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.5 String.prototype.bold()
	__webpack_require__(15)('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});


	/***/ }),
	/* 214 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(15)('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});


	/***/ }),
	/* 215 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(15)('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});


	/***/ }),
	/* 216 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(15)('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});


	/***/ }),
	/* 217 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.9 String.prototype.italics()
	__webpack_require__(15)('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});


	/***/ }),
	/* 218 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(15)('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});


	/***/ }),
	/* 219 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.11 String.prototype.small()
	__webpack_require__(15)('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});


	/***/ }),
	/* 220 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.12 String.prototype.strike()
	__webpack_require__(15)('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});


	/***/ }),
	/* 221 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.13 String.prototype.sub()
	__webpack_require__(15)('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});


	/***/ }),
	/* 222 */
	/***/ (function(module, exports, __webpack_require__) {

	// B.2.3.14 String.prototype.sup()
	__webpack_require__(15)('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});


	/***/ }),
	/* 223 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(0);

	$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


	/***/ }),
	/* 224 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toObject = __webpack_require__(10);
	var toPrimitive = __webpack_require__(23);

	$export($export.P + $export.F * __webpack_require__(3)(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});


	/***/ }),
	/* 225 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(0);
	var toISOString = __webpack_require__(226);

	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
	  toISOString: toISOString
	});


	/***/ }),
	/* 226 */
	/***/ (function(module, exports, __webpack_require__) {

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var fails = __webpack_require__(3);
	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;

	var lz = function (num) {
	  return num > 9 ? num : '0' + num;
	};

	// PhantomJS / old WebKit has a broken implementations
	module.exports = (fails(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  $toISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;


	/***/ }),
	/* 227 */
	/***/ (function(module, exports, __webpack_require__) {

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  __webpack_require__(14)(DateProto, TO_STRING, function toString() {
	    var value = getTime.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}


	/***/ }),
	/* 228 */
	/***/ (function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(6)('toPrimitive');
	var proto = Date.prototype;

	if (!(TO_PRIMITIVE in proto)) __webpack_require__(13)(proto, TO_PRIMITIVE, __webpack_require__(229));


	/***/ }),
	/* 229 */
	/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(1);
	var toPrimitive = __webpack_require__(23);
	var NUMBER = 'number';

	module.exports = function (hint) {
	  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};


	/***/ }),
	/* 230 */
	/***/ (function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(0);

	$export($export.S, 'Array', { isArray: __webpack_require__(61) });


	/***/ }),
	/* 231 */
	/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(19);
	var $export = __webpack_require__(0);
	var toObject = __webpack_require__(10);
	var call = __webpack_require__(118);
	var isArrayIter = __webpack_require__(90);
	var toLength = __webpack_require__(9);
	var createProperty = __webpack_require__(91);
	var getIterFn = __webpack_require__(92);

	$export($export.S + $export.F * !__webpack_require__(63)(function (iter) { }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = toObject(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = getIterFn(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


	/***/ }),
	/* 232 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var createProperty = __webpack_require__(91);

	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(3)(function () {
	  function F() { /* empty */ }
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */) {
	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});


	/***/ }),
	/* 233 */
	/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.13 Array.prototype.join(separator)
	var $export = __webpack_require__(0);
	var toIObject = __webpack_require__(16);
	var arrayJoin = [].join;

	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(52) != Object || !__webpack_require__(21)(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});


	/***/ }),
	/* 234 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var html = __webpack_require__(78);
	var cof = __webpack_require__(20);
	var toAbsoluteIndex = __webpack_require__(38);
	var toLength = __webpack_require__(9);
	var arraySlice = [].slice;

	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(3)(function () {
	  if (html) arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = toLength(this.length);
	    var klass = cof(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice.call(this, begin, end);
	    var start = toAbsoluteIndex(begin, len);
	    var upTo = toAbsoluteIndex(end, len);
	    var size = toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;
	    for (; i < size; i++) cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});


	/***/ }),
	/* 235 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var aFunction = __webpack_require__(11);
	var toObject = __webpack_require__(10);
	var fails = __webpack_require__(3);
	var $sort = [].sort;
	var test = [1, 2, 3];

	$export($export.P + $export.F * (fails(function () {
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function () {
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(21)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});


	/***/ }),
	/* 236 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $forEach = __webpack_require__(27)(0);
	var STRICT = __webpack_require__(21)([].forEach, true);

	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});


	/***/ }),
	/* 237 */
	/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(4);
	var isArray = __webpack_require__(61);
	var SPECIES = __webpack_require__(6)('species');

	module.exports = function (original) {
	  var C;
	  if (isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};


	/***/ }),
	/* 238 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $map = __webpack_require__(27)(1);

	$export($export.P + $export.F * !__webpack_require__(21)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});


	/***/ }),
	/* 239 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $filter = __webpack_require__(27)(2);

	$export($export.P + $export.F * !__webpack_require__(21)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});


	/***/ }),
	/* 240 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $some = __webpack_require__(27)(3);

	$export($export.P + $export.F * !__webpack_require__(21)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});


	/***/ }),
	/* 241 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $every = __webpack_require__(27)(4);

	$export($export.P + $export.F * !__webpack_require__(21)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});


	/***/ }),
	/* 242 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $reduce = __webpack_require__(119);

	$export($export.P + $export.F * !__webpack_require__(21)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});


	/***/ }),
	/* 243 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $reduce = __webpack_require__(119);

	$export($export.P + $export.F * !__webpack_require__(21)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});


	/***/ }),
	/* 244 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $indexOf = __webpack_require__(59)(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(21)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});


	/***/ }),
	/* 245 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toIObject = __webpack_require__(16);
	var toInteger = __webpack_require__(25);
	var toLength = __webpack_require__(9);
	var $native = [].lastIndexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(21)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
	    var O = toIObject(this);
	    var length = toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
	    return -1;
	  }
	});


	/***/ }),
	/* 246 */
	/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(0);

	$export($export.P, 'Array', { copyWithin: __webpack_require__(120) });

	__webpack_require__(33)('copyWithin');


	/***/ }),
	/* 247 */
	/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(0);

	$export($export.P, 'Array', { fill: __webpack_require__(94) });

	__webpack_require__(33)('fill');


	/***/ }),
	/* 248 */
	/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(0);
	var $find = __webpack_require__(27)(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(33)(KEY);


	/***/ }),
	/* 249 */
	/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(0);
	var $find = __webpack_require__(27)(6);
	var KEY = 'findIndex';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(33)(KEY);


	/***/ }),
	/* 250 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(41)('Array');


	/***/ }),
	/* 251 */
	/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(2);
	var inheritIfRequired = __webpack_require__(81);
	var dP = __webpack_require__(8).f;
	var gOPN = __webpack_require__(40).f;
	var isRegExp = __webpack_require__(62);
	var $flags = __webpack_require__(64);
	var $RegExp = global.RegExp;
	var Base = $RegExp;
	var proto = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;

	if (__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(3)(function () {
	  re2[__webpack_require__(6)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = isRegExp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function (key) {
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function () { return Base[key]; },
	      set: function (it) { Base[key] = it; }
	    });
	  };
	  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(14)(global, 'RegExp', $RegExp);
	}

	__webpack_require__(41)('RegExp');


	/***/ }),
	/* 252 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(122);
	var anObject = __webpack_require__(1);
	var $flags = __webpack_require__(64);
	var DESCRIPTORS = __webpack_require__(7);
	var TO_STRING = 'toString';
	var $toString = /./[TO_STRING];

	var define = function (fn) {
	  __webpack_require__(14)(RegExp.prototype, TO_STRING, fn, true);
	};

	// 21.2.5.14 RegExp.prototype.toString()
	if (__webpack_require__(3)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString.name != TO_STRING) {
	  define(function toString() {
	    return $toString.call(this);
	  });
	}


	/***/ }),
	/* 253 */
	/***/ (function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(65)('match', 1, function (defined, MATCH, $match) {
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp) {
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});


	/***/ }),
	/* 254 */
	/***/ (function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(65)('replace', 2, function (defined, REPLACE, $replace) {
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue) {
	    var O = defined(this);
	    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});


	/***/ }),
	/* 255 */
	/***/ (function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(65)('search', 1, function (defined, SEARCH, $search) {
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp) {
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});


	/***/ }),
	/* 256 */
	/***/ (function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(65)('split', 2, function (defined, SPLIT, $split) {
	  var isRegExp = __webpack_require__(62);
	  var _split = $split;
	  var $push = [].push;
	  var $SPLIT = 'split';
	  var LENGTH = 'length';
	  var LAST_INDEX = 'lastIndex';
	  if (
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ) {
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function (separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp(separator)) return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while (match = separatorCopy.exec(string)) {
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          // eslint-disable-next-line no-loop-func
	          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
	            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
	          });
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    $split = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit) {
	    var O = defined(this);
	    var fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});


	/***/ }),
	/* 257 */
	/***/ (function(module, exports, __webpack_require__) {

	var LIBRARY = __webpack_require__(36);
	var global = __webpack_require__(2);
	var ctx = __webpack_require__(19);
	var classof = __webpack_require__(54);
	var $export = __webpack_require__(0);
	var isObject = __webpack_require__(4);
	var aFunction = __webpack_require__(11);
	var anInstance = __webpack_require__(42);
	var forOf = __webpack_require__(43);
	var speciesConstructor = __webpack_require__(66);
	var task = __webpack_require__(96).set;
	var microtask = __webpack_require__(97)();
	var newPromiseCapabilityModule = __webpack_require__(98);
	var perform = __webpack_require__(123);
	var promiseResolve = __webpack_require__(124);
	var PROMISE = 'Promise';
	var TypeError = global.TypeError;
	var process = global.process;
	var $Promise = global[PROMISE];
	var isNode = classof(process) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[__webpack_require__(6)('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch (e) { /* empty */ }
	}();

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value);
	            if (domain) domain.exit();
	          }
	          if (result === reaction.promise) {
	            reject(TypeError('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode) {
	          process.emit('unhandledRejection', value, promise);
	        } else if (handler = global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(global, function () {
	    var handler;
	    if (isNode) {
	      process.emit('rejectionHandled', promise);
	    } else if (handler = global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};

	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(44)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
	__webpack_require__(47)($Promise, PROMISE);
	__webpack_require__(41)(PROMISE);
	Wrapper = __webpack_require__(22)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(63)(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});


	/***/ }),
	/* 258 */
	/***/ (function(module, exports, __webpack_require__) {

	var weak = __webpack_require__(129);
	var validate = __webpack_require__(50);
	var WEAK_SET = 'WeakSet';

	// 23.4 WeakSet Objects
	__webpack_require__(67)(WEAK_SET, function (get) {
	  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return weak.def(validate(this, WEAK_SET), value, true);
	  }
	}, weak, false, true);


	/***/ }),
	/* 259 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $typed = __webpack_require__(68);
	var buffer = __webpack_require__(99);
	var anObject = __webpack_require__(1);
	var toAbsoluteIndex = __webpack_require__(38);
	var toLength = __webpack_require__(9);
	var isObject = __webpack_require__(4);
	var ArrayBuffer = __webpack_require__(2).ArrayBuffer;
	var speciesConstructor = __webpack_require__(66);
	var $ArrayBuffer = buffer.ArrayBuffer;
	var $DataView = buffer.DataView;
	var $isView = $typed.ABV && ArrayBuffer.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW = $typed.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';

	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});

	$export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	    var len = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, len);
	    var final = toAbsoluteIndex(end === undefined ? len : end, len);
	    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;
	    while (first < final) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});

	__webpack_require__(41)(ARRAY_BUFFER);


	/***/ }),
	/* 260 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	$export($export.G + $export.W + $export.F * !__webpack_require__(68).ABV, {
	  DataView: __webpack_require__(99).DataView
	});


	/***/ }),
	/* 261 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


	/***/ }),
	/* 262 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


	/***/ }),
	/* 263 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);


	/***/ }),
	/* 264 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


	/***/ }),
	/* 265 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


	/***/ }),
	/* 266 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


	/***/ }),
	/* 267 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


	/***/ }),
	/* 268 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


	/***/ }),
	/* 269 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(30)('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


	/***/ }),
	/* 270 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export = __webpack_require__(0);
	var aFunction = __webpack_require__(11);
	var anObject = __webpack_require__(1);
	var rApply = (__webpack_require__(2).Reflect || {}).apply;
	var fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(3)(function () {
	  rApply(function () { /* empty */ });
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = aFunction(target);
	    var L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});


	/***/ }),
	/* 271 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export = __webpack_require__(0);
	var create = __webpack_require__(39);
	var aFunction = __webpack_require__(11);
	var anObject = __webpack_require__(1);
	var isObject = __webpack_require__(4);
	var fails = __webpack_require__(3);
	var bind = __webpack_require__(110);
	var rConstruct = (__webpack_require__(2).Reflect || {}).construct;

	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() { /* empty */ }
	  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  rConstruct(function () { /* empty */ });
	});

	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = create(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});


	/***/ }),
	/* 272 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP = __webpack_require__(8);
	var $export = __webpack_require__(0);
	var anObject = __webpack_require__(1);
	var toPrimitive = __webpack_require__(23);

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(3)(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


	/***/ }),
	/* 273 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export = __webpack_require__(0);
	var gOPD = __webpack_require__(17).f;
	var anObject = __webpack_require__(1);

	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});


	/***/ }),
	/* 274 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.5 Reflect.enumerate(target)
	var $export = __webpack_require__(0);
	var anObject = __webpack_require__(1);
	var Enumerate = function (iterated) {
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = [];      // keys
	  var key;
	  for (key in iterated) keys.push(key);
	};
	__webpack_require__(87)(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;
	  do {
	    if (that._i >= keys.length) return { value: undefined, done: true };
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});

	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});


	/***/ }),
	/* 275 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD = __webpack_require__(17);
	var getPrototypeOf = __webpack_require__(18);
	var has = __webpack_require__(12);
	var $export = __webpack_require__(0);
	var isObject = __webpack_require__(4);
	var anObject = __webpack_require__(1);

	function get(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
	}

	$export($export.S, 'Reflect', { get: get });


	/***/ }),
	/* 276 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD = __webpack_require__(17);
	var $export = __webpack_require__(0);
	var anObject = __webpack_require__(1);

	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});


	/***/ }),
	/* 277 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export = __webpack_require__(0);
	var getProto = __webpack_require__(18);
	var anObject = __webpack_require__(1);

	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return getProto(anObject(target));
	  }
	});


	/***/ }),
	/* 278 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(0);

	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});


	/***/ }),
	/* 279 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export = __webpack_require__(0);
	var anObject = __webpack_require__(1);
	var $isExtensible = Object.isExtensible;

	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});


	/***/ }),
	/* 280 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(0);

	$export($export.S, 'Reflect', { ownKeys: __webpack_require__(131) });


	/***/ }),
	/* 281 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export = __webpack_require__(0);
	var anObject = __webpack_require__(1);
	var $preventExtensions = Object.preventExtensions;

	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


	/***/ }),
	/* 282 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP = __webpack_require__(8);
	var gOPD = __webpack_require__(17);
	var getPrototypeOf = __webpack_require__(18);
	var has = __webpack_require__(12);
	var $export = __webpack_require__(0);
	var createDesc = __webpack_require__(34);
	var anObject = __webpack_require__(1);
	var isObject = __webpack_require__(4);

	function set(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = gOPD.f(anObject(target), propertyKey);
	  var existingDescriptor, proto;
	  if (!ownDesc) {
	    if (isObject(proto = getPrototypeOf(target))) {
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if (has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !isObject(receiver)) return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}

	$export($export.S, 'Reflect', { set: set });


	/***/ }),
	/* 283 */
	/***/ (function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export = __webpack_require__(0);
	var setProto = __webpack_require__(79);

	if (setProto) $export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


	/***/ }),
	/* 284 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/Array.prototype.includes
	var $export = __webpack_require__(0);
	var $includes = __webpack_require__(59)(true);

	$export($export.P, 'Array', {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	__webpack_require__(33)('includes');


	/***/ }),
	/* 285 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
	var $export = __webpack_require__(0);
	var flattenIntoArray = __webpack_require__(132);
	var toObject = __webpack_require__(10);
	var toLength = __webpack_require__(9);
	var aFunction = __webpack_require__(11);
	var arraySpeciesCreate = __webpack_require__(93);

	$export($export.P, 'Array', {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen, A;
	    aFunction(callbackfn);
	    sourceLen = toLength(O.length);
	    A = arraySpeciesCreate(O, 0);
	    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
	    return A;
	  }
	});

	__webpack_require__(33)('flatMap');


	/***/ }),
	/* 286 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
	var $export = __webpack_require__(0);
	var flattenIntoArray = __webpack_require__(132);
	var toObject = __webpack_require__(10);
	var toLength = __webpack_require__(9);
	var toInteger = __webpack_require__(25);
	var arraySpeciesCreate = __webpack_require__(93);

	$export($export.P, 'Array', {
	  flatten: function flatten(/* depthArg = 1 */) {
	    var depthArg = arguments[0];
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A = arraySpeciesCreate(O, 0);
	    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});

	__webpack_require__(33)('flatten');


	/***/ }),
	/* 287 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(0);
	var $at = __webpack_require__(85)(true);

	$export($export.P, 'String', {
	  at: function at(pos) {
	    return $at(this, pos);
	  }
	});


	/***/ }),
	/* 288 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(0);
	var $pad = __webpack_require__(133);
	var userAgent = __webpack_require__(100);

	// https://github.com/zloirock/core-js/issues/280
	$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});


	/***/ }),
	/* 289 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(0);
	var $pad = __webpack_require__(133);
	var userAgent = __webpack_require__(100);

	// https://github.com/zloirock/core-js/issues/280
	$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});


	/***/ }),
	/* 290 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(48)('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');


	/***/ }),
	/* 291 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(48)('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');


	/***/ }),
	/* 292 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/String.prototype.matchAll/
	var $export = __webpack_require__(0);
	var defined = __webpack_require__(24);
	var toLength = __webpack_require__(9);
	var isRegExp = __webpack_require__(62);
	var getFlags = __webpack_require__(64);
	var RegExpProto = RegExp.prototype;

	var $RegExpStringIterator = function (regexp, string) {
	  this._r = regexp;
	  this._s = string;
	};

	__webpack_require__(87)($RegExpStringIterator, 'RegExp String', function next() {
	  var match = this._r.exec(this._s);
	  return { value: match, done: match === null };
	});

	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp) {
	    defined(this);
	    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
	    var S = String(this);
	    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
	    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});


	/***/ }),
	/* 293 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(75)('asyncIterator');


	/***/ }),
	/* 294 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(75)('observable');


	/***/ }),
	/* 295 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export = __webpack_require__(0);
	var ownKeys = __webpack_require__(131);
	var toIObject = __webpack_require__(16);
	var gOPD = __webpack_require__(17);
	var createProperty = __webpack_require__(91);

	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIObject(object);
	    var getDesc = gOPD.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;
	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) createProperty(result, key, desc);
	    }
	    return result;
	  }
	});


	/***/ }),
	/* 296 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(0);
	var $values = __webpack_require__(134)(false);

	$export($export.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});


	/***/ }),
	/* 297 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(0);
	var $entries = __webpack_require__(134)(true);

	$export($export.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});


	/***/ }),
	/* 298 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toObject = __webpack_require__(10);
	var aFunction = __webpack_require__(11);
	var $defineProperty = __webpack_require__(8);

	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(7) && $export($export.P + __webpack_require__(69), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter) {
	    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
	  }
	});


	/***/ }),
	/* 299 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toObject = __webpack_require__(10);
	var aFunction = __webpack_require__(11);
	var $defineProperty = __webpack_require__(8);

	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(7) && $export($export.P + __webpack_require__(69), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter) {
	    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
	  }
	});


	/***/ }),
	/* 300 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toObject = __webpack_require__(10);
	var toPrimitive = __webpack_require__(23);
	var getPrototypeOf = __webpack_require__(18);
	var getOwnPropertyDescriptor = __webpack_require__(17).f;

	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(7) && $export($export.P + __webpack_require__(69), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P) {
	    var O = toObject(this);
	    var K = toPrimitive(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
	    } while (O = getPrototypeOf(O));
	  }
	});


	/***/ }),
	/* 301 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var toObject = __webpack_require__(10);
	var toPrimitive = __webpack_require__(23);
	var getPrototypeOf = __webpack_require__(18);
	var getOwnPropertyDescriptor = __webpack_require__(17).f;

	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(7) && $export($export.P + __webpack_require__(69), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P) {
	    var O = toObject(this);
	    var K = toPrimitive(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
	    } while (O = getPrototypeOf(O));
	  }
	});


	/***/ }),
	/* 302 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(0);

	$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(135)('Map') });


	/***/ }),
	/* 303 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(0);

	$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(135)('Set') });


	/***/ }),
	/* 304 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	__webpack_require__(70)('Map');


	/***/ }),
	/* 305 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	__webpack_require__(70)('Set');


	/***/ }),
	/* 306 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	__webpack_require__(70)('WeakMap');


	/***/ }),
	/* 307 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	__webpack_require__(70)('WeakSet');


	/***/ }),
	/* 308 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	__webpack_require__(71)('Map');


	/***/ }),
	/* 309 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	__webpack_require__(71)('Set');


	/***/ }),
	/* 310 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	__webpack_require__(71)('WeakMap');


	/***/ }),
	/* 311 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	__webpack_require__(71)('WeakSet');


	/***/ }),
	/* 312 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-global
	var $export = __webpack_require__(0);

	$export($export.G, { global: __webpack_require__(2) });


	/***/ }),
	/* 313 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-global
	var $export = __webpack_require__(0);

	$export($export.S, 'System', { global: __webpack_require__(2) });


	/***/ }),
	/* 314 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(0);
	var cof = __webpack_require__(20);

	$export($export.S, 'Error', {
	  isError: function isError(it) {
	    return cof(it) === 'Error';
	  }
	});


	/***/ }),
	/* 315 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  clamp: function clamp(x, lower, upper) {
	    return Math.min(upper, Math.max(lower, x));
	  }
	});


	/***/ }),
	/* 316 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


	/***/ }),
	/* 317 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(0);
	var RAD_PER_DEG = 180 / Math.PI;

	$export($export.S, 'Math', {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});


	/***/ }),
	/* 318 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(0);
	var scale = __webpack_require__(137);
	var fround = __webpack_require__(117);

	$export($export.S, 'Math', {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return fround(scale(x, inLow, inHigh, outLow, outHigh));
	  }
	});


	/***/ }),
	/* 319 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});


	/***/ }),
	/* 320 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});


	/***/ }),
	/* 321 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});


	/***/ }),
	/* 322 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


	/***/ }),
	/* 323 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(0);
	var DEG_PER_RAD = Math.PI / 180;

	$export($export.S, 'Math', {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});


	/***/ }),
	/* 324 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', { scale: __webpack_require__(137) });


	/***/ }),
	/* 325 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});


	/***/ }),
	/* 326 */
	/***/ (function(module, exports, __webpack_require__) {

	// http://jfbastien.github.io/papers/Math.signbit.html
	var $export = __webpack_require__(0);

	$export($export.S, 'Math', { signbit: function signbit(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
	} });


	/***/ }),
	/* 327 */
	/***/ (function(module, exports, __webpack_require__) {
	// https://github.com/tc39/proposal-promise-finally

	var $export = __webpack_require__(0);
	var core = __webpack_require__(22);
	var global = __webpack_require__(2);
	var speciesConstructor = __webpack_require__(66);
	var promiseResolve = __webpack_require__(124);

	$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = speciesConstructor(this, core.Promise || global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });


	/***/ }),
	/* 328 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-promise-try
	var $export = __webpack_require__(0);
	var newPromiseCapability = __webpack_require__(98);
	var perform = __webpack_require__(123);

	$export($export.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = newPromiseCapability.f(this);
	  var result = perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });


	/***/ }),
	/* 329 */
	/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var toMetaKey = metadata.key;
	var ordinaryDefineOwnMetadata = metadata.set;

	metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	} });


	/***/ }),
	/* 330 */
	/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var toMetaKey = metadata.key;
	var getOrCreateMetadataMap = metadata.map;
	var store = metadata.store;

	metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
	  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
	  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	  if (metadataMap.size) return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	} });


	/***/ }),
	/* 331 */
	/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var getPrototypeOf = __webpack_require__(18);
	var ordinaryHasOwnMetadata = metadata.has;
	var ordinaryGetOwnMetadata = metadata.get;
	var toMetaKey = metadata.key;

	var ordinaryGetMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


	/***/ }),
	/* 332 */
	/***/ (function(module, exports, __webpack_require__) {

	var Set = __webpack_require__(127);
	var from = __webpack_require__(136);
	var metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var getPrototypeOf = __webpack_require__(18);
	var ordinaryOwnMetadataKeys = metadata.keys;
	var toMetaKey = metadata.key;

	var ordinaryMetadataKeys = function (O, P) {
	  var oKeys = ordinaryOwnMetadataKeys(O, P);
	  var parent = getPrototypeOf(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};

	metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	} });


	/***/ }),
	/* 333 */
	/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var ordinaryGetOwnMetadata = metadata.get;
	var toMetaKey = metadata.key;

	metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


	/***/ }),
	/* 334 */
	/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var ordinaryOwnMetadataKeys = metadata.keys;
	var toMetaKey = metadata.key;

	metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	} });


	/***/ }),
	/* 335 */
	/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var getPrototypeOf = __webpack_require__(18);
	var ordinaryHasOwnMetadata = metadata.has;
	var toMetaKey = metadata.key;

	var ordinaryHasMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


	/***/ }),
	/* 336 */
	/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var ordinaryHasOwnMetadata = metadata.has;
	var toMetaKey = metadata.key;

	metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


	/***/ }),
	/* 337 */
	/***/ (function(module, exports, __webpack_require__) {

	var $metadata = __webpack_require__(31);
	var anObject = __webpack_require__(1);
	var aFunction = __webpack_require__(11);
	var toMetaKey = $metadata.key;
	var ordinaryDefineOwnMetadata = $metadata.set;

	$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
	  return function decorator(target, targetKey) {
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	} });


	/***/ }),
	/* 338 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export = __webpack_require__(0);
	var microtask = __webpack_require__(97)();
	var process = __webpack_require__(2).process;
	var isNode = __webpack_require__(20)(process) == 'process';

	$export($export.G, {
	  asap: function asap(fn) {
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});


	/***/ }),
	/* 339 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/zenparsing/es-observable
	var $export = __webpack_require__(0);
	var global = __webpack_require__(2);
	var core = __webpack_require__(22);
	var microtask = __webpack_require__(97)();
	var OBSERVABLE = __webpack_require__(6)('observable');
	var aFunction = __webpack_require__(11);
	var anObject = __webpack_require__(1);
	var anInstance = __webpack_require__(42);
	var redefineAll = __webpack_require__(44);
	var hide = __webpack_require__(13);
	var forOf = __webpack_require__(43);
	var RETURN = forOf.RETURN;

	var getMethod = function (fn) {
	  return fn == null ? undefined : aFunction(fn);
	};

	var cleanupSubscription = function (subscription) {
	  var cleanup = subscription._c;
	  if (cleanup) {
	    subscription._c = undefined;
	    cleanup();
	  }
	};

	var subscriptionClosed = function (subscription) {
	  return subscription._o === undefined;
	};

	var closeSubscription = function (subscription) {
	  if (!subscriptionClosed(subscription)) {
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};

	var Subscription = function (observer, subscriber) {
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup = subscriber(observer);
	    var subscription = cleanup;
	    if (cleanup != null) {
	      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch (e) {
	    observer.error(e);
	    return;
	  } if (subscriptionClosed(this)) cleanupSubscription(this);
	};

	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe() { closeSubscription(this); }
	});

	var SubscriptionObserver = function (subscription) {
	  this._s = subscription;
	};

	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if (m) return m.call(observer, value);
	      } catch (e) {
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = this._s;
	    if (subscriptionClosed(subscription)) throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if (!m) throw value;
	      value = m.call(observer, value);
	    } catch (e) {
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch (e) {
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});

	var $Observable = function Observable(subscriber) {
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};

	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn) {
	    var that = this;
	    return new (core.Promise || global.Promise)(function (resolve, reject) {
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next: function (value) {
	          try {
	            return fn(value);
	          } catch (e) {
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});

	redefineAll($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if (method) {
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          try {
	            if (forOf(x, false, function (it) {
	              observer.next(it);
	              if (done) return RETURN;
	            }) === RETURN) return;
	          } catch (e) {
	            if (done) throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  },
	  of: function of() {
	    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          for (var j = 0; j < items.length; ++j) {
	            observer.next(items[j]);
	            if (done) return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  }
	});

	hide($Observable.prototype, OBSERVABLE, function () { return this; });

	$export($export.G, { Observable: $Observable });

	__webpack_require__(41)('Observable');


	/***/ }),
	/* 340 */
	/***/ (function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global = __webpack_require__(2);
	var $export = __webpack_require__(0);
	var userAgent = __webpack_require__(100);
	var slice = [].slice;
	var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
	var wrap = function (set) {
	  return function (fn, time /* , ...args */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice.call(arguments, 2) : false;
	    return set(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
	    } : fn, time);
	  };
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout: wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});


	/***/ }),
	/* 341 */
	/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(0);
	var $task = __webpack_require__(96);
	$export($export.G + $export.B, {
	  setImmediate: $task.set,
	  clearImmediate: $task.clear
	});


	/***/ }),
	/* 342 */
	/***/ (function(module, exports, __webpack_require__) {

	var $iterators = __webpack_require__(95);
	var getKeys = __webpack_require__(37);
	var redefine = __webpack_require__(14);
	var global = __webpack_require__(2);
	var hide = __webpack_require__(13);
	var Iterators = __webpack_require__(49);
	var wks = __webpack_require__(6);
	var ITERATOR = wks('iterator');
	var TO_STRING_TAG = wks('toStringTag');
	var ArrayValues = Iterators.Array;

	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};

	for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
	  var NAME = collections[i];
	  var explicit = DOMIterables[NAME];
	  var Collection = global[NAME];
	  var proto = Collection && Collection.prototype;
	  var key;
	  if (proto) {
	    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
	    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
	  }
	}


	/***/ }),
	/* 343 */
	/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */

	!(function(global) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }

	    if (typeof global.process === "object" && global.process.domain) {
	      invoke = global.process.domain.bind(invoke);
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  runtime.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }

	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103)));

	/***/ }),
	/* 344 */
	/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(345);
	module.exports = __webpack_require__(22).RegExp.escape;


	/***/ }),
	/* 345 */
	/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(0);
	var $re = __webpack_require__(346)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

	$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


	/***/ }),
	/* 346 */
	/***/ (function(module, exports) {

	module.exports = function (regExp, replace) {
	  var replacer = replace === Object(replace) ? function (part) {
	    return replace[part];
	  } : replace;
	  return function (it) {
	    return String(it).replace(regExp, replacer);
	  };
	};


	/***/ }),
	/* 347 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(55), __webpack_require__(349), __webpack_require__(101), __webpack_require__(139), __webpack_require__(350), __webpack_require__(351), __webpack_require__(51), __webpack_require__(352), __webpack_require__(353), __webpack_require__(354), __webpack_require__(355), __webpack_require__(141), __webpack_require__(142), __webpack_require__(356), __webpack_require__(357), __webpack_require__(358), __webpack_require__(28), __webpack_require__(359), __webpack_require__(360), __webpack_require__(378), __webpack_require__(361), __webpack_require__(362), __webpack_require__(102), __webpack_require__(363), __webpack_require__(364), __webpack_require__(143), __webpack_require__(365), __webpack_require__(366), __webpack_require__(367), __webpack_require__(29), __webpack_require__(368), __webpack_require__(369), __webpack_require__(370), __webpack_require__(371), __webpack_require__(372), __webpack_require__(374), __webpack_require__(375), __webpack_require__(376), __webpack_require__(377), __webpack_require__(46), __webpack_require__(138)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphCore, _graphPosition, _graphLegend, _graphAxisX, _graphAxisY, _graphAxisXBar, _graphAxisXTime, _graphSerieLine, _graphSerieLine3d, _graphSerieBar, _graphSerieBox, _graphSerieLineColored, _graphSerieScatter, _graphSerieZone, _graphSerieZone3d, _graphSerieDensitymap, _graphSerieContour, _graphShape, _graphShapeAreaundercurve, _graphShapeArrow, _graphShapeEllipse, _graphShapeLabel, _graphShapePolyline, _graphShapeLine, _graphShapeNmrintegral, _graphShapePeakintegration2d, _graphShapeRect, _graphShapeCross, _graphShapePeakboundariescenter, _graphShapeHtml, _graphPlugin, _graphPluginDrag, _graphPluginShape, _graphPluginSelectScatter, _graphPluginZoom, _graphPluginTimeseriemanager, _graphPluginSerielinedifference, _graphPluginAxissplitting, _graphPluginMakeTracesDifferent, _graphPluginPeakpicking, _waveform, _fit_lm) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphCore2 = _interopRequireDefault(_graphCore);

	  var _graphPosition2 = _interopRequireDefault(_graphPosition);

	  var _graphLegend2 = _interopRequireDefault(_graphLegend);

	  var _graphAxisX2 = _interopRequireDefault(_graphAxisX);

	  var _graphAxisY2 = _interopRequireDefault(_graphAxisY);

	  var _graphAxisXBar2 = _interopRequireDefault(_graphAxisXBar);

	  var _graphAxisXTime2 = _interopRequireDefault(_graphAxisXTime);

	  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

	  var _graphSerieLine3d2 = _interopRequireDefault(_graphSerieLine3d);

	  var _graphSerieBar2 = _interopRequireDefault(_graphSerieBar);

	  var _graphSerieBox2 = _interopRequireDefault(_graphSerieBox);

	  var _graphSerieLineColored2 = _interopRequireDefault(_graphSerieLineColored);

	  var _graphSerieScatter2 = _interopRequireDefault(_graphSerieScatter);

	  var _graphSerieZone2 = _interopRequireDefault(_graphSerieZone);

	  var _graphSerieZone3d2 = _interopRequireDefault(_graphSerieZone3d);

	  var _graphSerieDensitymap2 = _interopRequireDefault(_graphSerieDensitymap);

	  var _graphSerieContour2 = _interopRequireDefault(_graphSerieContour);

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  var _graphShapeAreaundercurve2 = _interopRequireDefault(_graphShapeAreaundercurve);

	  var _graphShapeArrow2 = _interopRequireDefault(_graphShapeArrow);

	  var _graphShapeEllipse2 = _interopRequireDefault(_graphShapeEllipse);

	  var _graphShapeLabel2 = _interopRequireDefault(_graphShapeLabel);

	  var _graphShapePolyline2 = _interopRequireDefault(_graphShapePolyline);

	  var _graphShapeLine2 = _interopRequireDefault(_graphShapeLine);

	  var _graphShapeNmrintegral2 = _interopRequireDefault(_graphShapeNmrintegral);

	  var _graphShapePeakintegration2d2 = _interopRequireDefault(_graphShapePeakintegration2d);

	  var _graphShapeRect2 = _interopRequireDefault(_graphShapeRect);

	  var _graphShapeCross2 = _interopRequireDefault(_graphShapeCross);

	  var _graphShapePeakboundariescenter2 = _interopRequireDefault(_graphShapePeakboundariescenter);

	  var _graphShapeHtml2 = _interopRequireDefault(_graphShapeHtml);

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  var _graphPluginDrag2 = _interopRequireDefault(_graphPluginDrag);

	  var _graphPluginShape2 = _interopRequireDefault(_graphPluginShape);

	  var _graphPluginSelectScatter2 = _interopRequireDefault(_graphPluginSelectScatter);

	  var _graphPluginZoom2 = _interopRequireDefault(_graphPluginZoom);

	  var _graphPluginTimeseriemanager2 = _interopRequireDefault(_graphPluginTimeseriemanager);

	  var _graphPluginSerielinedifference2 = _interopRequireDefault(_graphPluginSerielinedifference);

	  var _graphPluginAxissplitting2 = _interopRequireDefault(_graphPluginAxissplitting);

	  var _graphPluginMakeTracesDifferent2 = _interopRequireDefault(_graphPluginMakeTracesDifferent);

	  var _graphPluginPeakpicking2 = _interopRequireDefault(_graphPluginPeakpicking);

	  var _waveform2 = _interopRequireDefault(_waveform);

	  var _fit_lm2 = _interopRequireDefault(_fit_lm);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  // Corrent naming is important here !

	  _graphCore2.default.registerConstructor('graph.position', _graphPosition2.default);

	  _graphCore2.default.registerConstructor('graph.axis.x', _graphAxisX2.default);
	  _graphCore2.default.registerConstructor('graph.axis.y', _graphAxisY2.default);
	  _graphCore2.default.registerConstructor('graph.axis.x.bar', _graphAxisXBar2.default);
	  _graphCore2.default.registerConstructor('graph.axis.x.time', _graphAxisXTime2.default);

	  _graphCore2.default.registerConstructor('graph.serie.line', _graphSerieLine2.default);
	  _graphCore2.default.registerConstructor('graph.serie.line.3d', _graphSerieLine3d2.default);
	  _graphCore2.default.registerConstructor('graph.serie.line.color', _graphSerieLineColored2.default);
	  _graphCore2.default.registerConstructor('graph.serie.contour', _graphSerieContour2.default);
	  _graphCore2.default.registerConstructor('graph.serie.bar', _graphSerieBar2.default);
	  _graphCore2.default.registerConstructor('graph.serie.box', _graphSerieBox2.default);
	  _graphCore2.default.registerConstructor('graph.serie.scatter', _graphSerieScatter2.default);
	  _graphCore2.default.registerConstructor('graph.serie.zone', _graphSerieZone2.default);
	  _graphCore2.default.registerConstructor('graph.serie.zone.3d', _graphSerieZone3d2.default);
	  _graphCore2.default.registerConstructor('graph.serie.densitymap', _graphSerieDensitymap2.default);

	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_LINE, _graphSerieLine2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_LINE_3D, _graphSerieLine3d2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_LINE_COLORED, _graphSerieLineColored2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_CONTOUR, _graphSerieContour2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_BAR, _graphSerieBar2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_BOX, _graphSerieBox2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_SCATTER, _graphSerieScatter2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_ZONE, _graphSerieZone2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_ZONE_3D, _graphSerieZone3d2.default);
	  _graphCore2.default.registerConstructor(_graphCore2.default.SERIE_DENSITYMAP, _graphSerieDensitymap2.default);

	  //Graph.registerConstructor( "graph.serie.line.broken", GraphSerieLineBroken );

	  _graphCore2.default.registerConstructor('graph.plugin.shape', _graphPluginShape2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.drag', _graphPluginDrag2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.zoom', _graphPluginZoom2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.selectScatter', _graphPluginSelectScatter2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.timeSerieManager', _graphPluginTimeseriemanager2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.serielinedifference', _graphPluginSerielinedifference2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.serieLineDifference', _graphPluginSerielinedifference2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.axissplitting', _graphPluginAxissplitting2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.makeTracesDifferent', _graphPluginMakeTracesDifferent2.default);
	  _graphCore2.default.registerConstructor('graph.plugin.peakPicking', _graphPluginPeakpicking2.default);

	  _graphCore2.default.registerConstructor('graph.shape', _graphShape2.default);
	  _graphCore2.default.registerConstructor('graph.shape.areaundercurve', _graphShapeAreaundercurve2.default);
	  _graphCore2.default.registerConstructor('graph.shape.arrow', _graphShapeArrow2.default);
	  _graphCore2.default.registerConstructor('graph.shape.ellipse', _graphShapeEllipse2.default);
	  _graphCore2.default.registerConstructor('graph.shape.label', _graphShapeLabel2.default);
	  _graphCore2.default.registerConstructor('graph.shape.polyline', _graphShapePolyline2.default);
	  _graphCore2.default.registerConstructor('graph.shape.line', _graphShapeLine2.default);
	  _graphCore2.default.registerConstructor('graph.shape.nmrintegral', _graphShapeNmrintegral2.default);
	  _graphCore2.default.registerConstructor('graph.shape.html', _graphShapeHtml2.default);
	  _graphCore2.default.registerConstructor('graph.shape.peakintegration2d', _graphShapePeakintegration2d2.default);
	  //  Graph.registerConstructor( "graph.shape.peakinterval", GraphShapePeakInterval );
	  //  Graph.registerConstructor( "graph.shape.peakinterval2", GraphShapePeakInterval2 );
	  //  Graph.registerConstructor( "graph.shape.rangex", GraphShapeRangeX );
	  _graphCore2.default.registerConstructor('graph.shape.rect', _graphShapeRect2.default);
	  _graphCore2.default.registerConstructor('graph.shape.rectangle', _graphShapeRect2.default);
	  _graphCore2.default.registerConstructor('graph.shape.cross', _graphShapeCross2.default);
	  //Graph.registerConstructor( "graph.shape.zoom2d", GraphShapeZoom2D );
	  _graphCore2.default.registerConstructor('graph.shape.peakboundariescenter', _graphShapePeakboundariescenter2.default);

	  //   Graph.registerConstructor( "graph.toolbar", GraphToolbar );
	  _graphCore2.default.registerConstructor('graph.legend', _graphLegend2.default);
	  _graphCore2.default.registerConstructor('graph.waveform', _waveform2.default);

	  exports.default = _graphCore2.default;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 348 */
	/***/ (function(module, exports, __webpack_require__) {


	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;

	var isArray = function isArray( arr ) {
	  if ( typeof Array.isArray === 'function' ) {
	    return Array.isArray( arr );
	  }

	  return toStr.call( arr ) === '[object Array]';
	};

	var isPlainObject = function isPlainObject( obj ) {
	  if ( !obj || toStr.call( obj ) !== '[object Object]' ) {
	    return false;
	  }

	  var hasOwnConstructor = hasOwn.call( obj, 'constructor' );
	  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call( obj.constructor.prototype, 'isPrototypeOf' );
	  // Not own constructor property must be Object
	  if ( obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf ) {
	    return false;
	  }

	  // Own properties are enumerated firstly, so to speed up,
	  // if last one is own, then all properties are own.
	  var key;
	  for ( key in obj ) { /**/ }

	  return typeof key === 'undefined' || hasOwn.call( obj, key );
	};

	module.exports = function extend() {
	  var options, name, src, copy, copyIsArray, clone;
	  var target = arguments[ 0 ];
	  var i = 1;
	  var length = arguments.length;
	  var deep = false;

	  // Handle a deep copy situation
	  if ( typeof target === 'boolean' ) {
	    deep = target;
	    target = arguments[ 1 ] || {};
	    // skip the boolean and the target
	    i = 2;
	  }
	  if ( target == null || ( typeof target !== 'object' && typeof target !== 'function' ) ) {
	    target = {};
	  }

	  for ( ; i < length; ++i ) {
	    options = arguments[ i ];
	    // Only deal with non-null/undefined values
	    if ( options != null ) {
	      // Extend the base object
	      for ( name in options ) {
	        src = target[ name ];
	        copy = options[ name ];

	        // Prevent never-ending loop
	        if ( target !== copy ) {
	          // Recurse if we're merging plain objects or arrays
	          if ( deep && copy && ( isPlainObject( copy ) || ( copyIsArray = isArray( copy ) ) ) ) {
	            if ( copyIsArray ) {
	              copyIsArray = false;
	              clone = src && isArray( src ) ? src : [];
	            } else {
	              clone = src && isPlainObject( src ) ? src : {};
	            }

	            // Never move original objects, clone them
	            target[ name ] = extend( deep, clone, copy );

	            // Don't bring in undefined values
	          } else if ( typeof copy !== 'undefined' ) {
	            target[ name ] = copy;
	          }
	        }
	      }
	    }
	  }

	  // Return the modified object
	  return target;
	};

	/***/ }),
	/* 349 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(55), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphPosition, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphPosition2 = _interopRequireDefault(_graphPosition);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  /**
	   * Default legend configuration
	   * @name LegendOptionsDefault
	   * @object
	   * @static
	   * @prop {Boolean} frame - <code>true</code> to display a frame around the legend
	   * @prop {Number} frameWidth - The width of the frame stroke
	   * @prop {String} frameColor - The stroke color of the frame
	   * @prop {String} backgroundColor - The background color of the frame
	   * @prop {Number} paddingLeft - The left padding
	   * @prop {Number} paddingRight - The right padding
	   * @prop {Number} paddingTop - The top padding
	   * @prop {Number} paddingBottom - The bottom padding
	   * @prop {Boolean} shapesToggleable - <code>true</code> to toggle the shapes linked to serie with its status (shown or hidden)
	   * @prop {Boolean} isSerieHideable - <code>true</code> to allow series to be hidden through the legend
	   * @prop {Boolean} isSerieSelectable - <code>true</code> to allow series to be selected through the legend
	   */
	  var legendDefaults = {

	    backgroundColor: 'rgba(255, 255, 255, 0.8)',
	    frame: true,
	    frameWidth: 1,
	    frameColor: 'black',
	    paddingTop: 10,
	    paddingLeft: 10,
	    paddingBottom: 10,
	    paddingRight: 10,
	    color: 'black',
	    frameRounding: 0,

	    movable: false,

	    shapesToggleable: true,
	    isSerieHideable: true,
	    isSerieSelectable: true

	  };

	  /**
	   * Legend constructor. You should not call this method directly, but rather use {@link graph.makeLegend}
	   * @example var legend = graph.makeLegend( {  backgroundColor: 'rgba(255, 255, 255, 0.8)',
	   * frame: true,
	   * frameWidth: 1,
	   * frameColor: 'black',
	   * paddingTop: 10,
	   * paddingLeft: 10,
	   * paddingBottom: 10,
	   * paddingRight: 10,
	   * frameRounding: 3,
	   *
	   * movable: false,
	   *
	   * shapesToggleable: true,
	   * isSerieHideable: true,
	   * isSerieSelectable: true
	   * } );
	   */

	  var Legend = function () {
	    function Legend(graph, options) {
	      _classCallCheck(this, Legend);

	      this.options = util.extend({}, legendDefaults, options);

	      this.graph = graph;
	      this.svg = document.createElementNS(this.graph.ns, 'g');
	      this.subG = document.createElementNS(this.graph.ns, 'g');

	      this.groups = [];
	      this.rect = document.createElementNS(this.graph.ns, 'rect');
	      this.rectBottom = document.createElementNS(this.graph.ns, 'rect');

	      this.rect.setAttribute('x', 0);
	      this.rect.setAttribute('y', 0);

	      this.rectBottom.setAttribute('x', 0);
	      this.rectBottom.setAttribute('y', 0);

	      this.series = false;

	      this.svg.setAttribute('display', 'none');
	      this.pos = {
	        x: undefined,
	        y: undefined,
	        transformX: 0,
	        transformY: 0
	      };

	      this.setEvents();

	      this.eyeId = util.guid();
	      this.eyeCrossedId = util.guid();

	      var eyeClosed = util.SVGParser('<svg xmlns="http://www.w3.org/2000/svg"><symbol id="' + this.eyeCrossedId + '" viewBox="0 -256 1850 1850"><rect pointer-events="fill" fill="transparent" x="-256" y="0" width="2106" height="1850" /><g transform="matrix(1,0,0,-1,30.372881,1214.339)"><path d="m 555,201 78,141 q -87,63 -136,159 -49,96 -49,203 0,121 61,225 Q 280,812 128,576 295,318 555,201 z m 389,759 q 0,20 -14,34 -14,14 -34,14 -125,0 -214.5,-89.5 Q 592,829 592,704 q 0,-20 14,-34 14,-14 34,-14 20,0 34,14 14,14 14,34 0,86 61,147 61,61 147,61 20,0 34,14 14,14 14,34 z m 363,191 q 0,-7 -1,-9 Q 1201,954 991,576 781,198 675,9 l -49,-89 q -10,-16 -28,-16 -12,0 -134,70 -16,10 -16,28 0,12 44,87 Q 349,154 228.5,262 108,370 20,507 0,538 0,576 q 0,38 20,69 153,235 380,371 227,136 496,136 89,0 180,-17 l 54,97 q 10,16 28,16 5,0 18,-6 13,-6 31,-15.5 18,-9.5 33,-18.5 15,-9 31.5,-18.5 16.5,-9.5 19.5,-11.5 16,-10 16,-27 z m 37,-447 Q 1344,565 1265,450.5 1186,336 1056,286 l 280,502 q 8,-45 8,-84 z m 448,-128 q 0,-35 -20,-69 Q 1733,443 1663,362 1513,190 1315.5,95 1118,0 896,0 l 74,132 q 212,18 392.5,137 180.5,119 301.5,307 -115,179 -282,294 l 63,112 q 95,-64 182.5,-153 87.5,-89 144.5,-184 20,-34 20,-69 z" fill="#c0c0c0"></path></g></symbol></svg>');
	      //  var eyeClosed = util.SVGParser('<svg xmlns="http://www.w3.org/2000/svg"><symbol id="' + this.eyeId + '" viewBox="0 0 100 100"><rect fill="black" x="0" y="0" width="100" height="100" /></symbol></svg>');

	      /* var eyeClosed = document.createElementNS( this.graph.ns, "symbol");
	        eyeClosed.setAttribute('id', this.eyeId );
	        eyeClosed.setAttribute("viewBox", '0 0 100 100');
	         var rect = document.createElementNS( this.graph.ns, "rect" );
	        rect.setAttribute('width', 100 );
	        rect.setAttribute('height', 100 );
	        rect.setAttribute('x', 0 );
	        rect.setAttribute('y', 0 );
	        rect.setAttribute('fill', 'black');
	        eyeClosed.appendChild( rect );
	      */
	      var eye = util.SVGParser('<svg xmlns="http://www.w3.org/2000/svg"><symbol id="' + this.eyeId + '" viewBox="0 -256 1850 1850"><rect pointer-events="fill" x="-256" y="0" fill="transparent" width="2106" height="1850" /><g transform="matrix(1,0,0,-1,30.372881,1259.8983)"><path d="m 1664,576 q -152,236 -381,353 61,-104 61,-225 0,-185 -131.5,-316.5 Q 1081,256 896,256 711,256 579.5,387.5 448,519 448,704 448,825 509,929 280,812 128,576 261,371 461.5,249.5 662,128 896,128 1130,128 1330.5,249.5 1531,371 1664,576 z M 944,960 q 0,20 -14,34 -14,14 -34,14 -125,0 -214.5,-89.5 Q 592,829 592,704 q 0,-20 14,-34 14,-14 34,-14 20,0 34,14 14,14 14,34 0,86 61,147 61,61 147,61 20,0 34,14 14,14 14,34 z m 848,-384 q 0,-34 -20,-69 Q 1632,277 1395.5,138.5 1159,0 896,0 633,0 396.5,139 160,278 20,507 0,542 0,576 q 0,34 20,69 140,229 376.5,368 236.5,139 499.5,139 263,0 499.5,-139 236.5,-139 376.5,-368 20,-35 20,-69 z" fill="#444444" /></g></symbol></svg>');

	      this.svg.appendChild(document.adoptNode(eye.documentElement.firstChild));
	      this.svg.appendChild(document.adoptNode(eyeClosed.documentElement.firstChild));

	      this.svg.appendChild(this.subG);

	      this.applyStyle();
	    }

	    /**
	     * Sets the position of the legend
	     * @param {Position} position - the position to set the legend to versus the graph main axes ({@link Graph#getXAxis} and {@link Graph#getYAxis})
	     * @param {String} alignToX - "right" or "left". References the legend right or left boundary using the position parameter
	     * @param {String} alignToY - "top" or "bottom". References the legend top or bottom boundary using the position parameter
	     * @example legend.setPosition( { x: 'max', y: '0px' }, 'right', 'top' ); // The rightmost side of the legend will at the maximum value of the axis, and will be positioned at the top
	     */


	    _createClass(Legend, [{
	      key: 'setPosition',
	      value: function setPosition(position, alignToX, alignToY) {

	        if (!position) {
	          return;
	        }

	        this.position = position;
	        this.alignToX = alignToX || 'left';
	        this.alignToY = alignToY || 'top';
	      }
	    }, {
	      key: 'setDraggable',
	      value: function setDraggable(bln) {
	        this.options.movable = bln;
	      }
	    }, {
	      key: 'setAutoPosition',
	      value: function setAutoPosition(position) {

	        if (['bottom', 'left', 'top', 'right'].indexOf(position = position.toLowerCase()) > -1) {
	          this.autoPosition = position;
	          return this;
	        }

	        this.requireDelayedUpdate();
	        this.autoPosition = false;
	      }
	    }, {
	      key: 'autoPosition',
	      value: function autoPosition() {
	        return this.setAutoPosition.apply(this, arguments);
	      }
	    }, {
	      key: 'buildLegendBox',
	      value: function buildLegendBox() {

	        var series = this.series || this.graph.getSeries(),
	            posX = 0,
	            posY = this.options.paddingTop;

	        if (!this.autoPosition) {
	          this.graph.graphingZone.appendChild(this.getDom());
	        } else {
	          this.graph.getDom().appendChild(this.getDom());
	        }

	        for (var i = 0, l = series.length; i < l; i++) {

	          if (series[i].excludedFromLegend && !this.series) {
	            continue;
	          }

	          if (this.autoPosition == 'bottom' || this.autoPosition == 'top') {

	            var bbox = getBBox(this.groups[i]);

	            if (posX + bbox.width > this.graph.getDrawingWidth() - this.options.paddingRight) {
	              posY += 16;
	              posX = 0;
	            }
	          }

	          this.groups[i].setAttribute('transform', 'translate( ' + posX + ', ' + posY + ')');

	          if (this.autoPosition == 'bottom' || this.autoPosition == 'top') {

	            posX += bbox.width + 10;
	            posY += 0;
	          } else {

	            posX = 0;
	            posY += 16;
	          }
	        }

	        var bbox = getBBox(this.subG);

	        /* Independant on box position */
	        this.width = bbox.width + this.options.paddingRight + this.options.paddingLeft;
	        this.height = bbox.height + this.options.paddingBottom + this.options.paddingTop;

	        this.rect.setAttribute('width', this.width);
	        this.rect.setAttribute('height', this.height);
	        this.rect.setAttribute('fill', 'none');
	        this.rect.setAttribute('pointer-events', 'fill');

	        this.rect.setAttribute('display', 'none');

	        if (this.options.movable) {
	          this.rectBottom.style.cursor = 'move';
	        }

	        this.rectBottom.setAttribute('width', this.width);
	        this.rectBottom.setAttribute('height', this.height);

	        this.rectBottom.setAttribute('x', bbox.x - this.options.paddingLeft);
	        this.rectBottom.setAttribute('y', bbox.y - this.options.paddingTop);
	        /* End independant on box position */

	        this.position = this.position || {};

	        switch (this.autoPosition) {

	          case 'bottom':
	            this.position.y = this.graph.getHeight() + 'px';
	            // Try to center with respect to the drawing space, not the full graph. It's useful when the graph is fairly asymmetric (i.e. multiple axes on 1 side)
	            this.position.x = (this.graph.drawingSpaceWidth - this.width) / 2 + this.graph.drawingSpaceMinX + 'px';
	            this.alignToY = 'bottom';
	            this.alignToX = false;
	            break;

	          case 'left':
	            this.position.x = '6px';
	            this.position.y = (this.graph.getHeight() - this.height) / 2 + 'px';
	            this.alignToX = 'left';
	            this.alignToY = false;
	            break;

	          case 'right':
	            this.position.x = this.graph.getWidth() + 'px';
	            this.position.y = (this.graph.getHeight() - this.height) / 2 + 'px';
	            this.alignToX = 'right';
	            this.alignToY = false;
	            break;

	          case 'top':
	            this.position.x = (this.graph.drawingSpaceWidth - this.width) / 2 + this.graph.drawingSpaceMinX + 'px';
	            this.position.y = '10px';
	            this.alignToY = 'top';
	            this.alignToX = false;
	            break;
	        }

	        if (this.autoPosition) {
	          switch (this.autoPosition) {

	            case 'bottom':
	              this.graph.options.paddingBottom = this.height + 10;
	              break;

	            case 'left':
	              this.graph.options.paddingLeft = this.width + 5;
	              break;

	            case 'right':
	              this.graph.options.paddingRight = this.width + 10;
	              break;

	            case 'top':
	              this.graph.options.paddingTop = this.height + 14;
	              break;
	          }

	          this.graph.updateGraphingZone();
	          this.graph.getDrawingHeight();
	          this.graph.getDrawingWidth();
	          // this.graph.redraw( false );
	        }

	        this.bbox = bbox;
	      }
	    }, {
	      key: 'calculatePosition',
	      value: function calculatePosition() {

	        var pos = _graphPosition2.default.check(this.position);
	        var poscoords = pos.compute(this.graph, this.graph.getXAxis(), this.graph.getYAxis());

	        if (!poscoords) {
	          return;
	        }

	        if (pos.y == 'max') {
	          poscoords.y += this.graph.getPaddingTop();
	        }

	        if (pos.x == 'max') {
	          poscoords.x -= this.graph.getPaddingRight();
	        }

	        if (this.alignToX == 'right') {
	          poscoords.x -= this.width;
	          poscoords.x -= this.bbox.x;
	        }

	        if (this.alignToY == 'bottom') {
	          poscoords.y -= this.height;
	          poscoords.y -= this.bbox.y;
	        } else {

	          poscoords.y -= this.bbox.y;
	        }

	        this.pos.transformX = poscoords.x;
	        this.pos.transformY = poscoords.y;

	        this._setPosition();
	      }
	    }, {
	      key: 'update',
	      value: function update(onlyIfRequired) {

	        if (this.graph.isDelayedUpdate() || !this._requiredUpdate && onlyIfRequired) {
	          return;
	        }

	        this._requiredUpdate = false;

	        var self = this;

	        this.applyStyle();

	        while (this.subG.hasChildNodes()) {
	          this.subG.removeChild(this.subG.lastChild);
	        }

	        this.svg.insertBefore(this.rectBottom, this.svg.firstChild);

	        var series = this.series || this.graph.getSeries();

	        if (series.length > 0) {
	          this.svg.setAttribute('display', 'block');
	        } else {
	          return;
	        }

	        if (this.autoPosition == 'bottom' || this.autoPosition == 'top') {
	          var fullWidth = this.graph.getDrawingWidth();
	        }

	        for (var i = 0, l = series.length; i < l; i++) {

	          if (series[i].excludedFromLegend && !this.series) {
	            continue;
	          }

	          (function (j) {

	            var g,
	                line,
	                text;

	            if (this.autoPosition == 'bottom' || this.autoPosition == 'top') {
	              var fullWidth = this.graph.getDrawingWidth();
	            }

	            g = document.createElementNS(self.graph.ns, 'g');
	            var rect = document.createElementNS(self.graph.ns, 'rect');

	            self.subG.appendChild(g);

	            g.appendChild(rect);

	            var line = series[j].getSymbolForLegend();
	            var marker = series[j].getMarkerForLegend();
	            var text = series[j].getTextForLegend();

	            var dx = 35;

	            if (this.isHideable()) {
	              dx += 20;

	              var eyeUse = document.createElementNS(self.graph.ns, 'use');
	              eyeUse.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + (series[i].isShown() ? this.eyeId : this.eyeCrossedId));
	              eyeUse.setAttribute('width', 15);
	              eyeUse.setAttribute('height', 15);
	              eyeUse.setAttribute('x', 35);
	              eyeUse.setAttribute('y', -8);

	              eyeUse.addEventListener('click', function (e) {
	                e.stopPropagation();

	                var id;
	                if (series[j].isShown()) {
	                  series[j].hide(self.options.hideShapesOnHideSerie);
	                  id = self.eyeCrossedId;
	                } else {
	                  series[j].show(self.options.hideShapesOnHideSerie);
	                  id = self.eyeId;
	                }

	                eyeUse.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + id);
	              });
	            }

	            text.setAttribute('transform', 'translate(' + dx + ', 3)');

	            text.setAttribute('color', this.options.color);

	            if (line) {
	              g.appendChild(line);
	            }

	            if (series[j].getType() == 'scatter') {
	              line.setAttribute('transform', 'translate( 20, 0 )');
	            }

	            if (marker) {
	              g.appendChild(marker);
	            }

	            if (eyeUse) {
	              g.appendChild(eyeUse);
	            }

	            g.appendChild(text);

	            var bbox = getBBox(g);

	            rect.setAttribute('x', bbox.x);
	            rect.setAttribute('y', bbox.y);
	            rect.setAttribute('width', bbox.width);
	            rect.setAttribute('height', bbox.height);
	            rect.setAttribute('fill', 'none');
	            rect.setAttribute('pointer-events', 'fill');

	            self.groups[j] = g;

	            g.addEventListener('click', function (e) {

	              var serie = series[j];

	              if (!serie.isShown()) {
	                return;
	              }

	              if (self.isSelectable() && !serie.isSelected()) {

	                self.graph.selectSerie(serie);
	              } else {

	                self.graph.unselectSerie(serie);
	              }

	              e.preventDefault();
	              e.stopPropagation();
	            });
	          }).call(this, i);
	        }

	        this.svg.appendChild(this.rect);
	        this.buildLegendBox();
	        this.calculatePosition();
	      }
	    }, {
	      key: 'isHideable',
	      value: function isHideable() {
	        return this.options.isSerieHideable;
	      }
	    }, {
	      key: 'notHideable',
	      value: function notHideable() {
	        this.options.isSerieHideable = false;
	        return this;
	      }
	    }, {
	      key: 'hideable',
	      value: function hideable() {
	        this.options.isSerieHideable = true;
	        return this;
	      }
	    }, {
	      key: 'isSelectable',
	      value: function isSelectable() {
	        return this.options.isSerieSelectable;
	      }
	    }, {
	      key: 'isToggleShapes',
	      value: function isToggleShapes() {
	        return this.options.shapesToggleable;
	      }
	    }, {
	      key: 'getDom',
	      value: function getDom() {
	        return this.svg;
	      }
	    }, {
	      key: 'setEvents',
	      value: function setEvents() {

	        var self = this;
	        var pos = this.pos;

	        var mousedown = function mousedown(e) {

	          e.stopPropagation();
	          console.log('down');
	          if (self.options.movable) {
	            pos.x = e.clientX;
	            pos.y = e.clientY;

	            e.preventDefault();
	            self.mousedown = true;
	            self.graph.elementMoving(self);

	            self.rect.setAttribute('display', 'block');
	          }
	        };

	        var mousemove = function mousemove(e) {
	          self.handleMouseMove(e);
	        };

	        this.svg.addEventListener('mousedown', mousedown);
	        this.svg.addEventListener('click', function (e) {
	          e.stopPropagation();
	        });
	        this.svg.addEventListener('dblclick', function (e) {
	          e.stopPropagation();
	        });
	        this.svg.addEventListener('mousemove', mousemove);
	        //this.rect.addEventListener( 'mousemove', mousemove );
	      }
	    }, {
	      key: 'handleMouseUp',
	      value: function handleMouseUp(e) {

	        e.stopPropagation();
	        e.preventDefault();
	        this.mousedown = false;
	        this.rect.setAttribute('display', 'none');
	        this.graph.elementMoving(false);
	      }
	    }, {
	      key: 'handleMouseMove',
	      value: function handleMouseMove(e) {

	        if (!this.mousedown) {
	          return;
	        }

	        var pos = this.pos;

	        var deltaX = e.clientX - pos.x;
	        var deltaY = e.clientY - pos.y;

	        pos.transformX += deltaX;
	        pos.transformY += deltaY;

	        pos.x = e.clientX;
	        pos.y = e.clientY;

	        e.stopPropagation();
	        e.preventDefault();

	        this._setPosition();
	      }
	    }, {
	      key: '_setPosition',
	      value: function _setPosition() {

	        var pos = this.pos;
	        if (!isNaN(pos.transformX) && !isNaN(pos.transformY) && pos.transformX !== false && pos.transformY !== false) {
	          this.svg.setAttribute('transform', 'translate(' + pos.transformX + ', ' + pos.transformY + ')');
	        }
	      }
	    }, {
	      key: 'applyStyle',
	      value: function applyStyle() {

	        if (this.options.frame) {
	          this.rectBottom.setAttribute('stroke', this.options.frameColor);
	          this.rectBottom.setAttribute('stroke-width', this.options.frameWidth + 'px');
	          this.rectBottom.setAttribute('rx', this.options.frameRounding);
	          this.rectBottom.setAttribute('ry', this.options.frameRounding);
	        }

	        this.rectBottom.setAttribute('fill', this.options.backgroundColor);
	      }
	    }, {
	      key: 'fixSeries',
	      value: function fixSeries() {
	        var series = [];

	        if (arguments[0] === false) {
	          this.series = false;
	          this.update();
	          return;
	        }

	        for (var i = 0, l = arguments.length; i < l; i++) {
	          if (Array.isArray(arguments[i])) {
	            series = series.concat(arguments[i]);
	          } else {
	            series.push(arguments[i]);
	          }
	        }

	        this.update();
	        this.series = series;
	      }
	    }, {
	      key: 'fixSeriesAdd',
	      value: function fixSeriesAdd(serie) {
	        this.series = this.series || [];
	        this.series.push(serie);
	      }
	    }, {
	      key: 'requireDelayedUpdate',
	      value: function requireDelayedUpdate() {
	        this._requiredUpdate = true;
	      }
	    }, {
	      key: 'seriesHideable',
	      set: function set(hideable) {
	        this.options.isSerieHideable = !!hideable;
	      },
	      get: function get() {
	        return this.options.isSerieHideable;
	      }
	    }]);

	    return Legend;
	  }();

	  function getBBox(svgElement) {
	    // Firefox throws when trying to call getBBox() on elements
	    // that are not yet rendered.
	    try {
	      return svgElement.getBBox();
	    } catch (e) {
	      return {
	        height: 0,
	        width: 0,
	        x: 0,
	        y: 0
	      };
	    }
	  }

	  exports.default = Legend;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 350 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(101)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphAxisX) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphAxisX2 = _interopRequireDefault(_graphAxisX);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var AxisXBar = function (_AxisX) {
	    _inherits(AxisXBar, _AxisX);

	    function AxisXBar(graph, topbottom) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      _classCallCheck(this, AxisXBar);

	      return _possibleConstructorReturn(this, (AxisXBar.__proto__ || Object.getPrototypeOf(AxisXBar)).call(this, graph, topbottom, options));
	    }

	    /**
	     * @param {Object[]} categories - Categories array
	     * @param {(String|Number)} categories[].title - The title of the category (to be dispalyed)
	     * @param {(String|Number)} categories[].name - The name of the category (to indentify series)
	     * @returns {AxisBar} The current axis instance
	     */


	    _createClass(AxisXBar, [{
	      key: 'draw',
	      value: function draw() {

	        var self = this,
	            tickLabel,
	            elements = this._barCategories;

	        this.forceMin(0);
	        this.forceMax(1);

	        this.cacheCurrentMin();
	        this.cacheCurrentMax();
	        this.cacheInterval();

	        if (!elements) {
	          return;
	        }

	        if (!Array.isArray(elements)) {
	          elements = [elements];
	        }

	        // this.drawInit();

	        //var widthPerElement = width / elements.length;
	        for (var i = 0; i <= elements.length; i++) {
	          this.drawTick(i / elements.length, 2);

	          if (i < elements.length) {
	            tickLabel = this.nextTickLabel(function (tickLabel) {

	              tickLabel.setAttribute('y', (self.top ? -1 : 1) * ((self.options.tickPosition == 1 ? 8 : 20) + (self.top ? 10 : 0)));
	              tickLabel.setAttribute('text-anchor', 'middle');
	              if (self.getTicksLabelColor() !== 'black') {
	                tickLabel.setAttribute('fill', self.getTicksLabelColor());
	              }
	              tickLabel.style.dominantBaseline = 'hanging';
	            });

	            tickLabel.setAttribute('x', this.getPos((i + 0.5) / elements.length));
	            tickLabel.textContent = elements[i].title;
	          }
	        }

	        this.drawSpecifics();
	        return this;
	      }
	    }, {
	      key: 'autoSeries',
	      value: function autoSeries() {

	        var series = [];
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = this.graph.series[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var serie = _step.value;

	            if (serie.getXAxis() == this) {
	              series.push(serie);
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }

	        this.setSeries.apply(this, series);
	        return this;
	      }
	    }, {
	      key: 'setSeries',
	      value: function setSeries() {

	        var self = this;
	        this.series = arguments;

	        Array.prototype.map.call(this.series, function (serie, index) {

	          if (!((typeof serie === 'undefined' ? 'undefined' : _typeof(serie)) == 'object')) {
	            serie = self.graph.getSerie(serie);
	          }

	          if (serie.setCategoryConfig) {
	            serie.setCategoryConfig(index, self._barCategories, self.series.length);
	          }
	        });

	        this._getUsedCategories();

	        return this;
	      }
	    }, {
	      key: '_getUsedCategories',
	      value: function _getUsedCategories() {

	        var categories = {},
	            total = 0;

	        Array.prototype.map.call(this.series, function (serie) {
	          var usedCategories = serie.getUsedCategories();
	          var _iteratorNormalCompletion2 = true;
	          var _didIteratorError2 = false;
	          var _iteratorError2 = undefined;

	          try {
	            for (var _iterator2 = usedCategories[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	              var cat = _step2.value;


	              if (!categories.hasOwnProperty(cat)) {
	                categories[cat] = 1;
	                total += 1;
	              }

	              categories[cat]++;
	              total++;
	            }
	          } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	              }
	            } finally {
	              if (_didIteratorError2) {
	                throw _iteratorError2;
	              }
	            }
	          }
	        });

	        var accumulator = 0;
	        for (var i in categories) {
	          var temp = categories[i];
	          categories[i] = accumulator;
	          accumulator += temp;
	        }

	        var dispatchedCategories = {};

	        Array.prototype.map.call(this.series, function (serie) {

	          var scategories = serie.getUsedCategories(),
	              indices = {};

	          scategories.forEach(function (cat) {

	            dispatchedCategories[cat] = dispatchedCategories[cat] || 0.5;
	            indices[cat] = (categories[cat] + dispatchedCategories[cat]) / total;
	            dispatchedCategories[cat]++;
	          });

	          serie.setDataIndices(indices, total);
	        });
	      }
	    }, {
	      key: 'getType',
	      value: function getType() {
	        return 'category';
	      }
	    }, {
	      key: 'categories',
	      set: function set(categories) {
	        this._barCategories = categories;
	        return this;
	      }
	    }]);

	    return AxisXBar;
	  }(_graphAxisX2.default);

	  exports.default = AxisXBar;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 351 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(72), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphAxis, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphAxis2 = _interopRequireDefault(_graphAxis);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var axisFormat = [{

	    threshold: 20,
	    increments: {

	      1: {
	        increment: 1, // 1 minute
	        unit: 'i',
	        format: 'HH"h"MM (dd/mm/yy)'
	      },

	      2: { // 10 seconds
	        increment: 1,
	        unit: 's',
	        format: 'MM:ss"s"'
	      }
	    }
	  }, {

	    threshold: 50,
	    increments: {

	      1: {
	        increment: 1, // 1 minute
	        unit: 'i',
	        format: 'HH"h"MM (dd/mm/yy)'
	      },

	      2: { // 2 seconds
	        increment: 2,
	        unit: 's',
	        format: 'MM:ss"s"'
	      }
	    }
	  }, {

	    threshold: 100,
	    increments: {

	      1: {
	        increment: 1, // 1 minute
	        unit: 'i',
	        format: 'HH"h"MM (dd/mm/yy)'
	      },

	      2: { // 5 seconds
	        increment: 5,
	        unit: 's',
	        format: 'MM:ss"s"'
	      }
	    }
	  }, {

	    threshold: 600,
	    increments: {

	      1: {
	        increment: 10, // 1 minute
	        unit: 'i',
	        format: 'HH"h"MM (dd/mm/yy)'
	      },

	      2: { // 10 seconds
	        increment: 30,
	        unit: 's',
	        format: 'MM:ss"s"'
	      }
	    }
	  }, { // One day

	    threshold: 1000,
	    increments: {

	      1: { // 1h
	        increment: 1,
	        unit: 'h',
	        format: 'HH"h"MM (dd/mm/yy)'
	      },

	      2: { // 10 minutes
	        increment: 10,
	        unit: 'i',
	        format: 'MM"min"'
	      }
	    }
	  }, { // One day

	    threshold: 1500,
	    increments: {

	      1: {
	        increment: 1, // One day on the first axis
	        unit: 'd',
	        format: 'dd/mm/yyyy'
	      },

	      2: {
	        increment: 1,
	        unit: 'i',
	        format: 'H"h"MM'
	      }
	    }
	  }, { // One day

	    threshold: 3000,
	    increments: {

	      1: {
	        increment: 1, // One day on the first axis
	        unit: 'd',
	        format: 'dd/mm/yyyy'
	      },

	      2: {
	        increment: 2,
	        unit: 'i',
	        format: 'H"h"MM'
	      }
	    }
	  }, { // One day

	    threshold: 8000,
	    increments: {

	      1: {
	        increment: 1, // One day on the first axis
	        unit: 'd',
	        format: 'dd/mm/yyyy'
	      },

	      2: {
	        increment: 10,
	        unit: 'i',
	        format: 'H"h"MM'
	      }
	    }
	  }, { // One day

	    threshold: 26400,
	    increments: {

	      1: {
	        increment: 1, // One day on the first axis
	        unit: 'd',
	        format: 'dd/mm/yyyy'
	      },

	      2: {
	        increment: 20,
	        unit: 'i',
	        format: 'H"h"MM'
	      }
	    }
	  }, { // One day

	    threshold: 86400,
	    increments: {

	      1: {
	        increment: 1, // One day on the first axis
	        unit: 'd',
	        format: 'dd/mm/yyyy'
	      },

	      2: {
	        increment: 1,
	        unit: 'h',
	        format: 'H"h"MM'
	      }
	    }
	  }, { // One day

	    threshold: 200000,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'd',
	        format: 'dd/mm/yyyy'
	      },

	      2: {

	        increment: 2, // One day on the first axis
	        unit: 'h',
	        format: 'H"h"MM'
	      }
	    }
	  }, { // One day

	    threshold: 400000,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'd',
	        format: 'dd/mm/yyyy'
	      },

	      2: {

	        increment: 6, // One day on the first axis
	        unit: 'h',
	        format: 'H"h"MM'
	      }
	    }
	  }, { // One day

	    threshold: 1400000,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'd',
	        format: 'dd/mm/yyyy'
	      },

	      2: {

	        increment: 12, // One day on the first axis
	        unit: 'h',
	        format: 'HH"h"MM'
	      }
	    }
	  }, { // One day

	    threshold: 6400000,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'm',
	        format: 'mmmm yyyy'
	      },

	      2: {

	        increment: 1, // One day on the first axis
	        unit: 'd',
	        format: 'dd'
	      }
	    }
	  }, { // One day

	    threshold: 12400000,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'm',
	        format: 'mmmm yyyy'
	      },

	      2: {

	        increment: 2, // One day on the first axis
	        unit: 'd',
	        format: 'dd'
	      }
	    }
	  }, { // One day

	    threshold: 86400000 * 0.5,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'm',
	        format: 'mmmm yyyy'
	      },

	      2: {

	        increment: 7, // One day on the first axis
	        unit: 'd',
	        format: 'dd'
	      }
	    }
	  }, { // One day

	    threshold: 86400000 * 0.8,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'm',
	        format: 'mmmm yyyy'
	      },

	      2: {

	        increment: 15, // One day on the first axis
	        unit: 'd',
	        format: 'dd'
	      }
	    }
	  }, { // One month

	    threshold: 86400000 * 1,
	    increments: {

	      1: {
	        increment: 1,
	        unit: 'y',
	        format: 'yyyy'
	      },

	      2: {

	        increment: 3, // One day on the first axis
	        unit: 'm',
	        format: 'mm/yyyy'
	      }
	    }
	  }, { // One month

	    threshold: 86400000 * 2,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'y',
	        format: 'yyyy'
	      },

	      2: {

	        increment: 4, // One day on the first axis
	        unit: 'm',
	        format: 'mm/yyyy'
	      }
	    }
	  }, { // One month

	    threshold: 86400000 * 10,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'y',
	        format: 'yyyy'
	      },

	      2: {

	        increment: 6, // One day on the first axis
	        unit: 'm',
	        format: 'mm/yyyy'
	      }
	    }
	  }, { // One month

	    threshold: 86400000 * 12,
	    increments: {

	      1: {

	        increment: 1,
	        unit: 'y',
	        format: 'yyyy'
	      },

	      2: {

	        increment: 1, // One day on the first axis
	        unit: 'y',
	        format: 'yyyy'
	      }
	    }
	  }];

	  /*
	   * Date Format 1.2.3
	   * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
	   * MIT license
	   *
	   * Includes enhancements by Scott Trenda <scott.trenda.net>
	   * and Kris Kowal <cixar.com/~kris.kowal/>
	   *
	   * Accepts a date, a mask, or a date and a mask.
	   * Returns a formatted version of the given date.
	   * The date defaults to the current date/time.
	   * The mask defaults to dateFormat.masks.default.
	   */

	  var dateFormat = function () {
	    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[WLloSZ]|"[^"]*"|'[^']*'/g,
	        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
	        timezoneClip = /[^-+\dA-Z]/g,
	        pad = function pad(val, len) {
	      val = String(val);
	      len = len || 2;
	      while (val.length < len) {
	        val = '0' + val;
	      }return val;
	    },
	        getWeek = function getWeek(d, f) {
	      var onejan = new Date(d[f + 'FullYear'](), 0, 1);
	      return Math.ceil(((d - onejan) / 86400000 + onejan[f + 'Day']() + 1) / 7);
	    };

	    // Regexes and supporting functions are cached through closure
	    return function (date, mask, utc) {
	      var dF = dateFormat;

	      // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
	      if (arguments.length == 1 && Object.prototype.toString.call(date) == '[object String]' && !/\d/.test(date)) {
	        mask = date;
	        date = undefined;
	      }

	      // Passing date through Date applies Date.parse, if necessary
	      date = date ? new Date(date) : new Date();
	      if (isNaN(date)) throw SyntaxError('invalid date:' + date);

	      mask = String(dF.masks[mask] || mask || dF.masks.default);

	      // Allow setting the utc argument via the mask
	      if (mask.slice(0, 4) == 'UTC:') {
	        mask = mask.slice(4);
	        utc = true;
	      }

	      var _ = utc ? 'getUTC' : 'get',
	          d = date[_ + 'Date'](),
	          D = date[_ + 'Day'](),
	          m = date[_ + 'Month'](),
	          y = date[_ + 'FullYear'](),
	          H = date[_ + 'Hours'](),
	          M = date[_ + 'Minutes'](),
	          s = date[_ + 'Seconds'](),
	          L = date[_ + 'Milliseconds'](),
	          o = utc ? 0 : date.getTimezoneOffset(),
	          flags = {
	        d: d,
	        dd: pad(d),
	        ddd: dF.i18n.dayNames[D],
	        dddd: dF.i18n.dayNames[D + 7],
	        m: m + 1,
	        mm: pad(m + 1),
	        mmm: dF.i18n.monthNames[m],
	        mmmm: dF.i18n.monthNames[m + 12],
	        yy: String(y).slice(2),
	        yyyy: y,
	        h: H % 12 || 12,
	        hh: pad(H % 12 || 12),
	        H: H,
	        HH: pad(H),
	        M: M,
	        MM: pad(M),
	        s: s,
	        ss: pad(s),
	        l: pad(L, 3),
	        L: pad(L > 99 ? Math.round(L / 10) : L),
	        t: H < 12 ? 'a' : 'p',
	        tt: H < 12 ? 'am' : 'pm',
	        T: H < 12 ? 'A' : 'P',
	        TT: H < 12 ? 'AM' : 'PM',
	        Z: utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
	        o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
	        S: ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
	        W: getWeek(date, _)
	      };

	      return mask.replace(token, function ($0) {
	        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
	      });
	    };
	  }();

	  // Some common format strings
	  dateFormat.masks = {
	    'default': 'ddd mmm dd yyyy HH:MM:ss',
	    shortDate: 'm/d/yy',
	    mediumDate: 'mmm d, yyyy',
	    longDate: 'mmmm d, yyyy',
	    fullDate: 'dddd, mmmm d, yyyy',
	    shortTime: 'h:MM TT',
	    mediumTime: 'h:MM:ss TT',
	    longTime: 'h:MM:ss TT Z',
	    isoDate: 'yyyy-mm-dd',
	    isoTime: 'HH:MM:ss',
	    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
	    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
	  };

	  // Internationalization strings
	  dateFormat.i18n = {
	    dayNames: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	    monthNames: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
	  };

	  /* END DATE FORMAT */

	  function getClosestIncrement(value, basis) {
	    return Math.round(value / basis) * basis;
	  }

	  function roundDate(date, format) {

	    switch (format.unit) {

	      case 's':
	        // Round at n hour

	        date.setSeconds(getClosestIncrement(date.getSeconds(), format.increment));
	        date.setMilliseconds(0);

	        break;

	      case 'i':
	        // Round at n hour

	        date.setMinutes(getClosestIncrement(date.getMinutes(), format.increment));
	        date.setSeconds(0);
	        date.setMilliseconds(0);

	        break;

	      case 'h':
	        // Round at n hour

	        date.setHours(getClosestIncrement(date.getHours(), format.increment));

	        date.setMinutes(0);
	        date.setSeconds(0);
	        date.setMilliseconds(0);

	        break;

	      case 'd':

	        date.setMinutes(0);
	        date.setSeconds(0);
	        date.setMilliseconds(0);
	        date.setHours(0);

	        date.setDate(getClosestIncrement(date.getDate(), format.increment));

	        break;

	      case 'm':

	        date.setMinutes(0);
	        date.setSeconds(0);
	        date.setMilliseconds(0);
	        date.setHours(0);
	        date.setDate(1);

	        date.setMonth(getClosestIncrement(date.getMonth(), format.increment));

	        break;

	      case 'y':

	        date.setMinutes(0);
	        date.setSeconds(0);
	        date.setMilliseconds(0);
	        date.setHours(0);
	        date.setDate(1);
	        date.setMonth(0);

	        //date.setYear( getClosest( date.getDate(), format.increment ) );

	        break;

	      default:
	        {
	          throw new Error('Date format not recognized');
	        }
	    }

	    return date;
	  }

	  function incrementDate(date, format) {

	    switch (format.unit) {

	      case 's':

	        date.setSeconds(date.getSeconds() + format.increment);
	        date.setMilliseconds(0);

	        break;

	      case 'i':

	        date.setMinutes(date.getMinutes() + format.increment);
	        date.setSeconds(0);
	        date.setMilliseconds(0);

	        break;

	      case 'h':
	        // Round at n hour

	        date.setHours(date.getHours() + format.increment);
	        date.setMinutes(0);
	        date.setSeconds(0);
	        date.setMilliseconds(0);

	        break;

	      case 'd':

	        date.setDate(date.getDate() + format.increment);
	        date.setMinutes(0);
	        date.setSeconds(0);
	        date.setMilliseconds(0);
	        date.setHours(0);

	        break;

	      case 'm':

	        date.setMonth(date.getMonth() + format.increment);
	        date.setMinutes(0);
	        date.setSeconds(0);
	        date.setMilliseconds(0);
	        date.setHours(0);
	        date.setDate(1);

	        break;

	      case 'y':

	        date.setFullYear(date.getFullYear() + format.increment);

	        date.setMinutes(0);
	        date.setSeconds(0);
	        date.setMilliseconds(0);
	        date.setHours(0);
	        date.setDate(1);
	        date.setMonth(0);

	        break;

	      default:
	        {
	          throw new Error('Date format not recognized');
	        }
	    }

	    return date;
	  }

	  function getGroup(axis, level, number) {

	    if (axis.groups[level][number]) {
	      axis.groups[level][number].group.setAttribute('display', 'block');
	      return axis.groups[level][number];
	    }

	    var g = {

	      group: document.createElementNS(axis.graph.ns, 'g'),
	      text: document.createElementNS(axis.graph.ns, 'text')
	    };

	    var line = document.createElementNS(axis.graph.ns, 'line');

	    line.setAttribute('stroke', 'black');
	    line.setAttribute('y1', 0);
	    switch (level) {

	      case 2:

	        line.setAttribute('y2', 6);
	        g.text.setAttribute('y', 15);

	        g.line = line;

	        g.group.appendChild(g.line);
	        break;

	      default:
	      case 1:

	        line.setAttribute('y2', 20);
	        g.text.setAttribute('y', 10);

	        g.line1 = line;
	        g.line2 = line.cloneNode();

	        g.group.appendChild(g.line1);
	        g.group.appendChild(g.line2);

	        break;
	    }

	    g.text.setAttribute('text-anchor', 'middle');
	    g.text.setAttribute('dominant-baseline', 'middle');

	    g.group.appendChild(g.text);

	    axis.getWrapper(level).appendChild(g.group);

	    return axis.groups[level][number] = g;
	  }

	  function hideGroups(axis, level, from) {

	    for (; from < axis.groups[level].length; from++) {

	      hideGroup(axis.groups[level][from]);
	    }
	  }

	  function hideGroup(group) {
	    group.group.setAttribute('display', 'none');
	  }

	  function getDateText(date, format) {

	    return dateFormat(date, format);
	  }

	  function renderGroup(level, group, text, minPx, maxPx, x1, x2) {

	    switch (level) {

	      case 2:

	        if (x1 < minPx || x1 > maxPx) {

	          hideGroup(group);
	          return;
	        }

	        group.line.setAttribute('x1', x1);
	        group.line.setAttribute('x2', x1);
	        group.text.setAttribute('x', x1);
	        group.text.textContent = text;

	        break;

	      default:
	      case 1:

	        var x1B = Math.max(minPx, Math.min(maxPx, x1)),
	            x2B = Math.max(minPx, Math.min(maxPx, x2));

	        if (isNaN(x2B) || isNaN(x1B)) {
	          return;
	        }

	        group.line1.setAttribute('x1', x1B);
	        group.line2.setAttribute('x1', x2B);

	        group.line1.setAttribute('x2', x1B);
	        group.line2.setAttribute('x2', x2B);

	        group.text.setAttribute('x', (x1B + x2B) / 2);

	        while (text.length * 8 > x2B - x1B) {

	          text = text.substr(0, text.length - 2) + '.';

	          if (text.length == 1) {
	            text = '';
	            break;
	          }
	        }

	        group.text.textContent = text;
	        break;
	    }
	  }

	  var GraphTimeAxis = function (_Axis) {
	    _inherits(GraphTimeAxis, _Axis);

	    function GraphTimeAxis() {
	      _classCallCheck(this, GraphTimeAxis);

	      return _possibleConstructorReturn(this, (GraphTimeAxis.__proto__ || Object.getPrototypeOf(GraphTimeAxis)).apply(this, arguments));
	    }

	    _createClass(GraphTimeAxis, [{
	      key: 'init',
	      value: function init(graph, options) {

	        _get(GraphTimeAxis.prototype.__proto__ || Object.getPrototypeOf(GraphTimeAxis.prototype), 'init', this).call(this, graph, options);

	        this.wrapper = {
	          1: document.createElementNS(graph.ns, 'g'),
	          2: document.createElementNS(graph.ns, 'g')
	        };
	        this.groups = {
	          1: [],
	          2: []
	        };

	        var rect = document.createElementNS(graph.ns, 'rect');
	        rect.setAttribute('fill', '#c0c0c0');
	        rect.setAttribute('stroke', '#808080');
	        rect.setAttribute('height', '20');
	        rect.setAttribute('x', '0');
	        rect.setAttribute('y', '0');

	        this.rect = rect;

	        this.wrapper[1].appendChild(this.rect);

	        //    this.init( graph, options );

	        this.group.appendChild(this.wrapper[1]);
	        this.group.appendChild(this.wrapper[2]);

	        this.wrapper[1].setAttribute('transform', 'translate( 0, 25 )');
	        this.wrapper[2].setAttribute('transform', 'translate( 0, 00 )');
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {
	        // Redrawing of the axis

	        //this.drawInit();

	        this.cacheCurrentMax();
	        this.cacheCurrentMin();

	        if (this.currentAxisMin == undefined || this.currentAxisMax == undefined) {
	          this.setMinMaxToFitSeries(true); // We reset the min max as a function of the series
	        }

	        this.line.setAttribute('x1', this.getMinPx());
	        this.line.setAttribute('x2', this.getMaxPx());
	        this.line.setAttribute('y1', 0);
	        this.line.setAttribute('y2', 0);

	        var widthPx = this.maxPx - this.minPx;
	        var widthTime = this.getCurrentInterval();

	        var timePerPx = widthTime / widthPx;

	        var maxVal = this.getCurrentMax();
	        var minVal = this.getCurrentMin();

	        this.rect.setAttribute('width', widthPx);
	        this.rect.setAttribute('x', this.minPx);

	        if (!maxVal || !minVal) {
	          return 0;
	        }

	        var currentFormat;

	        for (i = 0; i < axisFormat.length; i++) {

	          if (axisFormat[i].threshold > timePerPx) {
	            currentFormat = axisFormat[i];

	            break;
	          }
	        }

	        if (!currentFormat) {
	          currentFormat = axisFormat[axisFormat.length - 1];
	        }

	        var xVal1,
	            xVal2,
	            level = 0,
	            dateFirst,
	            currentDate,
	            text,
	            group,
	            i;

	        for (level = 1; level <= 2; level++) {

	          if (!util.isNumeric(minVal)) {
	            hideGroups(this, level, 0);
	            break;
	          }

	          dateFirst = new Date(minVal);

	          currentDate = roundDate(dateFirst, currentFormat.increments[level]);

	          i = 0;

	          do {
	            /** @ignore */
	            text = getDateText(currentDate, currentFormat.increments[level].format);
	            group = getGroup(this, level, i);

	            xVal1 = this.getPx(currentDate.getTime());
	            currentDate = incrementDate(currentDate, currentFormat.increments[level]);
	            xVal2 = this.getPx(currentDate.getTime());

	            renderGroup(level, group, text, this.getMinPx(), this.getMaxPx(), xVal1, xVal2);

	            i++;
	            if (i > 100) {
	              break;
	            }
	          } while (currentDate.getTime() < maxVal);

	          hideGroups(this, level, i);
	        }
	      }
	    }, {
	      key: 'isX',
	      value: function isX() {
	        return true;
	      }
	    }, {
	      key: 'getWrapper',
	      value: function getWrapper(level) {
	        return this.wrapper[level];
	      }
	    }, {
	      key: 'setShift',
	      value: function setShift(shift) {
	        this.shift = shift;
	        this.group.setAttribute('transform', 'translate(0 ' + (this.top ? this.shift : this.graph.getDrawingHeight() - this.shift) + ')');
	      }
	    }, {
	      key: 'getAxisPosition',
	      value: function getAxisPosition() {
	        return 60;
	      }
	    }, {
	      key: 'setMinMaxFlipped',
	      value: function setMinMaxFlipped() {

	        var interval = this.maxPx - this.minPx;
	        var maxPx = interval * this.options.span[1] + this.minPx;
	        var minPx = interval * this.options.span[0] + this.minPx;

	        this.minPxFlipped = this.isFlipped() ? maxPx : minPx;
	        this.maxPxFlipped = this.isFlipped() ? minPx : maxPx;
	      }
	    }]);

	    return GraphTimeAxis;
	  }(_graphAxis2.default);

	  exports.default = GraphTimeAxis;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 352 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(51), __webpack_require__(46), __webpack_require__(140), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphCore, _graphSerieLine, _waveform, _graphMixinSerie3d, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphCore2 = _interopRequireDefault(_graphCore);

	  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

	  var _waveform2 = _interopRequireDefault(_waveform);

	  var _graphMixinSerie3d2 = _interopRequireDefault(_graphMixinSerie3d);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieLine3D = function (_Serie) {
	    _inherits(SerieLine3D, _Serie);

	    _createClass(SerieLine3D, null, [{
	      key: 'defaults',
	      value: function defaults() {
	        return {
	          zpos: 0
	        };
	      }
	    }]);

	    function SerieLine3D(graph, name, options) {
	      _classCallCheck(this, SerieLine3D);

	      return _possibleConstructorReturn(this, (SerieLine3D.__proto__ || Object.getPrototypeOf(SerieLine3D)).apply(this, arguments));
	    }

	    /**
	     * Sets the z-position
	     * @memberof SerieLine3D
	     * @param {Number} zPos - The position in the z axis
	     */


	    _createClass(SerieLine3D, [{
	      key: 'setZPos',
	      value: function setZPos(zPos) {
	        this.options.zpos = zPos;
	        return this;
	      }
	    }, {
	      key: 'setz',
	      value: function setz() {
	        return this.setZPos.apply(this, arguments);
	      }
	    }]);

	    return SerieLine3D;
	  }(_graphSerieLine2.default);

	  util.mix(SerieLine3D, _graphMixinSerie3d2.default);
	  exports.default = SerieLine3D;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 353 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(51), __webpack_require__(73)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphUtil, _graphSerieLine, _graphMixinErrorbars) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

	  var _graphMixinErrorbars2 = _interopRequireDefault(_graphMixinErrorbars);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieBar = function (_Serie) {
	    _inherits(SerieBar, _Serie);

	    function SerieBar(graph, name, options) {
	      _classCallCheck(this, SerieBar);

	      var _this = _possibleConstructorReturn(this, (SerieBar.__proto__ || Object.getPrototypeOf(SerieBar)).apply(this, arguments));

	      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');

	      _this.pathDom = document.createElementNS(_this.graph.ns, 'path');
	      _this.groupMain.appendChild(_this.pathDom);

	      // Creates an empty style variable
	      _this.styles = {};

	      // Unselected style
	      _this.styles.unselected = {
	        lineColor: _this.options.lineColor,
	        lineStyle: _this.options.lineStyle,
	        lineWidth: _this.options.lineWidth,
	        fillColor: _this.options.fillColor,
	        fillOpacity: _this.options.fillOpacity,
	        markers: _this.options.markers
	      };

	      return _this;
	    }

	    /**
	     *  Sets the data of the bar serie
	     *  @param {Object} data
	     *  @example serie.setData( { "cat1": val1, "cat2": val2, "cat4": val4 } );
	     *  @return {SerieBar} The current serie instance
	     */


	    _createClass(SerieBar, [{
	      key: 'setData',
	      value: function setData(data) {

	        this.data = data;
	        this.minY = Number.MAX_SAFE_INTEGER;
	        this.maxY = Number.MIN_SAFE_INTEGER;

	        for (var i in this.data) {
	          this._checkY(this.data[i]);
	        }

	        return this;
	      }
	    }, {
	      key: 'setFillColor',
	      value: function setFillColor(fillColor, selectionType, applyToSelected) {

	        selectionType = selectionType || 'unselected';
	        this.styles[selectionType] = this.styles[selectionType] || {};
	        this.styles[selectionType].fillColor = fillColor;

	        if (applyToSelected) {
	          this.setFillColor(fillColor, 'selected');
	        }

	        this.styleHasChanged(selectionType);

	        return this;
	      }
	    }, {
	      key: 'getFillColor',
	      value: function getFillColor(selectionType) {
	        return this.getStyle(selectionType).fillColor;
	      }
	    }, {
	      key: 'setFillOpacity',
	      value: function setFillOpacity(opacity, selectionType, applyToSelected) {

	        selectionType = selectionType || 'unselected';
	        this.styles[selectionType] = this.styles[selectionType] || {};
	        this.styles[selectionType].fillOpacity = opacity;

	        if (applyToSelected) {
	          this.setLineWidth(opacity, 'selected');
	        }

	        this.styleHasChanged(selectionType);

	        return this;
	      }
	    }, {
	      key: 'getFillOpacity',
	      value: function getFillOpacity(selectionType) {

	        return this.getStyle(selectionType).fillOpacity || 1;
	      }
	    }, {
	      key: 'applyLineStyles',
	      value: function applyLineStyles() {
	        this.applyLineStyle(this.pathDom);
	      }
	    }, {
	      key: 'applyLineStyle',
	      value: function applyLineStyle(line) {

	        line.setAttribute('stroke', this.getLineColor());
	        line.setAttribute('stroke-width', this.getLineWidth());
	        if (this.getLineDashArray()) {
	          line.setAttribute('stroke-dasharray', this.getLineDashArray());
	        } else {
	          line.removeAttribute('stroke-dasharray');
	        }
	        line.setAttribute('fill', this.getFillColor());
	        line.setAttribute('fill-opacity', this.getFillOpacity() || 1);
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {

	        var path = '';

	        if (this.error) {
	          this.errorDrawInit();
	        }

	        for (var i in this.data) {

	          if (!this.categoryIndices[i]) {
	            continue;
	          }

	          path += 'M ' + this.getXAxis().getPos(this.categoryIndices[i]) + ' ' + this.getYAxis().getPos(0) + ' V ' + this.getYAxis().getPos(this.data[i]) + ' h ' + this.getXAxis().getDeltaPx(1 / this.nbCategories) + ' V ' + this.getYAxis().getPos(0);

	          if (this.error) {
	            this.errorAddPointBarChart(i, this.data[i], this.getXAxis().getPos(this.categoryIndices[i] + 0.5 / this.nbCategories), this.getYAxis().getPos(this.data[i]));
	          }
	        }

	        if (this.error) {
	          this.errorDraw();
	        }

	        this.pathDom.setAttribute('d', path);
	        this.applyLineStyles();
	      }
	    }, {
	      key: 'setMarkers',
	      value: function setMarkers() {}
	    }, {
	      key: 'getUsedCategories',
	      value: function getUsedCategories() {
	        return Object.keys(this.data);
	      }
	    }]);

	    return SerieBar;
	  }(_graphSerieLine2.default);

	  exports.default = SerieBar;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 354 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(57), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphSerie, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphSerie2 = _interopRequireDefault(_graphSerie);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieBox = function (_Serie) {
	    _inherits(SerieBox, _Serie);

	    _createClass(SerieBox, null, [{
	      key: 'default',
	      value: function _default() {
	        return {
	          orientation: 'y',
	          maxBoxWidth: 20,

	          defaultStyle: {

	            meanLineColor: 'rgb( 100, 0, 0 )',
	            meanLineWidth: 2,

	            boxAboveLineWidth: 1,
	            boxAboveLineColor: 'rgb( 0, 0, 0 )',
	            boxAboveFillColor: 'transparent',
	            boxAboveFillOpacity: 1,
	            boxBelowLineWidth: 1,
	            boxBelowLineColor: 'rgb( 0, 0, 0 )',
	            boxBelowFillColor: 'transparent',
	            boxBelowFillOpacity: 1,

	            barAboveLineColor: 'rgba( 0, 0, 0, 1 )',
	            barAboveLineWidth: 1,
	            barBelowLineColor: 'rgba( 0, 0, 0, 1 )',
	            barBelowLineWidth: 1,

	            outlierLineWidth: 1,
	            outlierLineColor: 'rgb( 255, 255, 255 )',
	            outlierFillColor: 'rgb( 0, 0, 0 )',
	            outlierFillOpacity: 1
	          }
	        };
	      }
	    }]);

	    function SerieBox(graph, name, options) {
	      _classCallCheck(this, SerieBox);

	      var _this = _possibleConstructorReturn(this, (SerieBox.__proto__ || Object.getPrototypeOf(SerieBox)).apply(this, arguments));

	      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');

	      _this.pathDom = document.createElementNS(_this.graph.ns, 'path');
	      _this.groupMain.appendChild(_this.pathDom);

	      // Creates an empty style variable
	      _this.styles = {};

	      // Unselected style
	      _this.styles.unselected = _this.options.defaultStyle;

	      return _this;
	    }

	    /**
	     *  Sets the data of the bar serie
	     *  @param {Object} data
	     *  @example serie.setData( [ { x: 'cat', Q2: valMean, Q1: valBoxMin, Q3: valBoxMax, whiskers: [ val1, val2 ], outliers: [ ...yList ] } ] );
	     *  @return {SerieBar} The current serie instance
	     */


	    _createClass(SerieBox, [{
	      key: 'setData',
	      value: function setData(data, noRescale) {

	        this.data = data;

	        if (!Array.isArray(data)) {
	          return;
	        }

	        var axisref = void 0,
	            axisval = void 0,
	            methodref = void 0,
	            methodval = void 0,
	            blnX = void 0;

	        if (this.options.orientation == 'y') {
	          axisref = this.getXAxis();
	          axisval = this.getYAxis();
	          methodref = this._checkX.bind(this);
	          methodval = this._checkY.bind(this);
	          blnX = true;

	          this.minY = data[0].Q2;
	          this.maxY = data[0].Q2;
	          this.maxX = data[0].x;
	          this.minX = data[0].x;
	        } else {
	          axisref = this.getYAxis();
	          axisval = this.getXAxis();
	          methodref = this._checkY.bind(this);
	          methodval = this._checkX.bind(this);
	          blnX = false;

	          this.minX = data[0].Q2;
	          this.maxX = data[0].Q2;
	          this.maxY = data[0].y;
	          this.minY = data[0].y;
	        }

	        if (noRescale) {
	          methodref = function methodref() {};
	          methodval = function methodval() {};
	        }

	        if (!axisref || !axisval) {
	          (0, _graphUtil.throwError)('Error in setting data of the box serie. The X and Y axes must be set beforehand');
	        }

	        for (var i in this.data) {

	          if (blnX) {
	            methodref(this.data[i].x);
	            this.data[i].pos = this.data[i].x;
	          } else {
	            methodref(this.data[i].y);
	            this.data[i].pos = this.data[i].y;
	          }

	          if (this.data[i].Q3) {

	            methodval(this.data[i].Q3);
	          }

	          if (this.data[i].Q1) {
	            methodval(this.data[i].Q1);
	          }

	          if (this.data[i].whiskers) {

	            if (Array.isArray(this.data[i].whiskers)) {

	              if (this.data[i].whiskers.length > 0) {
	                methodval(this.data[i].whiskers[0]);
	              }

	              if (this.data[i].whiskers.length > 1) {
	                methodval(this.data[i].whiskers[1]);
	              }
	            } else {
	              methodval(this.data[i].whiskers);
	              this.data[i].whiskers = [this.data[i].whiskers];
	            }
	          } else {
	            this.data[i].whiskers = [];
	          }

	          if (Array.isArray(this.data[i].outliers)) {
	            this.data[i].outliers.map(function (val) {
	              return methodval(val);
	            });
	          } else {
	            this.data[i].outliers = [];
	          }
	        }

	        this.dataHasChanged();
	        this.graph.updateDataMinMaxAxes();

	        return this;
	      }
	    }, {
	      key: '_style',
	      value: function _style(type, styleValue) {
	        var selectionType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unselected';
	        var applyToSelected = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

	        this.styles[selectionType] = this.styles[selectionType] || {};
	        this.styles[selectionType][type] = styleValue;

	        if (applyToSelected) {
	          this._set(type, styleValue, 'selected');
	        }

	        this.styleHasChanged(selectionType);
	        return this;
	      }
	    }, {
	      key: '_gstyle',
	      value: function _gstyle(type, selectionType) {
	        return this.getStyle(selectionType)[type];
	      }
	    }, {
	      key: 'getStyle',
	      value: function getStyle() {
	        var selectionType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unselected';


	        return this.styles[selectionType] || {};
	      }
	    }, {
	      key: 'setMeanLineColor',
	      value: function setMeanLineColor() {
	        return this._style.apply(this, ['meanLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getMeanLineColor',
	      value: function getMeanLineColor() {
	        return this._gstyle.apply(this, ['meanLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setStyle',
	      value: function setStyle(style) {
	        var selectionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unselected';

	        //console.log( style, selectionType );
	        this.styles[selectionType] = (0, _graphUtil.extend)({}, this.default().defaultStyle, this.styles.unselected, style);
	        this.styleHasChanged(selectionType);
	      }
	    }, {
	      key: 'setMeanLineWidth',
	      value: function setMeanLineWidth() {
	        return this._style.apply(this, ['meanLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getMeanLineWidth',
	      value: function getMeanLineWidth() {
	        return this._gstyle.apply(this, ['meanLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBoxAboveLineColor',
	      value: function setBoxAboveLineColor() {
	        return this._style.apply(this, ['boxAboveLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBoxAboveLineColor',
	      value: function getBoxAboveLineColor() {
	        return this._gstyle.apply(this, ['boxAboveLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBoxBelowLineColor',
	      value: function setBoxBelowLineColor() {
	        return this._style.apply(this, ['boxBelowLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBoxBelowLineColor',
	      value: function getBoxBelowLineColor() {
	        return this._gstyle.apply(this, ['boxBelowLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBoxAboveLineWidth',
	      value: function setBoxAboveLineWidth() {
	        return this._style.apply(this, ['boxAboveLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBoxAboveLineWidth',
	      value: function getBoxAboveLineWidth() {
	        return this._gstyle.apply(this, ['boxAboveLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBoxBelowLineWidth',
	      value: function setBoxBelowLineWidth() {
	        return this._style.apply(this, ['boxBelowLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBoxBelowLineWidth',
	      value: function getBoxBelowLineWidth() {
	        return this._gstyle.apply(this, ['boxBelowLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBoxAboveFillColor',
	      value: function setBoxAboveFillColor() {
	        return this._style.apply(this, ['boxAboveFillColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBoxAboveFillColor',
	      value: function getBoxAboveFillColor() {
	        return this._gstyle.apply(this, ['boxAboveFillColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBoxBelowFillColor',
	      value: function setBoxBelowFillColor() {
	        return this._style.apply(this, ['boxBelowFillColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBoxBelowFillColor',
	      value: function getBoxBelowFillColor() {
	        return this._gstyle.apply(this, ['boxBelowFillColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBoxAboveFillOpacity',
	      value: function setBoxAboveFillOpacity() {
	        return this._style.apply(this, ['boxAboveFillOpacity'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBoxAboveFillOpacity',
	      value: function getBoxAboveFillOpacity() {
	        return this._gstyle.apply(this, ['boxAboveFillOpacity'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBoxBelowFillOpacity',
	      value: function setBoxBelowFillOpacity() {
	        return this._style.apply(this, ['boxBelowFillOpacity'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBoxBelowFillOpacity',
	      value: function getBoxBelowFillOpacity() {
	        return this._gstyle.apply(this, ['boxBelowFillOpacity'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBarAboveLineColor',
	      value: function setBarAboveLineColor() {
	        return this._style.apply(this, ['barAboveLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBarAboveLineColor',
	      value: function getBarAboveLineColor() {
	        return this._gstyle.apply(this, ['barAboveLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBarBelowLineColor',
	      value: function setBarBelowLineColor() {
	        return this._style.apply(this, ['barBelowLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBarBelowLineColor',
	      value: function getBarBelowLineColor() {
	        return this._gstyle.apply(this, ['barBelowLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBarAboveLineWidth',
	      value: function setBarAboveLineWidth() {
	        return this._style.apply(this, ['barAboveLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBarAboveLineWidth',
	      value: function getBarAboveLineWidth() {
	        return this._gstyle.apply(this, ['barAboveLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setBarBelowLineWidth',
	      value: function setBarBelowLineWidth() {
	        return this._style.apply(this, ['barBelowLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getBarBelowLineWidth',
	      value: function getBarBelowLineWidth() {
	        return this._gstyle.apply(this, ['barBelowLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setOutlierLineColor',
	      value: function setOutlierLineColor() {
	        return this._style.apply(this, ['outlierLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getOutlierLineColor',
	      value: function getOutlierLineColor() {
	        return this._gstyle.apply(this, ['outlierLineColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setOutlierLineWidth',
	      value: function setOutlierLineWidth() {
	        return this._style.apply(this, ['outlierLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getOutlierLineWidth',
	      value: function getOutlierLineWidth() {
	        return this._gstyle.apply(this, ['outlierLineWidth'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setOutlierFillColor',
	      value: function setOutlierFillColor() {
	        return this._style.apply(this, ['outlierFillColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getOutlierFillColor',
	      value: function getOutlierFillColor() {
	        return this._gstyle.apply(this, ['outlierFillColor'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'setOutlierFillOpacity',
	      value: function setOutlierFillOpacity() {
	        return this._style.apply(this, ['outlierFillOpacity'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'getOutlierFillOpacity',
	      value: function getOutlierFillOpacity() {
	        return this._gstyle.apply(this, ['outlierFillOpacity'].concat(Array.prototype.slice.call(arguments)));
	      }
	    }, {
	      key: 'applyLineStyles',
	      value: function applyLineStyles() {
	        this.applyLineStyle(this.pathDom);
	      }
	    }, {
	      key: 'applyLineStyle',
	      value: function applyLineStyle(line) {

	        line.setAttribute('stroke', this.getLineColor());
	        line.setAttribute('stroke-width', this.getLineWidth());
	        line.removeAttribute('stroke-dasharray');
	        line.setAttribute('fill', this.getFillColor());
	        line.setAttribute('fill-opacity', this.getFillOpacity() || 1);
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {
	        var _this2 = this;

	        if (!this.data) {
	          return;
	        }

	        var position = void 0;
	        var axis = this.options.orientation == 'y' ? this.getYAxis() : this.getXAxis();
	        var axis2 = this.options.orientation == 'y' ? this.getXAxis() : this.getYAxis();
	        var boxOtherDimension = void 0; // width or height of the box
	        var mean = void 0,
	            boxAbove = void 0,
	            boxBelow = void 0,
	            barAbove = void 0,
	            barBelow = void 0,
	            outliers = void 0;

	        (0, _graphUtil.emptyDom)(this.groupMain);

	        if (axis2.getType() == 'category') {

	          boxOtherDimension = axis2.getRelPx(0.8 / this.nbCategories);
	        } else {
	          // Get all the spacing and determine the smallest one
	          boxOtherDimension = this.options.maxBoxWidth;
	          //      console.log( boxOtherDimension );
	          for (var i = 0, l = this.data.length; i < l - 1; i++) {

	            //     console.log( Math.abs( axis.getPx( this.data[ i + 1 ].pos ) - axis.getPx( this.data[ i ].pos ) ), axis.getPx( this.data[ i + 1 ].pos ), axis.getPx( this.data[ i ].pos ) );
	            boxOtherDimension = Math.min(boxOtherDimension, Math.abs(axis2.getPx(this.data[i + 1].pos) - axis2.getPx(this.data[i].pos)));
	          }
	          // console.log( boxOtherDimension );
	        }

	        for (var i = 0, l = this.data.length; i < l; i++) {

	          if (axis2.getType() == 'category') {

	            var cat = this.options.orientation == 'y' ? this.data[i].x : this.data[i].y;

	            if (!this.categoryIndices.hasOwnProperty(cat)) {

	              if (Array.isArray(this._linkedToScatterSeries)) {
	                var _iteratorNormalCompletion = true;
	                var _didIteratorError = false;
	                var _iteratorError = undefined;

	                try {
	                  for (var _iterator = this._linkedToScatterSeries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var scatter_serie = _step.value;


	                    if (scatter_serie.categoryIndices.hasOwnProperty(cat)) {

	                      position = [axis2.getPos(scatter_serie.categoryIndices[cat]) + 1.2 * boxOtherDimension / 2];

	                      if (this.options.orientation == 'y') {
	                        axis = scatter_serie.getYAxis();
	                      } else {
	                        axis = scatter_serie.getXAxis();
	                      }

	                      break;
	                    }
	                  }
	                } catch (err) {
	                  _didIteratorError = true;
	                  _iteratorError = err;
	                } finally {
	                  try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                      _iterator.return();
	                    }
	                  } finally {
	                    if (_didIteratorError) {
	                      throw _iteratorError;
	                    }
	                  }
	                }
	              }
	            } else {

	              position = [axis2.getPos(this.categoryIndices[cat]) + 1.2 * boxOtherDimension / 2];
	            }
	          } else {

	            position = [axis2.getPos(this.options.orientation == 'y' ? this.data[i].x : this.data[i].y), boxOtherDimension];
	          }

	          mean = axis.getPos(this.data[i].Q2);
	          boxAbove = axis.getPos(this.data[i].Q3);
	          boxBelow = axis.getPos(this.data[i].Q1);

	          this.data[i].whiskers.map(function (val) {

	            if (val < _this2.data[i].Q1) {
	              barBelow = axis.getPos(val);
	            } else {
	              barAbove = axis.getPos(val);
	            }
	          });

	          outliers = this.data[i].outliers.map(function (val) {
	            return axis.getPos(val);
	          });

	          var lineMean = document.createElementNS(this.graph.ns, 'line');

	          this.applyMeanStyle(lineMean);

	          var rectAbove = document.createElementNS(this.graph.ns, 'rect');
	          var rectBelow = document.createElementNS(this.graph.ns, 'rect');

	          if (this.options.orientation == 'y') {

	            rectAbove.setAttribute('width', boxOtherDimension);
	            rectAbove.setAttribute('x', position[0] - boxOtherDimension / 2);

	            rectBelow.setAttribute('width', boxOtherDimension);
	            rectBelow.setAttribute('x', position[0] - boxOtherDimension / 2);

	            lineMean.setAttribute('x1', position[0] - boxOtherDimension / 2);
	            lineMean.setAttribute('x2', position[0] + boxOtherDimension / 2);
	            lineMean.setAttribute('y1', mean);
	            lineMean.setAttribute('y2', mean);
	          } else {

	            rectAbove.setAttribute('height', boxOtherDimension);
	            rectAbove.setAttribute('y', position[0] - boxOtherDimension / 2);

	            rectBelow.setAttribute('height', boxOtherDimension);
	            rectBelow.setAttribute('y', position[0] - boxOtherDimension / 2);

	            lineMean.setAttribute('y1', position[0] - boxOtherDimension / 2);
	            lineMean.setAttribute('y2', position[0] + boxOtherDimension / 2);
	            lineMean.setAttribute('x1', mean);
	            lineMean.setAttribute('x2', mean);
	          }

	          this.boxPos(rectAbove, mean, boxAbove, this.options.orientation == 'x');
	          this.boxPos(rectBelow, mean, boxBelow, this.options.orientation == 'x');

	          this.applyBoxStyle(rectAbove, rectBelow);

	          var whiskerAbove = document.createElementNS(this.graph.ns, 'line');
	          var whiskerBelow = document.createElementNS(this.graph.ns, 'line');

	          if (this.options.orientation == 'y') {

	            if (barAbove !== undefined) {
	              whiskerAbove.setAttribute('y1', boxAbove);
	              whiskerAbove.setAttribute('y2', barAbove);
	              whiskerAbove.setAttribute('x1', position[0]);
	              whiskerAbove.setAttribute('x2', position[0]);
	            }

	            if (barBelow !== undefined) {
	              whiskerBelow.setAttribute('y1', boxBelow);
	              whiskerBelow.setAttribute('y2', barBelow);
	              whiskerBelow.setAttribute('x1', position[0]);
	              whiskerBelow.setAttribute('x2', position[0]);
	            }
	          } else {

	            if (barAbove !== undefined) {
	              whiskerAbove.setAttribute('x1', boxAbove);
	              whiskerAbove.setAttribute('x2', barAbove);
	              whiskerAbove.setAttribute('y1', position[0]);
	              whiskerAbove.setAttribute('y2', position[0]);
	            }

	            if (barBelow !== undefined) {
	              whiskerBelow.setAttribute('x1', boxBelow);
	              whiskerBelow.setAttribute('x2', barBelow);
	              whiskerBelow.setAttribute('y1', position[0]);
	              whiskerBelow.setAttribute('y2', position[0]);
	            }
	          }

	          outliers.map(function (outliervalue) {

	            var outlier = document.createElementNS(_this2.graph.ns, 'circle');

	            outlier.setAttribute('r', 2);

	            if (_this2.options.orientation == 'y') {

	              outlier.setAttribute('cx', position[0]);
	              outlier.setAttribute('cy', outliervalue);
	            } else {

	              outlier.setAttribute('cy', position[0]);
	              outlier.setAttribute('cx', outliervalue);
	            }

	            _this2.setOutlierStyle(outlier);

	            _this2.groupMain.appendChild(outlier);
	          });

	          if (barAbove !== undefined) {
	            this.groupMain.appendChild(whiskerAbove);
	          }

	          if (barBelow !== undefined) {
	            this.groupMain.appendChild(whiskerBelow);
	          }

	          if (boxAbove !== undefined) {
	            this.groupMain.appendChild(rectAbove);
	          }

	          if (boxBelow !== undefined) {
	            this.groupMain.appendChild(rectBelow);
	          }

	          this.groupMain.appendChild(lineMean);

	          this.applyWhiskerStyle(whiskerAbove, whiskerBelow);
	        }
	      }
	    }, {
	      key: 'applyBoxStyle',
	      value: function applyBoxStyle(above, below) {

	        above.setAttribute('stroke', this.getBoxAboveLineColor());
	        above.setAttribute('stroke-width', this.getBoxAboveLineWidth());

	        if (this.getBoxAboveFillColor() !== undefined) {
	          above.setAttribute('fill', this.getBoxAboveFillColor());
	        }
	        if (this.getBoxAboveFillOpacity() !== undefined) {
	          above.setAttribute('fill-opacity', this.getBoxAboveFillOpacity());
	        }

	        below.setAttribute('stroke', this.getBoxBelowLineColor());
	        below.setAttribute('stroke-width', this.getBoxBelowLineWidth());

	        if (this.getBoxBelowFillColor() !== undefined) {
	          below.setAttribute('fill', this.getBoxBelowFillColor());
	        }
	        if (this.getBoxAboveFillOpacity() !== undefined) {
	          below.setAttribute('fill-opacity', this.getBoxBelowFillOpacity());
	        }
	      }
	    }, {
	      key: 'applyWhiskerStyle',
	      value: function applyWhiskerStyle(above, below) {

	        above.setAttribute('stroke', this.getBarAboveLineColor());
	        above.setAttribute('stroke-width', this.getBarAboveLineWidth());

	        below.setAttribute('stroke', this.getBarBelowLineColor());
	        below.setAttribute('stroke-width', this.getBarBelowLineWidth());
	      }
	    }, {
	      key: 'applyMeanStyle',
	      value: function applyMeanStyle(line) {

	        line.setAttribute('stroke', this.getMeanLineColor());
	        line.setAttribute('stroke-width', this.getMeanLineWidth());
	      }
	    }, {
	      key: 'setOutlierStyle',
	      value: function setOutlierStyle(outlier) {

	        outlier.setAttribute('stroke', this.getOutlierLineColor());
	        outlier.setAttribute('stroke-width', this.getOutlierLineWidth());

	        if (this.getBoxBelowFillColor() !== undefined) {
	          outlier.setAttribute('fill', this.getOutlierFillColor());
	        }
	        if (this.getBoxAboveFillOpacity() !== undefined) {
	          outlier.setAttribute('fill-opacity', this.getOutlierFillOpacity());
	        }
	      }
	    }, {
	      key: 'getCategoryIndex',
	      value: function getCategoryIndex(name) {

	        if (!this.categories) {
	          throw new Error('No categories were defined. Probably axis.setSeries was not called');
	        }

	        for (var i = 0; i < this.categories.length; i++) {

	          if (this.categories[i].name == name) {
	            return i;
	          }
	        }

	        return false;
	      }
	    }, {
	      key: 'setMarkers',
	      value: function setMarkers() {}
	    }, {
	      key: 'boxPos',
	      value: function boxPos(box, mean, extremity, blnX) {

	        if (mean > extremity) {

	          box.setAttribute(blnX ? 'x' : 'y', extremity);
	          box.setAttribute(blnX ? 'width' : 'height', mean - extremity);
	        } else {

	          box.setAttribute(blnX ? 'x' : 'y', mean);
	          box.setAttribute(blnX ? 'width' : 'height', extremity - mean);
	        }
	      }
	    }, {
	      key: 'getUsedCategories',
	      value: function getUsedCategories() {
	        var xymode = this.options.orientation == 'y' ? 'x' : 'y';

	        var categories = this.data.map(function (d) {
	          return d[xymode];
	        });

	        if (Array.isArray(this._linkedToScatterSeries)) {
	          this._linkedToScatterSeries.map(function (scatter_serie) {

	            scatter_serie.getUsedCategories().map(function (scatter_serie_cat) {
	              var index = void 0;
	              if ((index = categories.indexOf(scatter_serie_cat)) > -1) {
	                categories.splice(index, 1);
	              }
	            });
	          });
	        }

	        return categories;
	      }
	    }, {
	      key: 'linkToScatterSerie',
	      value: function linkToScatterSerie() {
	        for (var _len = arguments.length, series = Array(_len), _key = 0; _key < _len; _key++) {
	          series[_key] = arguments[_key];
	        }

	        this._linkedToScatterSeries = series;
	      }
	    }]);

	    return SerieBox;
	  }(_graphSerie2.default);

	  exports.default = SerieBox;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 355 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(51), __webpack_require__(5), __webpack_require__(73)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphSerieLine, _graphUtil, _graphMixinErrorbars) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphMixinErrorbars2 = _interopRequireDefault(_graphMixinErrorbars);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieLineColor = function (_SerieLine) {
	    _inherits(SerieLineColor, _SerieLine);

	    function SerieLineColor(graph, name, options) {
	      _classCallCheck(this, SerieLineColor);

	      var _this = _possibleConstructorReturn(this, (SerieLineColor.__proto__ || Object.getPrototypeOf(SerieLineColor)).apply(this, arguments));

	      _this.lines = _this.lines || {};
	      return _this;
	    }

	    _createClass(SerieLineColor, [{
	      key: 'setColors',
	      value: function setColors(colors) {
	        this.colors = colors;
	      }
	    }, {
	      key: '_draw',
	      value: function _draw() {

	        var self = this,
	            data = this._dataToUse,
	            i = 0,
	            j,
	            m,
	            x,
	            y,
	            lastX = false,
	            lastY = false,
	            xpx,
	            ypx,
	            xpx2,
	            ypx2,
	            xAxis = this.getXAxis(),
	            yAxis = this.getYAxis(),
	            xMin = xAxis.getCurrentMin(),
	            yMin = yAxis.getCurrentMin(),
	            xMax = xAxis.getCurrentMax(),
	            yMax = yAxis.getCurrentMax();

	        this.eraseLines();

	        if (this.isFlipped()) ;

	        this.currentLine = '';
	        m = this.waveform.getLength();

	        for (j = 0; j < m; j += 2) {

	          x = this.waveform.getX(j);
	          y = this.waveform.getY(j);

	          if (x < xMin && lastX < xMin || x > xMax && lastX > xMax || (y < yMin && lastY < yMin || y > yMax && lastY > yMax) && !this.options.lineToZero) {
	            lastX = x;
	            lastY = y;
	            continue;
	          }

	          this.counter2 = j;

	          if (this.markersShown()) {
	            this.getMarkerCurrentFamily(this.counter2);
	          }

	          xpx2 = this.getX(x);
	          ypx2 = this.getY(y);

	          if (xpx2 == xpx && ypx2 == ypx) {
	            continue;
	          }
	          /*
	                  if ( this.options.lineToZero ) {
	                    pointOutside = ( x < xMin || x > xMax );
	                     if ( pointOutside ) {
	                      continue;
	                    }
	                  } else {
	                     if ( pointOutside || lastPointOutside ) {
	                       if ( ( lastX === false || lastY === false ) && !lastPointOutside ) {
	                         xpx = xpx2;
	                        ypx = ypx2;
	                        lastX = x;
	                        lastY = y;
	                       } else {
	                         pointOnAxis = [];
	                        // Y crossing
	                        yLeftCrossingRatio = ( x - xMin ) / ( x - lastX );
	                        yLeftCrossing = y - yLeftCrossingRatio * ( y - lastY );
	                        yRightCrossingRatio = ( x - xMax ) / ( x - lastX );
	                        yRightCrossing = y - yRightCrossingRatio * ( y - lastY );
	                         // X crossing
	                        xTopCrossingRatio = ( y - yMin ) / ( y - lastY );
	                        xTopCrossing = x - xTopCrossingRatio * ( x - lastX );
	                        xBottomCrossingRatio = ( y - yMax ) / ( y - lastY );
	                        xBottomCrossing = x - xBottomCrossingRatio * ( x - lastX );
	                         if ( yLeftCrossingRatio < 1 && yLeftCrossingRatio > 0 && yLeftCrossing !== false && yLeftCrossing < yMax && yLeftCrossing > yMin ) {
	                          pointOnAxis.push( [ xMin, yLeftCrossing ] );
	                        }
	                         if ( yRightCrossingRatio < 1 && yRightCrossingRatio > 0 && yRightCrossing !== false && yRightCrossing < yMax && yRightCrossing > yMin ) {
	                          pointOnAxis.push( [ xMax, yRightCrossing ] );
	                        }
	                         if ( xTopCrossingRatio < 1 && xTopCrossingRatio > 0 && xTopCrossing !== false && xTopCrossing < xMax && xTopCrossing > xMin ) {
	                          pointOnAxis.push( [ xTopCrossing, yMin ] );
	                        }
	                         if ( xBottomCrossingRatio < 1 && xBottomCrossingRatio > 0 && xBottomCrossing !== false && xBottomCrossing < xMax && xBottomCrossing > xMin ) {
	                          pointOnAxis.push( [ xBottomCrossing, yMax ] );
	                        }
	                         if ( pointOnAxis.length > 0 ) {
	                           if ( !pointOutside ) { // We were outside and now go inside
	                             if ( pointOnAxis.length > 1 ) {
	                              console.error( "Programmation error. Please e-mail me." );
	                              console.log( pointOnAxis, xBottomCrossing, xTopCrossing, yRightCrossing, yLeftCrossing, y, yMin, yMax, lastY );
	                            }
	                             this._createLine();
	                            this._addPoint( this.getX( pointOnAxis[ 0 ][ 0 ] ), this.getY( pointOnAxis[ 0 ][ 1 ] ), pointOnAxis[ 0 ][ 0 ], pointOnAxis[ 0 ][ 1 ], false, false, false );
	                            this._addPoint( xpx2, ypx2, lastX, lastY, false, false, true );
	                           } else if ( !lastPointOutside ) { // We were inside and now go outside
	                             if ( pointOnAxis.length > 1 ) {
	                              console.error( "Programmation error. Please e-mail me." );
	                              console.log( pointOnAxis, xBottomCrossing, xTopCrossing, yRightCrossing, yLeftCrossing, y, yMin, yMax, lastY );
	                            }
	                             this._addPoint( this.getX( pointOnAxis[ 0 ][ 0 ] ), this.getY( pointOnAxis[ 0 ][ 1 ] ), pointOnAxis[ 0 ][ 0 ], pointOnAxis[ 0 ][ 1 ], false, false, false );
	                           } else {
	                             // No crossing: do nothing
	                            if ( pointOnAxis.length == 2 ) {
	                              this._createLine();
	                               this._addPoint( this.getX( pointOnAxis[ 0 ][ 0 ] ), this.getY( pointOnAxis[ 0 ][ 1 ] ), pointOnAxis[ 0 ][ 0 ], pointOnAxis[ 0 ][ 1 ], false, false, false );
	                              this._addPoint( this.getX( pointOnAxis[ 1 ][ 0 ] ), this.getY( pointOnAxis[ 1 ][ 1 ] ), pointOnAxis[ 0 ][ 0 ], pointOnAxis[ 0 ][ 1 ], false, false, false );
	                            }
	                           }
	                        } else if ( !pointOutside ) {
	                          this._addPoint( xpx2, ypx2, lastX, lastY, j, false, false );
	                        }
	                      }
	                       xpx = xpx2;
	                      ypx = ypx2;
	                      lastX = x;
	                      lastY = y;
	                       lastPointOutside = pointOutside;
	                       continue;
	                    }
	                   }*/

	          if (isNaN(xpx2) || isNaN(ypx2)) {
	            if (this.counter > 0) ;
	            continue;
	          }

	          var color = this.colors[j];

	          this._addPoint(xpx2, ypx2, x, y, xpx, ypx, lastX, lastY, j, color, false, true);

	          xpx = xpx2;
	          ypx = ypx2;

	          lastX = x;
	          lastY = y;
	        }

	        this.latchLines();

	        if (this._tracker) {

	          if (this._trackerDom) {
	            this._trackerDom.remove();
	          }

	          var cloned = this.groupLines.cloneNode(true);
	          this.groupMain.appendChild(cloned);

	          for (var i = 0, l = cloned.children.length; i < l; i++) {

	            cloned.children[i].setAttribute('stroke', 'transparent');
	            cloned.children[i].setAttribute('stroke-width', '25px');
	            cloned.children[i].setAttribute('pointer-events', 'stroke');
	          }

	          self._trackerDom = cloned;

	          self.groupMain.addEventListener('mousemove', function (e) {
	            var coords = self.graph._getXY(e),
	                ret = self.handleMouseMove(false, false);
	            self._trackingCallback(self, ret, coords.x, coords.y);
	          });

	          self.groupMain.addEventListener('mouseleave', function (e) {
	            self._trackingOutCallback(self);
	          });
	        }
	        return this;
	      }
	    }, {
	      key: '_addPoint',
	      value: function _addPoint(xpx, ypx, x, y, xpxbefore, ypxbefore, xbefore, ybefore, j, color, move, allowMarker) {

	        if (xpxbefore === undefined || ypxbefore === undefined) {
	          return;
	        }

	        if (isNaN(xpx) || isNaN(ypx)) {
	          return;
	        }

	        if (color._rgb) {
	          color = 'rgba(' + color._rgb[0] + ',' + color._rgb[1] + ',' + color._rgb[2] + ',' + (color._rgb[3] || 1) + ')';
	        }

	        var line = this.lines[color];
	        if (!line) {
	          line = this.lines[color] = {
	            object: document.createElementNS(this.graph.ns, 'path'),
	            path: '',
	            color: color
	          };
	          line.object.setAttribute('stroke', color);
	          line.color = color;
	          //      this.applyLineStyle( line );
	          this.groupLines.appendChild(line.object);
	        }

	        line.path += 'M ' + xpxbefore + ' ' + ypxbefore + ' L ' + xpx + ' ' + ypx;

	        if (this.hasErrors()) {
	          this.errorAddPoint(j, x, y, xpx, ypx);
	        }

	        /*if ( this.markersShown() && allowMarker !== false ) {
	          drawMarkerXY( this, this.markerFamilies[ this.selectionType ][ this.markerCurrentFamily ], xpx, ypx );
	        }*/
	      }
	    }, {
	      key: 'removeExtraLines',
	      value: function removeExtraLines() {}
	    }, {
	      key: 'latchLines',
	      value: function latchLines() {

	        for (var i in this.lines) {
	          this.lines[i].object.setAttribute('d', this.lines[i].path);
	        }
	      }
	    }, {
	      key: 'eraseLines',
	      value: function eraseLines() {

	        for (var i in this.lines) {
	          this.lines[i].path = '';
	          this.lines[i].object.setAttribute('d', '');
	        }
	      }
	    }, {
	      key: 'applyLineStyle',
	      value: function applyLineStyle(line) {

	        //line.setAttribute( 'stroke', this.getLineColor() );
	        line.setAttribute('stroke-width', this.getLineWidth());
	        if (this.getLineDashArray()) {
	          line.setAttribute('stroke-dasharray', this.getLineDashArray());
	        } else {
	          line.removeAttribute('stroke-dasharray');
	        }
	        line.setAttribute('fill', 'none');
	        //	line.setAttribute('shape-rendering', 'optimizeSpeed');
	      }
	    }]);

	    return SerieLineColor;
	  }(_graphSerieLine2.default);

	  exports.default = SerieLineColor;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 356 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(142), __webpack_require__(46), __webpack_require__(140), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphCore, _graphSerieZone, _waveform, _graphMixinSerie3d, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphCore2 = _interopRequireDefault(_graphCore);

	  var _graphSerieZone2 = _interopRequireDefault(_graphSerieZone);

	  var _waveform2 = _interopRequireDefault(_waveform);

	  var _graphMixinSerie3d2 = _interopRequireDefault(_graphMixinSerie3d);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieZone3D = function (_Serie) {
	    _inherits(SerieZone3D, _Serie);

	    _createClass(SerieZone3D, null, [{
	      key: 'default',
	      value: function _default() {
	        return {
	          zpos: 0
	        };
	      }
	    }]);

	    function SerieZone3D(graph, name, options) {
	      _classCallCheck(this, SerieZone3D);

	      return _possibleConstructorReturn(this, (SerieZone3D.__proto__ || Object.getPrototypeOf(SerieZone3D)).apply(this, arguments));
	    }

	    /**
	     * Sets the z-position
	     * @memberof SerieZone3D
	     * @param {Number} zPos - The position in the z axis
	     */


	    _createClass(SerieZone3D, [{
	      key: 'setZPos',
	      value: function setZPos(zPos) {
	        this.options.zpos = zPos;
	        return this;
	      }
	    }, {
	      key: 'setz',
	      value: function setz() {
	        return this.setZPos.apply(this, arguments);
	      }
	    }]);

	    return SerieZone3D;
	  }(_graphSerieZone2.default);

	  util.mix(SerieZone3D, _graphMixinSerie3d2.default);
	  exports.default = SerieZone3D;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 357 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(57), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphSerie, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphSerie2 = _interopRequireDefault(_graphSerie);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieDensityMap = function (_Serie) {
	    _inherits(SerieDensityMap, _Serie);

	    function SerieDensityMap(graph, name, options) {
	      _classCallCheck(this, SerieDensityMap);

	      var _this = _possibleConstructorReturn(this, (SerieDensityMap.__proto__ || Object.getPrototypeOf(SerieDensityMap)).apply(this, arguments));

	      util.mapEventEmission(_this.options, _this); // Register events

	      _this.groupMain = document.createElementNS(_this.graph.ns, 'g');

	      _this.rects = [];
	      _this.paths = [];

	      _this.recalculateBinsOnDraw = false;
	      return _this;
	    }
	    /**
	     * Sets the data of the serie. Careful, only one format allowed for now.
	     * @memberof SerieDensityMap
	     * @param {Array} data - A vector containing 2-elements arrays
	     * @return {SerieDensityMap} The current instance
	     * @example serie.setData( [ [ x1, y1 ], [ x2, y2 ], ..., [ xn, yn ] ] );
	     */


	    _createClass(SerieDensityMap, [{
	      key: 'setData',
	      value: function setData(data) {

	        this.minX = this.maxX = this.minY = this.maxY = 0;
	        var i = 0,
	            l = data.length;
	        this.data = data;

	        this.minX = Number.POSITIVE_INFINITY;
	        this.minY = Number.POSITIVE_INFINITY;
	        this.maxX = Number.NEGATIVE_INFINITY;
	        this.maxY = Number.NEGATIVE_INFINITY;

	        for (i = 0; i < l; i++) {
	          this._checkX(data[i][0]);
	          this._checkY(data[i][1]);
	        }

	        this.dataHasChanged();
	        this.graph.updateDataMinMaxAxes();

	        return this;
	      }
	    }, {
	      key: 'calculateDensity',
	      value: function calculateDensity(fromX, deltaX, numX, fromY, deltaY, numY) {

	        var densitymap = [],
	            i,
	            l = this.data.length,
	            indexX,
	            indexY;

	        var binMin = Number.POSITIVE_INFINITY;
	        var binMax = Number.NEGATIVE_INFINITY;

	        for (i = 0; i < l; i++) {
	          indexX = ~~((this.data[i][0] - fromX) / deltaX);
	          indexY = ~~((this.data[i][1] - fromY) / deltaY);

	          if (indexX > numX || indexY > numY || indexX < 0 || indexY < 0) {
	            continue;
	          }

	          densitymap[indexX] = densitymap[indexX] || [];
	          densitymap[indexX][indexY] = densitymap[indexX][indexY] + 1 || 1;

	          binMin = densitymap[indexX][indexY] < binMin ? densitymap[indexX][indexY] : binMin;
	          binMax = densitymap[indexX][indexY] > binMax ? densitymap[indexX][indexY] : binMax;
	          //binMax = Math.max( binMax, densitymap[ indexX ][ indexY ] );
	        }

	        this.maxIndexX = numX;
	        this.maxIndexY = numY;

	        this.binMin = binMin;
	        this.binMax = binMax;

	        this.deltaX = deltaX;
	        this.deltaY = deltaY;

	        this.fromX = fromX;
	        this.fromY = fromY;

	        this.numX = numX;
	        this.numY = numY;

	        this.densitymap = densitymap;
	        return densitymap;
	      }
	    }, {
	      key: 'setDensityMap',
	      value: function setDensityMap(densitymap, fromX, deltaX, numX, fromY, deltaY, numY) {

	        var i,
	            j,
	            l = this.data.length;

	        var binMin = Number.POSITIVE_INFINITY;
	        var binMax = Number.NEGATIVE_INFINITY;

	        for (i = 0; i < densitymap.length; i++) {

	          for (j = 0; j < densitymap[i].length; j++) {
	            binMin = densitymap[i][j] < binMin ? densitymap[i][j] : binMin;
	            binMax = densitymap[i][j] > binMax ? densitymap[i][j] : binMax;
	          }
	          //binMax = Math.max( binMax, densitymap[ indexX ][ indexY ] );
	        }

	        this.maxIndexX = densitymap.length;
	        this.maxIndexY = densitymap[0].length;

	        this.binMin = binMin;
	        this.binMax = binMax;

	        this.deltaX = deltaX;
	        this.deltaY = deltaY;

	        this.fromX = fromX;
	        this.fromY = fromY;

	        this.numX = this.maxIndexX;
	        this.numY = this.maxIndexY;

	        this.densitymap = densitymap;
	        return densitymap;
	      }
	    }, {
	      key: 'calculateDensityWeighted',
	      value: function calculateDensityWeighted(fromX, deltaX, numX, fromY, deltaY, numY) {

	        var densitymap = [],
	            i,
	            l = this.data.length,
	            indexX,
	            indexY;

	        var binMin = Number.POSITIVE_INFINITY;
	        var binMax = Number.NEGATIVE_INFINITY;

	        var compX, compY;
	        var exactX, exactY;
	        var indexXLow, indexXHigh, indexYLow, indexYHigh;

	        for (i = 0; i < l; i++) {
	          exactX = (this.data[i][0] - fromX) / deltaX - 0.5;
	          exactY = (this.data[i][1] - fromY) / deltaY - 0.5;

	          indexX = Math.floor(exactX);
	          indexY = Math.floor(exactY);

	          indexXLow = indexX; //Math.floor( exactX );
	          indexYLow = indexY; //Math.floor( exactY );

	          indexXHigh = indexX + 1; //Math.ceil( exactX );
	          indexYHigh = indexY + 1; //Math.ceil( exactY );

	          compX = 1 - (exactX - indexX);
	          compY = 1 - (exactY - indexY);

	          //console.log( exactY, indexY );
	          //console.log( compY, indexYLow, indexYHigh );
	          if (indexX > numX || indexY > numY || indexX < 0 || indexY < 0) {
	            continue;
	          }

	          densitymap[indexXLow] = densitymap[indexXLow] || [];
	          densitymap[indexXHigh] = densitymap[indexXHigh] || [];

	          densitymap[indexXLow][indexYLow] = densitymap[indexXLow][indexYLow] || 0;
	          densitymap[indexXHigh][indexYLow] = densitymap[indexXHigh][indexYLow] || 0;
	          densitymap[indexXLow][indexYHigh] = densitymap[indexXLow][indexYHigh] || 0;
	          densitymap[indexXHigh][indexYHigh] = densitymap[indexXHigh][indexYHigh] || 0;

	          densitymap[indexXLow][indexYLow] += compX * compY;
	          densitymap[indexXHigh][indexYLow] += (1 - compX) * compY;
	          densitymap[indexXLow][indexYHigh] += compX * (1 - compY);
	          densitymap[indexXHigh][indexYHigh] += (1 - compX) * (1 - compY);

	          // A loop would be nicer, but would it be faster ?
	          binMin = densitymap[indexXLow][indexYLow] < binMin ? densitymap[indexXLow][indexYLow] : binMin;
	          binMax = densitymap[indexXLow][indexYLow] > binMax ? densitymap[indexXLow][indexYLow] : binMax;
	          binMin = densitymap[indexXHigh][indexYLow] < binMin ? densitymap[indexXHigh][indexYLow] : binMin;
	          binMax = densitymap[indexXHigh][indexYLow] > binMax ? densitymap[indexXHigh][indexYLow] : binMax;
	          binMin = densitymap[indexXLow][indexYHigh] < binMin ? densitymap[indexXLow][indexYHigh] : binMin;
	          binMax = densitymap[indexXLow][indexYHigh] > binMax ? densitymap[indexXLow][indexYHigh] : binMax;
	          binMin = densitymap[indexXHigh][indexYHigh] < binMin ? densitymap[indexXHigh][indexYHigh] : binMin;
	          binMax = densitymap[indexXHigh][indexYHigh] > binMax ? densitymap[indexXHigh][indexYHigh] : binMax;

	          //binMax = Math.max( binMax, densitymap[ indexX ][ indexY ] );
	        }

	        this.maxIndexX = numX;
	        this.maxIndexY = numY;

	        this.binMin = binMin;
	        this.binMax = binMax;

	        this.deltaX = deltaX;
	        this.deltaY = deltaY;

	        this.fromX = fromX;
	        this.fromY = fromY;

	        this.numX = numX;
	        this.numY = numY;

	        this.densitymap = densitymap;
	        return densitymap;
	      }
	    }, {
	      key: 'autoBins',
	      value: function autoBins(numX, numY) {

	        this.numX = numX || 400;
	        this.numY = numY || this.numX;

	        this.calculateDensity(this.minX, (this.maxX - this.minX) / numX, numX, this.minY, (this.maxY - this.minY) / numY, numY);

	        this.recalculateBinsOnDraw = false;

	        return this;
	      }
	    }, {
	      key: 'setPxPerBin',
	      value: function setPxPerBin(pxPerBinX, pxPerBinY, weightedDensityMap) {

	        if (pxPerBinX) {
	          this.calculationDensityMap({
	            from: 'min',
	            to: 'max',
	            pxPerBin: pxPerBinX,
	            weighted: weightedDensityMap
	          });
	        }

	        if (pxPerBinY) {
	          this.calculationDensityMap(false, {
	            from: 'min',
	            to: 'max',
	            pxPerBin: pxPerBinY,
	            weighted: weightedDensityMap
	          });
	        }

	        return this;
	      }
	    }, {
	      key: 'setBinsFromTo',
	      value: function setBinsFromTo(mode, from, to, num) {

	        this.densityMapCalculation = this.densityMapCalculation || {};

	        this.densityMapCalculation[mode] = {
	          from: from,
	          to: to,
	          numBins: num
	        };
	        this.calculationDensityMap();
	        return this;
	      }
	    }, {
	      key: 'calculationDensityMap',
	      value: function calculationDensityMap(x, y) {

	        this.method = this.calculateDensityAdvanced;
	        this.densityMapCalculation = this.densityMapCalculation || {};

	        if (x) {
	          this.densityMapCalculation.x = x;
	        }

	        if (y) {
	          this.densityMapCalculation.y = y;
	        }
	      }
	    }, {
	      key: 'calculateDensityAdvanced',
	      value: function calculateDensityAdvanced() {

	        var results = {
	          x: {
	            from: 0,
	            num: 0,
	            delta: 0,
	            weighing: false
	          },

	          y: {
	            from: 0,
	            num: 0,
	            delta: 0,
	            weighing: false
	          }
	        };

	        var widthValues = {
	          x: this.graph.drawingSpaceWidth,
	          y: this.graph.drawingSpaceHeight
	        };
	        var axisGetter = {
	          x: this.getXAxis,
	          y: this.getYAxis
	        };

	        var weighing = false;

	        for (var i in this.densityMapCalculation) {

	          if (this.densityMapCalculation[i].weighted) {
	            weighing = true;
	            results[i].weighing = true;
	          }

	          if (this.densityMapCalculation[i].pxPerBin) {

	            // In value

	            var from = this.densityMapCalculation[i].from == 'min' ? axisGetter[i].call(this).getCurrentMin() : this.densityMapCalculation[i].from;
	            var to = this.densityMapCalculation[i].to == 'max' ? axisGetter[i].call(this).getCurrentMax() : this.densityMapCalculation[i].to;

	            // In px
	            var dimension = Math.abs(axisGetter[i].call(this).getRelPx(to - from));
	            results[i].num = Math.ceil(widthValues[i] / this.densityMapCalculation[i].pxPerBin);

	            //console.log( from, from - axisGetter[ i ].call( this ).getRelVal( ( results[i ].num * this.densityMapCalculation[ i ].pxPerBin - dimension ) / 2 ), ( results[i ].num * this.densityMapCalculation[ i ].pxPerBin - dimension ) / 2 );
	            results[i].from = from - Math.abs(axisGetter[i].call(this).getRelVal((results[i].num * this.densityMapCalculation[i].pxPerBin - dimension) / 2));
	            results[i].delta = Math.abs(axisGetter[i].call(this).getRelVal(this.densityMapCalculation[i].pxPerBin));
	          } else {

	            results[i].num = this.densityMapCalculation[i].numBins || 400;
	            results[i].from = this.densityMapCalculation[i].from == 'min' ? axisGetter[i].call(this).getCurrentMin() : this.densityMapCalculation[i].from;
	            results[i].delta = this.densityMapCalculation[i].to ? ((this.densityMapCalculation[i].to == 'max' ? axisGetter[i].call(this).getCurrentMax() : this.densityMapCalculation[i].to) - results[i].from) / results[i].num : this.densityMapCalculate[i].delta;
	          }

	          //      console.log( axisGetter[ i ].call( this ).getCurrentMin(), axisGetter[ i ].call( this ).getCurrentMax(), )
	        }
	        //console.log( this.getYAxis().getCurrentMin(), this.getYAxis().getCurrentMax(), this.graph.drawingSpaceHeight );

	        //console.log( this.densityMapCalculation );

	        (weighing ? this.calculateDensityWeighted : this.calculateDensity).call(this, results.x.from, results.x.delta, results.x.num, results.y.from, results.y.delta, results.y.num);
	      }
	    }, {
	      key: 'setColorMapBinBoundaries',
	      value: function setColorMapBinBoundaries(min, max) {
	        this.colorMapMin = min;
	        this.colorMapMax = max;
	        return this;
	      }
	    }, {
	      key: 'autoColorMapBinBoundaries',
	      value: function autoColorMapBinBoundaries() {
	        this.colorMapMin = this.binMin;
	        this.colorMapMax = this.binMax;
	        return this;
	      }
	    }, {
	      key: 'onRedrawColorMapBinBoundaries',
	      value: function onRedrawColorMapBinBoundaries(callback) {
	        this.callbackColorMapMinMax = callback;
	        return this;
	      }
	    }, {
	      key: 'colorMapHSL',
	      value: function colorMapHSL(colorStops, numColors, method) {

	        method = method || 'linear';

	        var methods = {
	          'exp': function exp(value) {
	            return (Math.exp(value / numColors * 1) - Math.exp(0)) / (Math.exp(1) - Math.exp(0));
	          },
	          'log': function log(value) {
	            return (Math.log(value + 1) - Math.log(1)) / (Math.log(numColors + 1) - Math.log(1));
	          },
	          'linear': function linear(value) {
	            return (value - 0) / (numColors - 0);
	          }
	        };

	        var k = 0,
	            colorMap = [],
	            opacities = [];

	        var color = {
	          h: null,
	          s: null,
	          l: null,
	          a: null
	        };

	        var ratio, first;

	        var slices = colorStops.length - 1;

	        for (var i = 0; i <= numColors; i++) {

	          ratio = methods[method](i);

	          first = Math.floor(ratio * slices);

	          if (first == colorStops.length - 1) {
	            // Handle 1
	            first = slices - 1;
	          }

	          ratio = (ratio - first / slices) / (1 / slices);

	          for (var j in color) {
	            color[j] = (colorStops[first + 1][j] - colorStops[first][j]) * ratio + colorStops[first][j];
	          }

	          colorMap[k] = 'hsl(' + color.h + ', ' + Math.round(color.s * 100) + '%, ' + Math.round(color.l * 100) + '%)'; //this.HSVtoRGB( color.h, color.s, color.v );
	          opacities[k] = color.a;
	          k++;
	        }

	        this.opacities = opacities;
	        this.colorMap = colorMap;
	        this.colorMapNum = numColors;
	        return this;
	      }
	    }, {
	      key: 'autoColorMapHSL',
	      value: function autoColorMapHSL(colorStops) {
	        var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'linear';

	        this.colorMapHSV(colorStops, 100, method);
	        return this;
	      }
	    }, {
	      key: 'getColorIndex',
	      value: function getColorIndex(binValue) {

	        return Math.max(0, Math.min(this.colorMapNum, Math.floor((binValue - this.colorMapMin) / (this.colorMapMax - this.colorMapMin) * this.colorMapNum)));
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {

	        var colorIndex;

	        if (this.method) {
	          this.method();
	        }

	        if (!this.callbackColorMapMinMax || this.colorMapMin == undefined || this.colorMapMax == undefined || this.callbackColorMapMinMax == 'auto') {

	          this.autoColorMapBinBoundaries();
	        } else {
	          var val = this.callbackColorMapMinMax(this.binMin, this.binMax);

	          this.setColorMapBinBoundaries(val[0], val[1]);
	        }

	        var deltaXPx = this.getXAxis().getRelPx(this.deltaX),
	            deltaYPx = this.getYAxis().getRelPx(this.deltaY);

	        for (var i = 0; i < this.paths.length; i++) {
	          this.paths[i] = '';
	        }

	        for (var i = 0; i < this.maxIndexX; i++) {

	          for (var j = 0; j < this.maxIndexY; j++) {

	            if (this.densitymap[i] == undefined || this.densitymap[i][j] == undefined) {
	              continue;
	            }

	            colorIndex = this.getColorIndex(this.densitymap[i][j]);
	            if (!this.paths[colorIndex]) {
	              this.paths[colorIndex] = '';
	            }

	            this.paths[colorIndex] += ' M ' + this.getXAxis().getPx(i * this.deltaX + this.fromX) + ' ' + this.getYAxis().getPx(j * this.deltaY + this.fromY) + ' h ' + deltaXPx + ' v ' + deltaYPx + ' h -' + deltaXPx + ' z';
	          }
	        }
	        /*
	            this.maxIndexX = indexX;
	            this.maxIndexY = indexY;*/

	        this.drawRects();
	      }
	    }, {
	      key: 'drawRects',
	      value: function drawRects() {

	        for (var i = 0; i < this.paths.length; i++) {

	          if (!this.rects[i]) {
	            this.rects[i] = document.createElementNS(this.graph.ns, 'path');
	            this.rects[i].setAttribute('shape-rendering', 'crispEdges');
	          }

	          if (this.paths[i] !== undefined) {
	            this.rects[i].setAttribute('d', this.paths[i]);
	            this.rects[i].setAttribute('fill', this.colorMap[i]);
	            this.rects[i].setAttribute('fill-opacity', this.opacities[i]);
	          }
	          this.groupMain.appendChild(this.rects[i]);
	        }
	      }
	    }, {
	      key: 'setOptions',
	      value: function setOptions(options) {
	        this.options = util.extend(true, {}, this.defaults(), options || {});
	        // Unselected style

	        return this;
	      }
	    }]);

	    return SerieDensityMap;
	  }(_graphSerie2.default);

	  exports.default = SerieDensityMap;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 358 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(51), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphSerieLine, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieContour = function (_SerieLine) {
	    _inherits(SerieContour, _SerieLine);

	    function SerieContour(graph, name, options) {
	      _classCallCheck(this, SerieContour);

	      var _this = _possibleConstructorReturn(this, (SerieContour.__proto__ || Object.getPrototypeOf(SerieContour)).apply(this, arguments));

	      _this.negativeDelta = 0;
	      _this.positiveDelta = 0;

	      _this.negativeThreshold = 0;
	      _this.positiveThreshold = 0;

	      _this.groupMain.setAttribute('clip-path', 'url(#_clipplot' + graph._creation + ')');
	      return _this;
	    }

	    /**
	     * Sets the contour lines
	     * @memberof SerieContour.prototype
	     * @param {Object} data - The object data
	     * @param {Number} data.minX - The minimum x value
	     * @param {Number} data.maxX - The maximum x value
	     * @param {Number} data.minY - The minimum y value
	     * @param {Number} data.maxY - The maximum y value
	     * @param {Object[]} data.segments - The segments making up the contour lines
	     * @param {Number[]} data.segments.lines - An array of alternating (x1,y1,x2,y2) quadruplet
	     * @param {Number} data.segments.zValue - The corresponding z-value of this array
	     * @return {Serie} The current serie
	     */


	    _createClass(SerieContour, [{
	      key: 'setData',
	      value: function setData(data, arg, type) {
	        var type = type || 'float',
	            i,
	            l = data.length,
	            j,
	            k,
	            arr,
	            datas = [];

	        if (!(data instanceof Array)) {

	          if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) == 'object') {
	            // Def v2
	            this.minX = data.minX;
	            this.minY = data.minY;
	            this.maxX = data.maxX;
	            this.maxY = data.maxY;

	            data = data.segments;
	            l = data.length;
	          }
	        }

	        for (i = 0; i < l; i++) {
	          k = data[i].lines.length;
	          arr = this._addData(type, k);

	          for (j = 0; j < k; j += 2) {

	            arr[j] = data[i].lines[j];
	            this._checkX(arr[j]);
	            arr[j + 1] = data[i].lines[j + 1];
	            this._checkY(arr[j + 1]);
	          }

	          datas.push({
	            lines: arr,
	            zValue: data[i].zValue
	          });
	        }
	        this.data = datas;
	        this.graph.updateDataMinMaxAxes();

	        this.dataHasChanged(true);

	        return this;
	      }
	    }, {
	      key: 'draw',
	      value: function draw(force) {

	        if (force || this.hasDataChanged()) {

	          this.currentLine = 0;
	          var xpx,
	              ypx,
	              xpx2,
	              ypx2,
	              i = 0,
	              l = this.data.length,
	              j = 0,
	              m,
	              domLine,
	              arr;
	          this.minZ = Infinity;
	          this.maxZ = -Infinity;

	          var next = this.groupLines.nextSibling;
	          this.groupMain.removeChild(this.groupLines);
	          this.zValues = {};

	          var incrXFlip = 0;
	          var incrYFlip = 1;
	          if (this.getFlip()) {
	            incrXFlip = 0;
	            incrYFlip = 1;
	          }

	          var minY = this.getYAxis().getCurrentMin();
	          var minX = this.getXAxis().getCurrentMin();

	          var maxX = this.getXAxis().getCurrentMax();
	          var maxY = this.getYAxis().getCurrentMax();

	          this.counter = 0;
	          this.currentLineId = 0;

	          for (; i < l; i++) {
	            this.currentLine = '';
	            j = 0;

	            for (arr = this.data[i].lines, m = arr.length; j < m; j += 4) {

	              if (arr[j + incrXFlip] < minX && arr[j + 2 + incrXFlip] < minX || arr[j + incrYFlip] < minY && arr[j + 2 + incrYFlip] < minY || arr[j + incrYFlip] > maxY && arr[j + 2 + incrYFlip] > maxY || arr[j + incrXFlip] > maxX && arr[j + 2 + incrXFlip] > maxX) {
	                continue;
	              }

	              xpx2 = this.getX(arr[j + incrXFlip]);
	              ypx2 = this.getY(arr[j + incrYFlip]);

	              xpx = this.getX(arr[j + 2 + incrXFlip]);
	              ypx = this.getY(arr[j + 2 + incrYFlip]);

	              if (xpx == xpx2 && ypx == ypx2) {
	                continue;
	              }

	              /*	if( j > 0 && ( lastxpx !== undefined && lastypx !== undefined && Math.abs( xpx2 - lastxpx ) <= 30 && Math.abs( ypx2 - lastypx ) <= 30 ) ) {
	              currentLine += "L";
	              } else {
	              currentLine += "M";
	              }
	              */

	              this.currentLine += 'M ';
	              this.currentLine += xpx2;
	              this.currentLine += ' ';
	              this.currentLine += ypx2;

	              this.currentLine += 'L ';
	              this.currentLine += xpx;
	              this.currentLine += ' ';
	              this.currentLine += ypx;

	              this.counter++;
	            }

	            this.currentLine += ' z';

	            domLine = this._createLine();
	            domLine.setAttribute('data-zvalue', this.data[i].zValue);

	            this.zValues[this.data[i].zValue] = {
	              dom: domLine
	            };

	            this.minZ = Math.min(this.minZ, this.data[i].zValue);
	            this.maxZ = Math.max(this.maxZ, this.data[i].zValue);
	          }

	          i++;

	          for (i = this.currentLine + 1; i < this.lines.length; i++) {
	            this.groupLines.removeChild(this.lines[i]);
	            this.lines.splice(i, 1);
	          }

	          i = 0;

	          for (; i < l; i++) {
	            this.setColorTo(this.lines[i], this.data[i].zValue, this.minZ, this.maxZ);
	          }

	          this.onMouseWheel(0, {
	            shiftKey: false
	          });
	          this.groupMain.insertBefore(this.groupLines, next);
	        } else if (this.hasStyleChanged(this.selectionType)) {

	          for (; i < l; i++) {
	            this.setColorTo(this.lines[i], this.data[i].zValue, this.minZ, this.maxZ);
	          }
	        }
	      }
	    }, {
	      key: 'onMouseWheel',
	      value: function onMouseWheel(delta, e, fixed, positive) {

	        delta /= 250;

	        if (fixed !== undefined) {

	          if (!positive) {
	            this.negativeThreshold = -fixed * this.minZ;
	            this.negativeDelta = -Math.pow(Math.abs(this.negativeThreshold / -this.minZ), 1 / 3);
	          }

	          if (positive) {
	            this.positiveThreshold = fixed * this.maxZ;
	            this.positiveDelta = Math.pow(this.positiveThreshold / this.maxZ, 1 / 3);
	          }
	        } else {

	          if (!e.shiftKey || !this.options.hasNegative) {

	            this.positiveDelta = Math.min(1, Math.max(0, this.positiveDelta + Math.min(0.1, Math.max(-0.1, delta))));
	            this.positiveThreshold = this.maxZ * Math.pow(this.positiveDelta, 3);
	          } else {

	            this.negativeDelta = Math.min(0, Math.max(-1, this.negativeDelta + Math.min(0.1, Math.max(-0.1, delta))));
	            this.negativeThreshold = -this.minZ * Math.pow(this.negativeDelta, 3);
	          }
	        }

	        if (isNaN(this.positiveDelta)) {
	          this.positiveDelta = 0;
	        }

	        if (isNaN(this.negativeDelta)) {
	          this.negativeDelta = 0;
	        }

	        for (var i in this.zValues) {

	          this.zValues[i].dom.setAttribute('display', i >= 0 && i >= this.positiveThreshold || i <= 0 && i <= this.negativeThreshold ? 'block' : 'none');
	        }

	        if (this._shapeZoom) {

	          if (!this.options.hasNegative) {
	            this._shapeZoom.hideHandleNeg();
	          } else {

	            this._shapeZoom.setHandleNeg(-Math.pow(this.negativeDelta, 3), this.minZ);
	            this._shapeZoom.showHandleNeg();
	          }

	          this._shapeZoom.setHandlePos(Math.pow(this.positiveDelta, 3), this.maxZ);
	        }
	      }
	    }, {
	      key: 'setDynamicColor',
	      value: function setDynamicColor(colors) {
	        this.lineColors = colors;

	        this.styleHasChanged();
	      }
	    }, {
	      key: 'setNegative',
	      value: function setNegative(bln) {
	        this.options.hasNegative = bln;

	        if (bln) {
	          this.negativeThreshold = 0;
	        }
	      }
	    }, {
	      key: 'setColorTo',
	      value: function setColorTo(line, zValue, min, max) {

	        if (!this.lineColors) {
	          return;
	        }

	        var hsl = {
	          h: 0,
	          s: 0,
	          l: 0
	        };

	        for (var i in hsl) {

	          if (zValue > 0) {
	            hsl[i] = this.lineColors.fromPositive[i] + (this.lineColors.toPositive[i] - this.lineColors.fromPositive[i]) * (zValue / max);
	          } else {
	            hsl[i] = this.lineColors.fromNegative[i] + (this.lineColors.toNegative[i] - this.lineColors.fromNegative[i]) * (zValue / min);
	          }
	        }

	        hsl.h /= 360;

	        var rgb = util.hslToRgb(hsl.h, hsl.s, hsl.l);

	        line.setAttribute('stroke', 'rgb(' + rgb.join() + ')');
	      }
	    }, {
	      key: 'getSymbolForLegend',
	      value: function getSymbolForLegend() {

	        if (!this.lineForLegend) {

	          var line = document.createElementNS(this.graph.ns, 'ellipse');

	          line.setAttribute('cx', 7);
	          line.setAttribute('cy', 0);
	          line.setAttribute('rx', 8);
	          line.setAttribute('ry', 3);

	          line.setAttribute('cursor', 'pointer');
	          this.lineForLegend = line;
	        }

	        this.applyLineStyle(this.lineForLegend, this.maxZ);

	        return this.lineForLegend;
	      }
	    }, {
	      key: 'applyLineStyle',
	      value: function applyLineStyle(line, overwriteValue) {
	        line.setAttribute('stroke', this.getLineColor());
	        line.setAttribute('stroke-width', this.getLineWidth() + (this.isSelected() ? 2 : 0));
	        if (this.getLineDashArray()) {
	          line.setAttribute('stroke-dasharray', this.getLineDashArray());
	        }
	        line.setAttribute('fill', 'none');

	        this.setColorTo(line, overwriteValue !== undefined ? overwriteValue : line.getAttribute('data-zvalue'), this.minZ, this.maxZ);
	        //  line.setAttribute('shape-rendering', 'optimizeSpeed');

	        this.hasStyleChanged(false);
	      }
	    }, {
	      key: 'setShapeZoom',
	      value: function setShapeZoom(shape) {
	        this._shapeZoom = shape;
	      }
	    }]);

	    return SerieContour;
	  }(_graphSerieLine2.default);

	  exports.default = SerieContour;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 359 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShape) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeSurfaceUnderCurve = function (_Shape) {
	    _inherits(ShapeSurfaceUnderCurve, _Shape);

	    function ShapeSurfaceUnderCurve() {
	      _classCallCheck(this, ShapeSurfaceUnderCurve);

	      return _possibleConstructorReturn(this, (ShapeSurfaceUnderCurve.__proto__ || Object.getPrototypeOf(ShapeSurfaceUnderCurve)).apply(this, arguments));
	    }

	    _createClass(ShapeSurfaceUnderCurve, [{
	      key: 'createDom',
	      value: function createDom() {
	        this._dom = document.createElementNS(this.graph.ns, 'path');
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {

	        this._createHandles(2, 'line', {
	          'stroke-width': '3',
	          'stroke': 'transparent',
	          'pointer-events': 'stroke',
	          'cursor': 'ew-resize'
	        });
	      }
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl(e, deltaX, deltaY) {

	        if (this.isLocked()) {
	          return;
	        }

	        if (this.moving) {

	          this.getPosition(0).deltaPosition('x', deltaX, this.getXAxis());
	          this.getPosition(1).deltaPosition('x', deltaX, this.getXAxis());
	        } else if (this.serie && this.handleSelected) {

	          this.resizingPosition = this.handleSelected == 1 ? this.getPosition(0) : this.getPosition(1);

	          var value = this.serie.searchClosestValue(this.getXAxis().getVal(this.graph._getXY(e).x - this.graph.getPaddingLeft()));

	          if (!value) {
	            return;
	          }

	          if (this.resizingPosition.x != value.xMin) {
	            this.preventUnselect = true;
	          }

	          this.resizingPosition.x = value.xMin;
	        } else if (this.handleSelected) {

	          this.resizingPosition = this.handleSelected == 1 ? this.getPosition(0) : this.getPosition(1);
	          this.resizingPosition.deltaPosition('x', deltaX, this.getXAxis());
	        }

	        this.applyPosition();
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        if (!this.serie) {
	          return;
	        }

	        var posXY = this.computePosition(0),
	            posXY2 = this.computePosition(1),
	            w = Math.abs(posXY.x - posXY2.x),
	            x = Math.min(posXY.x, posXY2.x);

	        //  this.reversed = x == posXY2.x;

	        if (w < 2 || x + w < 0 || x > this.graph.getDrawingWidth()) {
	          this.setDom('d', '');
	          return false;
	        }

	        var v1 = this.serie.searchClosestValue(this.getPosition(0).x),
	            v2 = this.serie.searchClosestValue(this.getPosition(1).x),
	            v3,
	            i,
	            j,
	            init,
	            max,
	            k,
	            x,
	            y,
	            maxY = 0,
	            minY = Number.MAX_VALUE;

	        if (!v1 || !v2) {
	          return false;
	        }

	        if (v1.xBeforeIndex > v2.xBeforeIndex) {
	          v3 = v1;
	          v1 = v2;
	          v2 = v3;

	          //this.handleSelected = ( this.handleSelected == 1 ) ? 2 : 1;
	        }

	        this.counter = 0;

	        for (i = v1.dataIndex; i <= v2.dataIndex; i++) {
	          this.currentLine = '';
	          init = i == v1.dataIndex ? v1.xBeforeIndexArr : 0;
	          max = i == v2.dataIndex ? v2.xBeforeIndexArr : this.serie.data[i].length;
	          k = 0;

	          if (init == max) {
	            max++;
	          }

	          for (j = init; j <= max; j += 2) {

	            x = this.serie.getX(this.serie.data[i][j + 0]);
	            y = this.serie.getY(this.serie.data[i][j + 1]);

	            maxY = Math.max(this.serie.data[i][j + 1], maxY);
	            minY = Math.min(this.serie.data[i][j + 1], minY);

	            if (j == init) {
	              this.firstX = x;
	              this.firstY = y;
	            }

	            if (k > 0) {
	              this.currentLine += ' L ' + x + ' ' + y + ' ';
	            } else {
	              this.currentLine += ' M ' + x + ' ' + y + ' ';
	            }

	            //this.serie._addPoint( x, y, false, this.currentLine );
	            k++;
	          }

	          this.lastX = x;
	          this.lastY = y;

	          if (!this.firstX || !this.firstY || !this.lastX || !this.lastY) {
	            return;
	          }

	          this.currentLine += ' V ' + this.getYAxis().getPx(0) + ' H ' + this.firstX + ' z';
	          this.setDom('d', this.currentLine);
	        }

	        this.maxY = this.serie.getY(maxY);
	        this.setHandles();

	        this.changed();

	        return true;
	      }
	    }, {
	      key: 'setHandles',
	      value: function setHandles() {

	        if (!this.firstX) {
	          return;
	        }

	        var posXY = this.computePosition(0),
	            posXY2 = this.computePosition(1);

	        if (posXY.x < posXY2.x) {

	          this.handles[1].setAttribute('x1', this.firstX);
	          this.handles[1].setAttribute('x2', this.firstX);

	          this.handles[2].setAttribute('x1', this.lastX);
	          this.handles[2].setAttribute('x2', this.lastX);
	        } else {

	          this.handles[1].setAttribute('x1', this.lastX);
	          this.handles[1].setAttribute('x2', this.lastX);

	          this.handles[2].setAttribute('x1', this.firstX);
	          this.handles[2].setAttribute('x2', this.firstX);
	        }
	        this.handles[1].setAttribute('y1', this.getYAxis().getMaxPx());
	        this.handles[1].setAttribute('y2', this.serie.getY(0));

	        this.handles[2].setAttribute('y1', this.getYAxis().getMaxPx());
	        this.handles[2].setAttribute('y2', this.serie.getY(0));
	      }
	    }]);

	    return ShapeSurfaceUnderCurve;
	  }(_graphShape2.default);

	  exports.default = ShapeSurfaceUnderCurve;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 360 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(102)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShapeLine) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShapeLine2 = _interopRequireDefault(_graphShapeLine);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeArrow = function (_ShapeLine) {
	    _inherits(ShapeArrow, _ShapeLine);

	    function ShapeArrow(graph) {
	      _classCallCheck(this, ShapeArrow);

	      return _possibleConstructorReturn(this, (ShapeArrow.__proto__ || Object.getPrototypeOf(ShapeArrow)).call(this, graph));
	    }

	    _createClass(ShapeArrow, [{
	      key: 'createDom',
	      value: function createDom() {

	        this._dom = document.createElementNS(this.graph.ns, 'line');
	        this._dom.setAttribute('marker-end', 'url(#arrow' + this.graph._creation + ')');

	        this.createHandles(this.nbHandles, 'rect', {
	          transform: 'translate(-3 -3)',
	          width: 6,
	          height: 6,
	          stroke: 'black',
	          fill: 'white',
	          cursor: 'nwse-resize'
	        });

	        this.setStrokeColor('black');
	        this.setStrokeWidth(1);
	      }
	    }]);

	    return ShapeArrow;
	  }(_graphShapeLine2.default);

	  exports.default = ShapeArrow;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 361 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShape) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeLabel = function (_GraphShape) {
	    _inherits(ShapeLabel, _GraphShape);

	    function ShapeLabel(graph, options) {
	      _classCallCheck(this, ShapeLabel);

	      return _possibleConstructorReturn(this, (ShapeLabel.__proto__ || Object.getPrototypeOf(ShapeLabel)).call(this, graph, options));
	    }

	    _createClass(ShapeLabel, [{
	      key: 'createDom',
	      value: function createDom() {
	        return false;
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {
	        return true;
	      }
	    }]);

	    return ShapeLabel;
	  }(_graphShape2.default);

	  exports.default = ShapeLabel;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 362 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShape) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapePolyline = function (_Shape) {
	    _inherits(ShapePolyline, _Shape);

	    function ShapePolyline(graph, options) {
	      _classCallCheck(this, ShapePolyline);

	      return _possibleConstructorReturn(this, (ShapePolyline.__proto__ || Object.getPrototypeOf(ShapePolyline)).call(this, graph, options));
	    }

	    /**
	     * Creates the DOM
	     * @private
	     * @return {Shape} The current shape
	     */


	    _createClass(ShapePolyline, [{
	      key: 'createDom',
	      value: function createDom() {

	        this._dom = document.createElementNS(this.graph.ns, 'path');

	        if (!this.getStrokeColor()) {
	          this.setStrokeColor('black');
	        }

	        if (this.getStrokeWidth() == undefined) {
	          this.setStrokeWidth(1);
	        }
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {}
	    }, {
	      key: 'setPointsPx',
	      value: function setPointsPx(points) {
	        this.setProp('pxPoints', points);
	        return this;
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        var pxPoints = void 0;
	        var pos = this.computePosition(0);

	        if (pxPoints = this.getProp('pxPoints')) {

	          pxPoints = ' M ' + pos.x + ' ' + pos.y + ' ' + pxPoints;
	          this.setDom('d', pxPoints);
	        } else if (this.points) {

	          var xAxis, yAxis;

	          if (this.serie) {

	            xAxis = this.serie.getXAxis();
	            yAxis = this.serie.getYAxis();
	          } else if (this.xAxis && this.yAxis) {

	            xAxis = this.xAxis;
	            yAxis = this.yAxis;
	          }

	          this.setDom('d', 'M ' + this.points.map(function (p) {
	            return xAxis.getPx(p[0]) + ', ' + yAxis.getPx(p[1]);
	          }).join(' L '));
	        }

	        this.changed();
	        return true;
	      }
	    }]);

	    return ShapePolyline;
	  }(_graphShape2.default);

	  exports.default = ShapePolyline;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 363 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28), __webpack_require__(55)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShape, _graphPosition) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  var _graphPosition2 = _interopRequireDefault(_graphPosition);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeNMRIntegral = function (_Shape) {
	    _inherits(ShapeNMRIntegral, _Shape);

	    function ShapeNMRIntegral(graph, options) {
	      _classCallCheck(this, ShapeNMRIntegral);

	      var _this = _possibleConstructorReturn(this, (ShapeNMRIntegral.__proto__ || Object.getPrototypeOf(ShapeNMRIntegral)).call(this, graph, options));

	      _this.nbHandles = 2;
	      return _this;
	    }

	    _createClass(ShapeNMRIntegral, [{
	      key: 'createDom',
	      value: function createDom() {
	        this._dom = document.createElementNS(this.graph.ns, 'path');
	        this._domShadow = document.createElementNS(this.graph.ns, 'path');
	        this._domShadow.jsGraphIsShape = this;
	        this._dom.setAttribute('pointer-events', 'stroke');
	        this._domShadow.setAttribute('pointer-events', 'stroke');
	        this._domShadow.setAttribute('stroke-width', '12');
	        this._domShadow.setAttribute('fill', 'transparent');
	        this._domShadow.setAttribute('stroke', 'transparent');
	        this.group.appendChild(this._domShadow);
	      }
	    }, {
	      key: 'initImpl',
	      value: function initImpl() {
	        this.setFillColor('transparent');
	        this.setStrokeColor('black');
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {

	        this._createHandles(2, 'rect', {
	          transform: 'translate(-3 -3)',
	          width: 6,
	          height: 6,
	          stroke: 'black',
	          fill: 'white'
	        });

	        this.handles[1].setAttribute('fill', 'red');
	      }
	    }, {
	      key: 'xor',
	      value: function xor(a, b) {
	        return a && !b || !a && b;
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        var x = void 0,
	            y = void 0,
	            xVal = void 0,
	            yVal = void 0,
	            axis = this.getAxis(),
	            points = [];

	        var currentLine = '',
	            baseLine = this.getProp('baseLine', 0) || 300,
	            ratio = void 0;

	        if (!this.serie) {
	          throw 'No serie exists for this shape';
	        }
	        /*
	            this.sortPositions( ( a, b ) => {
	              return a.x - b.x;
	            } );
	             */
	        var pos1 = this.getPosition(0);
	        var pos2 = this.getPosition(1);

	        if (pos1.x < this.serie.getXAxis().getCurrentMin() && pos2.x < this.serie.getXAxis().getCurrentMin() || pos1.x > this.serie.getXAxis().getCurrentMax() && pos2.x > this.serie.getXAxis().getCurrentMax()) {
	          this.setDom('d', '');
	          this._domShadow.setAttribute('d', '');

	          this.hideLabel(0);
	          return false;
	        }

	        this.showLabel(0);

	        var sum = 0;

	        var j = void 0;
	        var waveform = this.serie.getWaveform();

	        if (!waveform) {
	          return;
	        }

	        var index1 = waveform.getIndexFromX(pos1[axis], true, Math.floor),
	            index2 = waveform.getIndexFromX(pos2[axis], true, Math.ceil),
	            index3 = void 0,
	            flipped = false;

	        if (index1 == index2) {
	          // At least one px please !
	          if (waveform.getReductionType() == 'aggregate') {
	            index2 += 4; // Aggregated state
	          } else {
	            index2++; // Non aggregated state
	          }
	        }

	        if (index2 < index1) {
	          index3 = index1;
	          index1 = index2;
	          index2 = index3;
	          flipped = true;
	        }

	        var firstX = void 0,
	            firstY = void 0,
	            firstXVal = void 0,
	            firstYVal = void 0,
	            lastX = void 0,
	            lastXVal = void 0,
	            lastYVal = void 0;
	        var data = waveform.getDataInUse();

	        var condition = void 0,
	            incrementation = void 0;
	        if (waveform.getReductionType() == 'aggregate') ;

	        if (waveform.getXMonotoneousAscending() && // Ascending
	        1 == 1 || !waveform.getXMonotoneousAscending() && // Ascending
	        1 == 2) {

	          j = index2;
	          condition = true;
	          incrementation = -1;
	        } else {

	          j = index1;
	          condition = false;
	          incrementation = 1;
	        }

	        for (; condition ? j >= index1 : j <= index2; j += incrementation) {

	          xVal = waveform.getX(j, true);
	          yVal = waveform.getY(j, true);

	          x = this.serie.getX(xVal);
	          y = this.serie.getY(yVal);

	          /*
	                if ( ! normalSums && j % 4 == 0 && j >= index1 && data.sums ) { // Sums are located every 4 element
	                   sum += data.sums[ j ];// * ( waveform.getX( j, true ) - waveform.getX( j - 3, true ) ); // y * (out-in)
	                 } else if( normalSums ) {
	          */
	          sum += waveform.getY(j, true); // * ( waveform.getX( j, true ) - waveform.getX( j - 1, true ) ); // y * (out-in)
	          //}

	          if (!firstX) {

	            firstX = x;
	            firstY = y;
	            firstXVal = waveform.getX(j);
	            firstYVal = waveform.getY(j);
	          }

	          if (lastX == undefined) {

	            lastX = x;
	            lastXVal = waveform.getX(j);
	            lastYVal = waveform.getY(j);
	            continue;
	          }

	          lastX = x;
	          //console.log( data, data[ j ] );

	          points.push([x, y, sum]);
	          lastXVal = xVal;
	        }

	        lastXVal = false;
	        lastYVal = false;
	        lastX = false;

	        if (sum == 0) {
	          sum = 1;
	        }

	        this._sumVal = waveform.integrate(pos1.x, pos2.x);

	        if (!this.ratio) {
	          // 150px / unit
	          ratio = 200 / sum;
	        } else {
	          // Already existing
	          ratio = this.ratio * (this.sumVal / sum);
	        }
	        var py = void 0;

	        if (points.length == 0) {
	          return;
	        }

	        for (var i = 0, l = points.length; i < l; i++) {

	          py = baseLine - points[i][2] * ratio;

	          if (i > 0 && (points[i - 1][2] > sum / 2 && points[i][2] <= sum / 2 || points[i - 1][2] < sum / 2 && points[i][2] >= sum / 2)) {

	            var pos = baseLine - (points[i - 1][2] + points[i][2]) / 2 * ratio;

	            this.setPosition({
	              x: points[i][0] + 'px',
	              y: pos + 'px'

	            }, 3);

	            this.setLabelPosition(this.getPosition(3), 0);
	          }

	          currentLine += ' L ' + points[i][0] + ', ' + py + ' ';

	          this.lastPointX = points[i][0];
	          this.lastPointY = py;
	        }

	        this.points = points;
	        this._sum = sum;

	        if (this.serie.isFlipped()) {
	          currentLine = ' M ' + baseLine + ', ' + firstX + ' ' + currentLine;
	        } else {
	          currentLine = ' M ' + firstX + ', ' + baseLine + ' ' + currentLine;
	        }

	        this.firstPointX = firstX;
	        this.firstPointY = baseLine;

	        this.setDom('d', currentLine);
	        this._domShadow.setAttribute('d', currentLine);

	        this.firstX = firstX;
	        this.firstY = firstY;
	        /*
	              if ( this._selected ) {
	                this.select();
	              }
	               this.setHandles();*/

	        this.serie.ratioLabel && this.updateIntegralValue(this.serie.ratioLabel) || this.updateLabels();

	        this.changed();
	        this.handleCondition = !this.xor(incrementation == -1, flipped);
	        this.setHandles();

	        this.updateIntegralValue();

	        return true;
	      }
	    }, {
	      key: 'updateIntegralValue',
	      value: function updateIntegralValue() {
	        var ratioLabel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.serie.ratioLabel;
	        var forceValue = arguments[1];

	        console.log(ratioLabel);
	        if (ratioLabel) {
	          this.serie.ratioLabel = ratioLabel;
	        }

	        if (!isNaN(forceValue) && !isNaN(this.sumVal) && this.sumVal) {
	          this.serie.ratioLabel = forceValue / this.sumVal;
	        }

	        this.setLabelText(ratioLabel ? (Math.round(100 * this.sumVal * ratioLabel) / 100).toPrecision(3) : 'N/A', 0);
	        this.updateLabels();
	        return this.serie.ratioLabel;
	      }
	    }, {
	      key: 'getAxis',
	      value: function getAxis() {
	        return this._data.axis || 'x';
	      }
	    }, {
	      key: 'selectStyle',
	      value: function selectStyle() {
	        this.setDom('stroke-width', '2px');
	      }
	    }, {
	      key: 'selectHandles',
	      value: function selectHandles() {}
	    }, {
	      key: 'setHandles',
	      value: function setHandles() {

	        if (this.points == undefined) {
	          return;
	        }

	        if (!this.isSelected()) {
	          return;
	        }

	        this.addHandles();

	        if (this.handleCondition) {

	          this.handles[1].setAttribute('x', this.firstPointX);
	          this.handles[1].setAttribute('y', this.firstPointY);
	          this.handles[2].setAttribute('x', this.lastPointX);
	          this.handles[2].setAttribute('y', this.lastPointY);
	        } else {

	          this.handles[2].setAttribute('x', this.firstPointX);
	          this.handles[2].setAttribute('y', this.firstPointY);
	          this.handles[1].setAttribute('x', this.lastPointX);
	          this.handles[1].setAttribute('y', this.lastPointY);
	        }
	      }
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

	        if (this.isLocked()) {
	          return;
	        }

	        var pos = this.getPosition(0);
	        var pos2 = this.getPosition(1);

	        var posToChange;

	        if (this.handleSelected == 1) {

	          posToChange = pos;
	        } else if (this.handleSelected == 2) {

	          posToChange = pos2;
	        }

	        if (posToChange) {

	          if (!this._data.vertical) {
	            posToChange.deltaPosition('x', deltaX, this.getXAxis());
	          }
	        }

	        if (this.moving) {

	          // If the pos2 is defined by a delta, no need to move them
	          if (pos.x) {
	            pos.deltaPosition('x', deltaX, this.getXAxis());
	          }

	          // If the pos2 is defined by a delta, no need to move them
	          if (pos2.x) {
	            pos2.deltaPosition('x', deltaX, this.getXAxis());
	          }
	        }

	        if (this.rectEvent) {
	          this.setEventReceptacle();
	        }

	        this.redraw();
	        this.changed();

	        return true;
	      }
	    }, {
	      key: 'ratio',
	      set: function set(r) {
	        this._ratio = r;
	      },
	      get: function get() {
	        return this._ratio;
	      }
	    }, {
	      key: 'sum',
	      get: function get() {
	        return this._sum;
	      }
	    }, {
	      key: 'sumVal',
	      get: function get() {
	        return this._sumVal;
	      }
	    }]);

	    return ShapeNMRIntegral;
	  }(_graphShape2.default);

	  exports.default = ShapeNMRIntegral;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 364 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(143)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShapeRect) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShapeRect2 = _interopRequireDefault(_graphShapeRect);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapePeakIntegration2D = function (_ShapeRect) {
	    _inherits(ShapePeakIntegration2D, _ShapeRect);

	    function ShapePeakIntegration2D(graph, options) {
	      _classCallCheck(this, ShapePeakIntegration2D);

	      var _this = _possibleConstructorReturn(this, (ShapePeakIntegration2D.__proto__ || Object.getPrototypeOf(ShapePeakIntegration2D)).call(this, graph, options));

	      _this.nbHandles = 4;
	      return _this;
	    }

	    _createClass(ShapePeakIntegration2D, [{
	      key: 'createDom',
	      value: function createDom() {

	        this._dom = document.createElementNS(this.graph.ns, 'rect');
	        this._dom.element = this;

	        this.createHandles(this.nbHandles, 'rect', {
	          transform: 'translate(-3 -3)',
	          width: 6,
	          height: 6,
	          stroke: 'black',
	          fill: 'white',
	          cursor: 'nwse-resize'
	        });
	      }
	    }, {
	      key: 'redrawImpl',
	      value: function redrawImpl() {

	        this.setPosition();
	        this.setHandles();
	        this.setBindableToDom(this._dom);
	      }
	    }]);

	    return ShapePeakIntegration2D;
	  }(_graphShapeRect2.default);

	  exports.default = ShapePeakIntegration2D;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 365 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShape) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeCross = function (_Shape) {
	    _inherits(ShapeCross, _Shape);

	    function ShapeCross(graph, options) {
	      _classCallCheck(this, ShapeCross);

	      var _this = _possibleConstructorReturn(this, (ShapeCross.__proto__ || Object.getPrototypeOf(ShapeCross)).call(this, graph, options));

	      _this.nbHandles = 1;
	      return _this;
	    }

	    /**
	     * Width of the cross, also available from the constructor
	     * @type {Number} width
	     */


	    _createClass(ShapeCross, [{
	      key: 'createDom',
	      value: function createDom() {

	        this._dom = document.createElementNS(this.graph.ns, 'path');
	        this._dom.setAttribute('d', 'M -' + this.width / 2 + ' 0 h ' + this.width + ' m -' + this.width / 2 + ' -' + this.width / 2 + ' v ' + this.width + '');
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {

	        this._createHandles(this.nbHandles, 'rect', {
	          transform: 'translate(-3 -3)',
	          width: 6,
	          height: 6,
	          stroke: 'black',
	          fill: 'white',
	          cursor: 'nwse-resize'
	        });
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        var position = this.calculatePosition(0);
	        if (!position || !position.x || !position.y) {
	          return;
	        }

	        this.setDom('transform', 'translate( ' + position.x + ', ' + position.y + ')');

	        this.currentPos1x = position.x;
	        this.currentPos1y = position.y;

	        return true;
	      }
	    }, {
	      key: 'redrawImpl',
	      value: function redrawImpl() {

	        this.setHandles();
	      }
	    }, {
	      key: 'handleCreateImpl',
	      value: function handleCreateImpl() {}
	    }, {
	      key: 'handleMouseDownImpl',
	      value: function handleMouseDownImpl(e) {

	        this.moving = true;

	        return true;
	      }
	    }, {
	      key: 'handleMouseUpImpl',
	      value: function handleMouseUpImpl() {

	        this.triggerChange();
	        return true;
	      }
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

	        if (this.isLocked()) {
	          return;
	        }

	        var pos = this.getFromData('pos');

	        if (this.moving) {

	          pos.x = this.graph.deltaPosition(pos.x, deltaX, this.getXAxis());
	          pos.y = this.graph.deltaPosition(pos.y, deltaY, this.getYAxis());
	        }

	        this.redrawImpl();

	        return true;
	      }
	    }, {
	      key: 'setHandles',
	      value: function setHandles() {

	        if (!this.areHandlesInDom()) {
	          return;
	        }

	        if (isNaN(this.currentPos1x)) {
	          return;
	        }

	        this.handles[1].setAttribute('x', this.currentPos1x);
	        this.handles[1].setAttribute('y', this.currentPos1y);
	      }
	    }, {
	      key: 'selectStyle',
	      value: function selectStyle() {
	        this.setDom('stroke', 'red');
	        this.setDom('stroke-width', '2');
	      }
	    }, {
	      key: 'width',
	      get: function get() {
	        return this.options.width || 10;
	      },
	      set: function set(l) {
	        this.options.width = l;
	      }
	    }]);

	    return ShapeCross;
	  }(_graphShape2.default);

	  exports.default = ShapeCross;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 366 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(102)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphShapeLine) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShapeLine2 = _interopRequireDefault(_graphShapeLine);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapePeakBoundaries = function (_ShapeLine) {
	    _inherits(ShapePeakBoundaries, _ShapeLine);

	    function ShapePeakBoundaries(graph) {
	      _classCallCheck(this, ShapePeakBoundaries);

	      var _this = _possibleConstructorReturn(this, (ShapePeakBoundaries.__proto__ || Object.getPrototypeOf(ShapePeakBoundaries)).call(this, graph));

	      _this.lineHeight = 6;
	      return _this;
	    }

	    _createClass(ShapePeakBoundaries, [{
	      key: 'createDom',
	      value: function createDom() {

	        this._dom = document.createElementNS(this.graph.ns, 'line');
	        this.line1 = document.createElementNS(this.graph.ns, 'line');
	        this.line2 = document.createElementNS(this.graph.ns, 'line');
	        this.line3 = document.createElementNS(this.graph.ns, 'line');

	        this.rectBoundary = document.createElementNS(this.graph.ns, 'path');

	        this.rectBoundary.setAttribute('fill', 'transparent');
	        this.rectBoundary.setAttribute('stroke', 'none');
	        this.rectBoundary.setAttribute('pointer-events', 'fill');

	        this.rectBoundary.jsGraphIsShape = true;

	        this.group.appendChild(this.rectBoundary);
	        this.group.appendChild(this.line1);
	        this.group.appendChild(this.line2);
	        this.group.appendChild(this.line3);
	        this._dom.element = this;
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {
	        this._createHandles(3, 'rect', {
	          transform: 'translate(-3 -3)',
	          width: 6,
	          height: 6,
	          stroke: 'black',
	          fill: 'white',
	          cursor: 'nwse-resize'
	        });
	      }
	    }, {
	      key: 'redrawImpl',
	      value: function redrawImpl() {

	        this.line1.setAttribute('stroke', this.getStrokeColor());
	        this.line2.setAttribute('stroke', this.getStrokeColor());
	        this.line3.setAttribute('stroke', this.getStrokeColor());

	        this.line1.setAttribute('stroke-width', this.getStrokeWidth());
	        this.line2.setAttribute('stroke-width', this.getStrokeWidth());
	        this.line3.setAttribute('stroke-width', this.getStrokeWidth());

	        this.setHandles();
	        this.redrawLines();
	      }
	    }, {
	      key: 'redrawLines',
	      value: function redrawLines() {

	        var posLeft = this.computePosition(0);
	        var posRight = this.computePosition(1);
	        var posCenter = this.computePosition(2);

	        if (posLeft.x && posRight.x && posCenter.x && this.posYPx) {

	          var height = this.lineHeight;
	          this.rectBoundary.setAttribute('d', 'M ' + posLeft.x + ' ' + (this.posYPx - height) + ' v ' + 2 * height + ' H ' + posRight.x + ' v ' + -2 * height + 'z');
	          this.line1.setAttribute('x1', posLeft.x);
	          this.line1.setAttribute('x2', posLeft.x);

	          this.line2.setAttribute('x1', posRight.x);
	          this.line2.setAttribute('x2', posRight.x);

	          this.line3.setAttribute('x1', posCenter.x);
	          this.line3.setAttribute('x2', posCenter.x);

	          this._dom.setAttribute('x1', posLeft.x);
	          this._dom.setAttribute('x2', posRight.x);

	          this.redrawY(height);
	        }

	        return this;
	      }
	    }, {
	      key: 'redrawY',
	      value: function redrawY() {

	        if (!this.posYPx) {
	          return this;
	        }

	        var height = this.lineHeight;

	        this.line1.setAttribute('y1', this.posYPx - height);
	        this.line1.setAttribute('y2', this.posYPx + height);

	        this.line2.setAttribute('y1', this.posYPx - height);
	        this.line2.setAttribute('y2', this.posYPx + height);

	        this.line3.setAttribute('y1', this.posYPx - height);
	        this.line3.setAttribute('y2', this.posYPx + height);

	        this._dom.setAttribute('y1', this.posYPx);
	        this._dom.setAttribute('y2', this.posYPx);

	        return this;
	      }
	    }, {
	      key: 'setHandles',
	      value: function setHandles() {

	        if (!this.posYPx) {
	          return;
	        }

	        var posLeft = this.computePosition(0);
	        var posRight = this.computePosition(1);
	        var posCenter = this.computePosition(2);

	        if (posLeft.x && posRight.x && posCenter.x) {

	          this.handles[1].setAttribute('x', posLeft.x);
	          this.handles[1].setAttribute('y', this.posYPx);

	          this.handles[2].setAttribute('x', posRight.x);
	          this.handles[2].setAttribute('y', this.posYPx);

	          this.handles[3].setAttribute('x', posCenter.x);
	          this.handles[3].setAttribute('y', this.posYPx);
	        }
	      }
	    }, {
	      key: 'setY',
	      value: function setY(y) {
	        this.posYPx = y;
	        return this;
	      }
	    }, {
	      key: 'setLineHeight',
	      value: function setLineHeight(height) {
	        this.lineHeihgt = height;
	      }
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl(e, deltaX, deltaY) {

	        if (this.isLocked()) {
	          return;
	        }

	        var posLeft = this.getPosition(0);
	        var posRight = this.getPosition(1);
	        var posCenter = this.getPosition(2);

	        switch (this.handleSelected) {

	          case 1:
	            // left
	            posLeft.deltaPosition('x', deltaX, this.getXAxis());

	            if (Math.abs(posCenter.x - posRight.x) > Math.abs(posRight.x - posLeft.x) || Math.abs(posCenter.x - posLeft.x) > Math.abs(posRight.x - posLeft.x)) {
	              posCenter.x = posLeft.x + (posRight.x - posLeft.x) * 0.1;
	            }
	            break;

	          case 2:
	            // left

	            posRight.deltaPosition('x', deltaX, this.getXAxis());

	            if (Math.abs(posCenter.x - posRight.x) > Math.abs(posRight.x - posLeft.x) || Math.abs(posCenter.x - posLeft.x) > Math.abs(posRight.x - posLeft.x)) {
	              posCenter.x = posRight.x + (posLeft.x - posRight.x) * 0.1;
	            }

	            break;

	          case 3:
	            // left

	            posCenter.deltaPosition('x', deltaX, this.getXAxis());

	            if (Math.abs(posCenter.x - posRight.x) > Math.abs(posRight.x - posLeft.x) || Math.abs(posCenter.x - posLeft.x) > Math.abs(posRight.x - posLeft.x)) {
	              return;
	            }

	            break;

	        }

	        this.setLabelPosition({
	          y: this.getLabelPosition(0).y,
	          x: posCenter.x
	        });

	        this.updateLabels();
	        this.redrawLines();
	        this.setHandles();
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        this.redrawLines();
	        return true;
	      }
	    }]);

	    return ShapePeakBoundaries;
	  }(_graphShapeLine2.default);

	  exports.default = ShapePeakBoundaries;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 367 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphUtil, _graphShape) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeHTML = function (_GraphShape) {
	    _inherits(ShapeHTML, _GraphShape);

	    function ShapeHTML(graph, options) {
	      _classCallCheck(this, ShapeHTML);

	      return _possibleConstructorReturn(this, (ShapeHTML.__proto__ || Object.getPrototypeOf(ShapeHTML)).call(this, graph, options));
	    }

	    /**
	     * Creates the DOM
	     * @private
	     * @return {Shape} The current shape
	     */


	    _createClass(ShapeHTML, [{
	      key: 'createDom',
	      value: function createDom() {

	        this._dom = document.createElement('div');
	        //  this._dom.setAttribute( "requiredExtensions", "http://www.w3.org/1999/xhtml" );

	        this._dom.setAttribute('style', 'position: absolute');
	        var div = document.createElement('div');
	        this._dom.appendChild(div);
	        this.div = div;
	      }
	    }, {
	      key: 'createHandles',
	      value: function createHandles() {}
	    }, {
	      key: 'setHeight',
	      value: function setHeight(height) {
	        this.setProp('height', height);
	      }
	    }, {
	      key: 'setWidth',
	      value: function setWidth(width) {
	        this.setProp('width', width);
	      }
	    }, {
	      key: 'setContent',
	      value: function setContent(content) {
	        this.setProp('content', content);
	      }
	    }, {
	      key: 'setRenderer',
	      value: function setRenderer(method) {
	        this._renderer = method;
	      }
	    }, {
	      key: 'redraw',
	      value: function redraw() {

	        if (this._renderer) {
	          this._renderer(this.div);
	        } else {
	          this.div.innerHTML = this.getProp('content');
	        }

	        _get(ShapeHTML.prototype.__proto__ || Object.getPrototypeOf(ShapeHTML.prototype), 'redraw', this).apply(this, arguments);
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        var position = this.calculatePosition(0);

	        if (!position || !(0, _graphUtil.isNumeric)(position.x) || !(0, _graphUtil.isNumeric)(position.y)) {
	          return;
	        }
	        this._dom.style.left = position.x + 'px';
	        this._dom.style.top = position.y + 'px';

	        this.currentPosX = position.x;
	        this.currentPosY = position.y;

	        return true;
	      }
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {

	        return true;
	      }
	    }, {
	      key: 'setHandles',
	      value: function setHandles() {}
	    }, {
	      key: 'isHTML',
	      value: function isHTML() {
	        return true;
	      }
	    }]);

	    return ShapeHTML;
	  }(_graphShape2.default);

	  exports.default = ShapeHTML;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 368 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphPlugin) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PluginDrag = function (_Plugin) {
	    _inherits(PluginDrag, _Plugin);

	    function PluginDrag() {
	      _classCallCheck(this, PluginDrag);

	      return _possibleConstructorReturn(this, (PluginDrag.__proto__ || Object.getPrototypeOf(PluginDrag)).apply(this, arguments));
	    }

	    _createClass(PluginDrag, [{
	      key: 'init',
	      value: function init(graph) {

	        this.graph = graph;
	        this.time = null;
	        this.totaltime = 2000;
	      }
	    }, {
	      key: 'onMouseDown',
	      value: function onMouseDown(graph, x, y, e, target) {
	        this._draggingX = x;
	        this._draggingY = y;

	        this._lastDraggingX = this._draggingX;
	        this._lastDraggingY = this._draggingY;

	        this.stopAnimation = true;

	        this.moved = false;

	        return true;
	      }
	    }, {
	      key: 'onMouseMove',
	      value: function onMouseMove(graph, x, y, e, target) {

	        var deltaX = x - this._draggingX;
	        var deltaY = y - this._draggingY;

	        if (this.options.dragX) {
	          graph._applyToAxes(function (axis) {
	            axis.setCurrentMin(axis.getVal(axis.getMinPx() - deltaX));
	            axis.setCurrentMax(axis.getVal(axis.getMaxPx() - deltaX));
	          }, false, true, false);
	        }

	        if (this.options.dragY) {

	          graph._applyToAxes(function (axis) {
	            axis.setCurrentMin(axis.getVal(axis.getMinPx() - deltaY));
	            axis.setCurrentMax(axis.getVal(axis.getMaxPx() - deltaY));
	          }, false, false, true);
	        }

	        this._lastDraggingX = this._draggingX;
	        this._lastDraggingY = this._draggingY;

	        this._draggingX = x;
	        this._draggingY = y;

	        this.moved = true;

	        this.time = Date.now();

	        this.emit('dragging');

	        graph.draw(true);
	      }
	    }, {
	      key: 'onMouseUp',
	      value: function onMouseUp(graph, x, y, e, target) {

	        var dt = Date.now() - this.time;

	        if (x == this._lastDraggingX || y == this._lastDraggingY) {

	          if (this.moved) {
	            this.emit('dragged');
	          }

	          return;
	        }

	        this.speedX = (x - this._lastDraggingX) / dt;
	        this.speedY = (y - this._lastDraggingY) / dt;

	        if (isNaN(this.speedX) || isNaN(this.speedY)) {
	          this.emit('dragged');
	          return;
	        }

	        graph._applyToAxes(function (axis) {
	          axis._pluginDragMin = axis.getCurrentMin();
	          axis._pluginDragMax = axis.getCurrentMax();
	        }, false, true, true);

	        this.stopAnimation = false;
	        this.accelerationX = -this.speedX / this.totaltime;
	        this.accelerationY = -this.speedY / this.totaltime;

	        if (this.options.persistanceX || this.options.persistanceY) {

	          this._persistanceMove(graph);
	        } else {

	          this.emit('dragged');
	        }
	      }
	    }, {
	      key: '_persistanceMove',
	      value: function _persistanceMove(graph) {

	        var self = this;

	        if (self.stopAnimation) {
	          self.emit('dragged');
	          return;
	        }

	        window.requestAnimationFrame(function () {

	          var dt = Date.now() - self.time;
	          var dx = (0.5 * self.accelerationX * dt + self.speedX) * dt;
	          var dy = (0.5 * self.accelerationY * dt + self.speedY) * dt;

	          if (self.options.persistanceX) {

	            graph._applyToAxes(function (axis) {

	              axis.setCurrentMin(-axis.getRelVal(dx) + axis._pluginDragMin);
	              axis.setCurrentMax(-axis.getRelVal(dx) + axis._pluginDragMax);

	              axis.cacheCurrentMin();
	              axis.cacheCurrentMax();
	              axis.cacheInterval();
	            }, false, true, false);
	          }

	          if (self.options.persistanceY) {

	            graph._applyToAxes(function (axis) {

	              axis.setCurrentMin(-axis.getRelVal(dy) + axis._pluginDragMin);
	              axis.setCurrentMax(-axis.getRelVal(dy) + axis._pluginDragMax);

	              axis.cacheCurrentMin();
	              axis.cacheCurrentMax();
	              axis.cacheInterval();
	            }, false, false, true);
	          }

	          graph.draw();

	          if (dt < self.totaltime) {
	            self.emit('dragging');
	            self._persistanceMove(graph);
	          } else {
	            self.emit('dragged');
	          }
	        });
	      }
	    }], [{
	      key: 'default',
	      value: function _default() {
	        return {

	          dragX: true,
	          dragY: true,
	          persistanceX: false,
	          persistanceY: false

	        };
	      }
	    }]);

	    return PluginDrag;
	  }(_graphPlugin2.default);

	  exports.default = PluginDrag;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 369 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(29), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphPlugin, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PluginShape = function (_Plugin) {
	    _inherits(PluginShape, _Plugin);

	    function PluginShape() {
	      _classCallCheck(this, PluginShape);

	      return _possibleConstructorReturn(this, (PluginShape.__proto__ || Object.getPrototypeOf(PluginShape)).apply(this, arguments));
	    }

	    _createClass(PluginShape, [{
	      key: 'init',
	      value: function init(graph, options) {

	        _get(PluginShape.prototype.__proto__ || Object.getPrototypeOf(PluginShape.prototype), 'init', this).call(this, graph, options);
	        this.shapeType = options.type;
	      }
	    }, {
	      key: 'setShape',
	      value: function setShape(shapeType) {
	        this.shapeInfo.shapeType = shapeType;
	      }
	    }, {
	      key: 'onMouseDown',
	      value: function onMouseDown(graph, x, y, e, target) {
	        var _this2 = this;

	        if (!this.shapeType && !this.options.url) {
	          return;
	        }

	        var self = this;

	        var xVal, yVal;

	        this.count = this.count || 0;

	        x -= graph.getPaddingLeft();
	        y -= graph.getPaddingTop();

	        xVal = graph.getXAxis().getVal(x);
	        yVal = graph.getYAxis().getVal(y);

	        var shapeInfo = {

	          position: [{
	            x: xVal,
	            y: yVal
	          }, {
	            x: xVal,
	            y: yVal
	          }],

	          onChange: function onChange(newData) {
	            graph.triggerEvent('onAnnotationChange', newData);
	          },

	          locked: false,
	          selectable: true,
	          resizable: true,
	          movable: true
	        };

	        var shapeProperties = this.options.properties;

	        util.extend(true, shapeInfo, this.options);

	        this.emit('beforeNewShape', e, shapeInfo);

	        if (this.graph.prevent(false)) {
	          return;
	        }

	        var shape = graph.newShape(shapeInfo.type, shapeInfo, false, shapeProperties);

	        this.emit('createdShape', e, shape);

	        if (shape) {
	          self.currentShape = shape;
	          self.currentShapeEvent = e;
	        }

	        graph.once('mouseUp', function () {
	          console.log(_this2.currentShape);
	          if (!_this2.currentShape) {
	            // The mouse has moved
	            self.emit('newShape', e, shape);
	          }
	        });
	      }
	    }, {
	      key: 'onMouseMove',
	      value: function onMouseMove(graph, x, y, e) {

	        if (this.currentShape) {
	          console.log('mv');
	          this.count++;

	          var shape = this.currentShape;

	          this.currentShape = false;

	          if (graph.selectedSerie && !shape.serie) {
	            shape.setSerie(graph.selectedSerie);
	          }

	          shape.resizing = true;

	          if (shape.options && shape.options.onCreate) {
	            shape.options.onCreate.call(shape);
	          }

	          shape.draw();
	          graph.selectShape(shape);
	          shape.handleMouseDown(this.currentShapeEvent, true);
	          shape.handleSelected = this.options.handleSelected || 1;
	          shape.handleMouseMove(e, true);
	        }
	      }
	    }, {
	      key: 'onMouseUp',
	      value: function onMouseUp() {

	        if (this.currentShape) {
	          // No need to kill it as it hasn't been actually put in the dom right now

	          // Norman 30 July 2017: Yes but it's added in the jsGraph stack. We need to remove it. See #176
	          // From now on killing the shape will result in removing it from the stack as well.
	          this.currentShape.kill();
	          this.currentShape = false;
	        }
	      }
	    }], [{
	      key: 'default',
	      value: function _default() {
	        return {};
	      }
	    }]);

	    return PluginShape;
	  }(_graphPlugin2.default);

	  exports.default = PluginShape;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 370 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphUtil, _graphPlugin) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PluginSelectScatter = function (_Plugin) {
	    _inherits(PluginSelectScatter, _Plugin);

	    function PluginSelectScatter() {
	      _classCallCheck(this, PluginSelectScatter);

	      return _possibleConstructorReturn(this, (PluginSelectScatter.__proto__ || Object.getPrototypeOf(PluginSelectScatter)).apply(this, arguments));
	    }

	    _createClass(PluginSelectScatter, [{
	      key: 'init',
	      value: function init(graph, options) {

	        this._path = document.createElementNS(graph.ns, 'path');

	        util.setAttributeTo(this._path, {
	          'display': 'none',
	          'fill': 'rgba(0,0,0,0.1)',
	          'stroke': 'rgba(0,0,0,1)',
	          'shape-rendering': 'crispEdges',
	          'x': 0,
	          'y': 0,
	          'height': 0,
	          'width': 0,
	          'd': ''
	        });

	        this.graph = graph;

	        graph.dom.appendChild(this._path);
	      }
	    }, {
	      key: 'setSerie',
	      value: function setSerie(serie) {
	        this.serie = serie;
	      }
	    }, {
	      key: 'onMouseDown',
	      value: function onMouseDown(graph, x, y, e, mute) {

	        if (!this.serie) {
	          return;
	        }

	        this.path = 'M ' + x + ' ' + y + ' ';
	        this.currentX = x;
	        this.currentY = y;

	        this.xs = [this.serie.getXAxis().getVal(x - graph.getPaddingLeft())];
	        this.ys = [this.serie.getYAxis().getVal(y - graph.getPaddingTop())];
	        this._path.setAttribute('d', '');
	        this._path.setAttribute('display', 'block');
	      }
	    }, {
	      key: 'onMouseMove',
	      value: function onMouseMove(graph, x, y, e, mute) {

	        if (Math.pow(x - this.currentX, 2) + Math.pow(y - this.currentY, 2) > 25) {

	          this.path += ' L ' + x + ' ' + y + ' ';
	          this.currentX = x;
	          this.currentY = y;

	          this.xs.push(this.serie.getXAxis().getVal(x - graph.getPaddingLeft()));
	          this.ys.push(this.serie.getYAxis().getVal(y - graph.getPaddingTop()));

	          this._path.setAttribute('d', this.path + ' z');

	          this.findPoints();
	        }
	      }
	    }, {
	      key: 'findPoints',
	      value: function findPoints() {

	        var data = this.serie.waveform;
	        var selected = [];
	        var counter = 0,
	            j2;
	        for (var i = 0, l = data.getLength(); i < l; i += 1) {

	          counter = 0;
	          for (var j = 0, k = this.xs.length; j < k; j += 1) {

	            if (j == k - 1) {
	              j2 = 0;
	            } else {
	              j2 = j + 1;
	            }

	            if (this.ys[j] < data.getY(i) && this.ys[j2] > data.getY(i) || this.ys[j] > data.getY(i) && this.ys[j2] < data.getY(i)) {

	              if (data.getX(i) > (data.getY(i) - this.ys[j]) / (this.ys[j2] - this.ys[j]) * (this.xs[j2] - this.xs[j]) + this.xs[j]) {
	                counter++;
	              }
	            }
	          }

	          if (counter % 2 == 1) {
	            selected.push(i);
	            this.serie.selectPoint(i, true, 'selected');
	          } else {
	            this.serie.unselectPoint(i);
	          }
	        }

	        this.selected = selected;
	        this.emit('selectionProcess', selected);
	      }
	    }, {
	      key: 'onMouseUp',
	      value: function onMouseUp(graph, x, y, e) {
	        this._path.setAttribute('display', 'none');
	        this.emit('selectionEnd', this.selected);
	      }
	    }], [{
	      key: 'default',
	      value: function _default() {
	        return {};
	      }
	    }]);

	    return PluginSelectScatter;
	  }(_graphPlugin2.default);

	  exports.default = PluginSelectScatter;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 371 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphUtil, _graphPlugin) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PluginZoom = function (_Plugin) {
	    _inherits(PluginZoom, _Plugin);

	    function PluginZoom() {
	      _classCallCheck(this, PluginZoom);

	      return _possibleConstructorReturn(this, (PluginZoom.__proto__ || Object.getPrototypeOf(PluginZoom)).apply(this, arguments));
	    }

	    _createClass(PluginZoom, [{
	      key: 'init',
	      value: function init(graph, options) {

	        this._zoomingGroup = document.createElementNS(graph.ns, 'g');
	        this._zoomingSquare = document.createElementNS(graph.ns, 'rect');
	        this._zoomingSquare.setAttribute('display', 'none');

	        util.setAttributeTo(this._zoomingSquare, {
	          'display': 'none',
	          'fill': 'rgba(171,12,12,0.2)',
	          'stroke': 'rgba(171,12,12,1)',
	          'shape-rendering': 'crispEdges',
	          'x': 0,
	          'y': 0,
	          'height': 0,
	          'width': 0,
	          'pointer-events': 'none'
	        });

	        this.graph = graph;
	        graph.groupEvent.appendChild(this._zoomingGroup);
	        this._zoomingGroup.appendChild(this._zoomingSquare);
	      }
	    }, {
	      key: 'onMouseDown',
	      value: function onMouseDown(graph, x, y, e, mute) {

	        var zoomMode = this.options.zoomMode;

	        if (!zoomMode) {
	          return;
	        }

	        this._zoomingMode = zoomMode;

	        if (x === undefined) {
	          this._backedUpZoomMode = this._zoomingMode;
	          this._zoomingMode = 'y';
	          x = 0;
	        }

	        if (y === undefined) {
	          this._backedUpZoomMode = this._zoomingMode;
	          this._zoomingMode = 'x';
	          y = 0;
	        }

	        this._zoomingXStart = x;
	        this._zoomingYStart = y;
	        this.x1 = x - graph.getPaddingLeft();
	        this.y1 = y - graph.getPaddingTop();

	        this._zoomingSquare.setAttribute('width', 0);
	        this._zoomingSquare.setAttribute('height', 0);
	        this._zoomingSquare.setAttribute('display', 'block');

	        switch (this._zoomingMode) {

	          case 'x':
	            this._zoomingSquare.setAttribute('y', graph.options.paddingTop);
	            this._zoomingSquare.setAttribute('height', graph.getDrawingHeight() - graph.shift.bottom);
	            break;

	          case 'y':
	            this._zoomingSquare.setAttribute('x', graph.options.paddingLeft /* + this.shift[1]*/);
	            this._zoomingSquare.setAttribute('width', graph.getDrawingWidth() /* - this.shift[1] - this.shift[2]*/);
	            break;

	          case 'forceY2':

	            this.y2 = graph.getYAxis().getPx(this.options.forcedY) + graph.options.paddingTop;

	            break;

	        }

	        if (this.options.onZoomStart && !mute) {
	          this.options.onZoomStart(graph, x, y, e, mute);
	        }
	      }
	    }, {
	      key: 'onMouseMove',
	      value: function onMouseMove(graph, x, y, e, mute) {

	        //	this._zoomingSquare.setAttribute('display', 'none');

	        //	this._zoomingSquare.setAttribute('transform', 'translate(' + Math.random() + ', ' + Math.random() + ') scale(10, 10)');
	        switch (this._zoomingMode) {

	          case 'xy':
	            this._zoomingSquare.setAttribute('x', Math.min(this._zoomingXStart, x));
	            this._zoomingSquare.setAttribute('y', Math.min(this._zoomingYStart, y));
	            this._zoomingSquare.setAttribute('width', Math.abs(this._zoomingXStart - x));
	            this._zoomingSquare.setAttribute('height', Math.abs(this._zoomingYStart - y));

	            break;

	          case 'forceY2':
	            this._zoomingSquare.setAttribute('y', Math.min(this._zoomingYStart, this.y2));
	            this._zoomingSquare.setAttribute('height', Math.abs(this._zoomingYStart - this.y2));
	            this._zoomingSquare.setAttribute('x', Math.min(this._zoomingXStart, x));
	            this._zoomingSquare.setAttribute('width', Math.abs(this._zoomingXStart - x));

	            break;

	          case 'x':
	            this._zoomingSquare.setAttribute('x', Math.min(this._zoomingXStart, x));
	            this._zoomingSquare.setAttribute('width', Math.abs(this._zoomingXStart - x));

	            break;

	          case 'y':
	            this._zoomingSquare.setAttribute('y', Math.min(this._zoomingYStart, y));
	            this._zoomingSquare.setAttribute('height', Math.abs(this._zoomingYStart - y));
	            break;

	        }

	        if (this.options.onZoomMove && !mute) {

	          this.options.onZoomMove(graph, x, y, e, mute);
	        }
	        //		this._zoomingSquare.setAttribute('display', 'block');
	      }
	    }, {
	      key: 'onMouseUp',
	      value: function onMouseUp(graph, x, y, e, mute) {
	        var self = this;
	        this.removeZone();

	        var _x = x - graph.options.paddingLeft;
	        var _y = y - graph.options.paddingTop;

	        this.emit('beforeZoom', {
	          graph: graph,
	          x: x,
	          y: y,
	          e: e,
	          mute: mute
	        });

	        if (graph.prevent(false)) {

	          // This doesn't work !
	          //graph.prevent( true ); // Cancel future click event
	          return;
	        }

	        if (x - this._zoomingXStart == 0 && this._zoomingMode != 'y' || y - this._zoomingYStart == 0 && this._zoomingMode != 'x') {
	          return;
	        }

	        if (this.options.transition || this.options.smooth) {

	          var modeX = false,
	              modeY = false;

	          if (this._zoomingMode == 'x' || this._zoomingMode == 'xy' || this._zoomingMode == 'forceY2') {

	            this.fullX = false;
	            this.toAxes(function (axis) {

	              axis._pluginZoomMin = axis.getCurrentMin();
	              axis._pluginZoomMax = axis.getCurrentMax();

	              axis._pluginZoomMinFinal = Math.min(axis.getVal(_x), axis.getVal(self.x1));
	              axis._pluginZoomMaxFinal = Math.max(axis.getVal(_x), axis.getVal(self.x1));
	            }, false, true, false);

	            modeX = true;
	          }

	          if (this._zoomingMode == 'y' || this._zoomingMode == 'xy') {

	            this.fullY = false;
	            this.toAxes(function (axis) {

	              axis._pluginZoomMin = axis.getCurrentMin();
	              axis._pluginZoomMax = axis.getCurrentMax();

	              axis._pluginZoomMinFinal = Math.min(axis.getVal(_y), axis.getVal(self.y1));
	              axis._pluginZoomMaxFinal = Math.max(axis.getVal(_y), axis.getVal(self.y1));
	            }, false, false, true);

	            modeY = true;
	          }

	          if (this._zoomingMode == 'forceY2') {

	            this.fullY = false;
	            this.toAxes(function (axis) {

	              axis._pluginZoomMin = axis.getCurrentMin();
	              axis._pluginZoomMax = axis.getCurrentMax();

	              axis._pluginZoomMinFinal = Math.min(axis.getVal(self.y2), axis.getVal(self.y1));
	              axis._pluginZoomMaxFinal = Math.max(axis.getVal(self.y2), axis.getVal(self.y1));
	            }, false, false, true);

	            modeY = true;
	          }

	          this.transition(modeX, modeY, 'zoomEnd');
	        } else {

	          switch (this._zoomingMode) {
	            case 'x':
	              this.fullX = false;
	              this.toAxes('_doZoom', [_x, this.x1], true, false);
	              break;
	            case 'y':
	              this.fullY = false;
	              this.toAxes('_doZoom', [_y, this.y1], false, true);
	              break;
	            case 'xy':
	              this.fullX = false;
	              this.fullY = false;
	              this.toAxes('_doZoom', [_x, this.x1], true, false);
	              this.toAxes('_doZoom', [_y, this.y1], false, true);
	              break;

	            case 'forceY2':

	              this.fullX = false;
	              this.fullY = false;

	              this.toAxes('_doZoom', [_x, this.x1], true, false);
	              this.toAxes('_doZoom', [this.y1, this.y2], false, true);

	              break;
	          }

	          //  graph.prevent( true ); // WHat are you doing ??
	          graph.draw();

	          if (this._backedUpZoomMode) {
	            this._zoomingMode = this._backedUpZoomMode;
	          }

	          this.emit('zoomed');

	          graph.pluginYieldActiveState();
	        }
	      }
	    }, {
	      key: 'removeZone',
	      value: function removeZone() {

	        this._zoomingSquare.setAttribute('display', 'none');
	      }
	    }, {
	      key: 'onMouseWheel',
	      value: function onMouseWheel(delta, e, coordX, coordY, options) {

	        if (!options) {
	          options = {};
	        }

	        if (!options.baseline) {
	          options.baseline = 0;
	        }

	        var baseline = options.baseline;

	        if (options.baseline == 'mousePosition') {
	          baseline = this.graph.getYAxis().getVal(coordY);
	          console.log(baseline);
	        }

	        /*var serie;
	        if ( ( serie = this.graph.getSelectedSerie() ) ) {
	           if ( serie.getYAxis().handleMouseWheel( delta, e ) ) {
	            return;
	          }
	        }*/

	        var doX = options.direction == 'x';
	        var doY = !(options.direction !== 'y');

	        this.toAxes('handleMouseWheel', [delta, e, baseline], doX, doY);

	        this.graph.drawSeries();
	      }
	    }, {
	      key: 'onDblClick',
	      value: function onDblClick(x, y, e, pref, mute) {

	        var graph = this.graph;
	        this.emit('beforeDblClick', {
	          graph: graph,
	          x: x,
	          y: y,
	          pref: pref,
	          e: e,
	          mute: mute
	        });

	        if (graph.prevent(false)) {
	          return;
	        }

	        if (this.options.transition || this.options.smooth) {

	          var modeX = false,
	              modeY = false;

	          if (pref.mode == 'xtotal' || pref.mode == 'total') {

	            this.toAxes(function (axis) {
	              axis._pluginZoomMin = axis.getCurrentMin();
	              axis._pluginZoomMax = axis.getCurrentMax();

	              axis._pluginZoomMinFinal = axis.getMinValue() - axis.options.axisDataSpacing.min * axis.getInterval();
	              axis._pluginZoomMaxFinal = axis.getMaxValue() + axis.options.axisDataSpacing.max * axis.getInterval();
	            }, false, true, false);

	            modeX = true;
	          }

	          if (pref.mode == 'ytotal' || pref.mode == 'total') {

	            this.toAxes(function (axis) {

	              axis._pluginZoomMin = axis.getCurrentMin();
	              axis._pluginZoomMax = axis.getCurrentMax();

	              axis._pluginZoomMinFinal = axis.getMinValue() - axis.options.axisDataSpacing.min * axis.getInterval();
	              axis._pluginZoomMaxFinal = axis.getMaxValue() + axis.options.axisDataSpacing.max * axis.getInterval();
	            }, false, false, true);

	            modeY = true;
	          }

	          var _x2 = void 0,
	              _y2 = void 0;

	          if (pref.mode == 'gradualX' || pref.mode == 'gradualY' || pref.mode == 'gradual' || pref.mode == 'gradualXY') {

	            _x2 = false, _y2 = false;

	            if (pref.mode == 'gradualX' || pref.mode == 'gradual' || pref.mode == 'gradualXY') {
	              _x2 = true;
	              modeX = true;
	            }

	            if (pref.mode == 'gradualY' || pref.mode == 'gradual' || pref.mode == 'gradualXY') {
	              _y2 = true;
	              modeY = true;
	            }

	            this.toAxes(function (axis) {

	              axis._pluginZoomMin = axis.getCurrentMin();
	              axis._pluginZoomMax = axis.getCurrentMax();

	              axis._pluginZoomMinFinal = axis.getCurrentMin() - (axis.getCurrentMax() - axis.getCurrentMin());
	              axis._pluginZoomMaxFinal = axis.getCurrentMax() + (axis.getCurrentMax() - axis.getCurrentMin());
	            }, false, _x2, _y2);
	          }

	          this.transition(modeX, modeY, 'dblClick');
	          return;
	        }

	        var xAxis = this.graph.getXAxis(),
	            yAxis = this.graph.getYAxis();

	        if (pref.mode == 'xtotal') {

	          this.toAxes('setMinMaxToFitSeries', null, true, false);
	          this.fullX = true;
	          this.fullY = false;
	        } else if (pref.mode == 'ytotal') {

	          this.toAxes('setMinMaxToFitSeries', null, false, true);
	          this.fullX = false;
	          this.fullY = true;
	        } else if (pref.mode == 'total') {

	          this.toAxes('setMinMaxToFitSeries', null, true, true);

	          this.fullX = true;
	          this.fullY = true;
	          // Nothing to do here
	          /*        this.graph._applyToAxes( function( axis ) {
	               axis.emit( 'zoom', axis.currentAxisMin, axis.currentAxisMax, axis );
	             }, null, true, true );
	          */
	        } else {

	          x -= this.graph.options.paddingLeft;
	          y -= this.graph.options.paddingTop;

	          var xMin = xAxis.getCurrentMin(),
	              xMax = xAxis.getCurrentMax(),
	              xActual = xAxis.getVal(x),
	              diffX = xMax - xMin,
	              yMin = yAxis.getCurrentMin(),
	              yMax = yAxis.getCurrentMax(),
	              yActual = yAxis.getVal(y),
	              diffY = yMax - yMin;

	          if (pref.mode == 'gradualXY' || pref.mode == 'gradualX') {

	            var ratio = (xActual - xMin) / (xMax - xMin);
	            xMin = Math.max(xAxis.getMinValue() - xAxis.getInterval() * xAxis.options.axisDataSpacing.min, xMin - diffX * ratio);
	            xMax = Math.min(xAxis.getMaxValue() + xAxis.getInterval() * xAxis.options.axisDataSpacing.max, xMax + diffX * (1 - ratio));
	            xAxis.setCurrentMin(xMin);
	            xAxis.setCurrentMax(xMax);

	            if (xAxis.options.onZoom) {
	              xAxis.options.onZoom(xMin, xMax);
	            }

	            xAxis.cacheCurrentMin();
	            xAxis.cacheCurrentMax();
	            xAxis.cacheInterval();
	          }

	          if (pref.mode == 'gradualXY' || pref.mode == 'gradualY') {

	            var ratio = (yActual - yMin) / (yMax - yMin);
	            yMin = Math.max(yAxis.getMinValue() - yAxis.getInterval() * yAxis.options.axisDataSpacing.min, yMin - diffY * ratio);
	            yMax = Math.min(yAxis.getMaxValue() + yAxis.getInterval() * yAxis.options.axisDataSpacing.max, yMax + diffY * (1 - ratio));
	            yAxis.setCurrentMin(yMin);
	            yAxis.setCurrentMax(yMax);

	            if (yAxis.options.onZoom) {
	              yAxis.options.onZoom(yMin, yMax);
	            }

	            yAxis.cacheCurrentMin();
	            yAxis.cacheCurrentMax();
	            yAxis.cacheInterval();
	          }
	        }

	        graph.pluginYieldActiveState();

	        this.graph.draw();
	        /*
	            this.emit( "dblClick", {
	              graph: graph,
	              x: x,
	              y: y,
	              pref: pref,
	              e: e,
	              mute: mute
	            } );
	             if ( this.options.onDblClick && !mute ) {
	              this.options.onDblClick( graph, x, y, e, mute );
	            }*/
	      }
	    }, {
	      key: 'transition',
	      value: function transition(modeX, modeY, eventName) {

	        var self = this,
	            maxTime = 500;

	        if (!self.gradualUnzoomStart) {
	          self.gradualUnzoomStart = Date.now();
	        }

	        window.requestAnimationFrame(function () {

	          var dt = Date.now() - self.gradualUnzoomStart;

	          if (dt > maxTime) {
	            dt = maxTime;
	          }
	          var progress = Math.sin(dt / maxTime * Math.PI / 2);

	          self.toAxes(function (axis) {

	            axis.setCurrentMin(axis._pluginZoomMin + (axis._pluginZoomMinFinal - axis._pluginZoomMin) * progress);
	            axis.setCurrentMax(axis._pluginZoomMax + (axis._pluginZoomMaxFinal - axis._pluginZoomMax) * progress);

	            axis.cacheCurrentMin();
	            axis.cacheCurrentMax();
	            axis.cacheInterval();
	          }, false, modeX, modeY);

	          self.graph.draw();

	          if (dt < maxTime) {

	            self.transition(modeX, modeY, eventName);
	            self.emit('zooming');
	          } else {

	            self.emit('zoomed');
	            self.graph.pluginYieldActiveState();

	            if (eventName) {
	              self.emit(eventName);
	            }
	            self.gradualUnzoomStart = 0;
	          }
	        });
	      }
	    }, {
	      key: 'isFullX',
	      value: function isFullX() {
	        return this.fullX;
	      }
	    }, {
	      key: 'isFullY',
	      value: function isFullY() {
	        return this.fullY;
	      }
	    }, {
	      key: 'toAxes',
	      value: function toAxes(func, params, tb, lr) {

	        var axes = this.options.axes;

	        if (!axes || axes == 'serieSelected' && !this.graph.getSelectedSerie()) {
	          axes = 'all';
	        }

	        switch (axes) {

	          case 'all':
	            this.graph._applyToAxes.apply(this.graph, arguments);
	            break;

	          case 'serieSelected':

	            var serie = this.graph.getSelectedSerie();
	            if (serie) {

	              if (tb) {

	                if (typeof func == 'string') {
	                  serie.getXAxis()[func].apply(serie.getXAxis(), params);
	                } else {
	                  func.apply(serie.getXAxis(), params);
	                }
	              }

	              if (lr) {

	                if (typeof func == 'string') {
	                  serie.getYAxis()[func].apply(serie.getYAxis(), params);
	                } else {
	                  func.apply(serie.getYAxis(), params);
	                }
	              }
	            }

	            break;

	          default:

	            if (!Array.isArray(axes)) {
	              axes = [axes];
	            }

	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	              for (var _iterator = axes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var axis = _step.value;


	                if (axis.isX() && tb) {
	                  // Not the best check

	                  if (typeof func == 'string') {
	                    axis[func].apply(axis, params);
	                  } else {
	                    func.apply(axis, params);
	                  }
	                } else if (axis.isY() && lr) {
	                  // Not the best check

	                  if (typeof func == 'string') {
	                    axis[func].apply(axis, params);
	                  } else {
	                    func.apply(axis, params);
	                  }
	                }
	              }
	            } catch (err) {
	              _didIteratorError = true;
	              _iteratorError = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                  _iterator.return();
	                }
	              } finally {
	                if (_didIteratorError) {
	                  throw _iteratorError;
	                }
	              }
	            }

	            break;
	        }
	      }
	    }], [{
	      key: 'default',
	      value: function _default() {

	        return {
	          'axes': 'all'
	        };
	      }
	    }]);

	    return PluginZoom;
	  }(_graphPlugin2.default);

	  exports.default = PluginZoom;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 372 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(373), __webpack_require__(29), __webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphCore, _graphLru, _graphPlugin, _graphUtil) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphCore2 = _interopRequireDefault(_graphCore);

	  var _graphLru2 = _interopRequireDefault(_graphLru);

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  var util = _interopRequireWildcard(_graphUtil);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PluginTimeSerieManager = function (_Plugin) {
	    _inherits(PluginTimeSerieManager, _Plugin);

	    function PluginTimeSerieManager() {
	      _classCallCheck(this, PluginTimeSerieManager);

	      var _this = _possibleConstructorReturn(this, (PluginTimeSerieManager.__proto__ || Object.getPrototypeOf(PluginTimeSerieManager)).apply(this, arguments));

	      _this.series = [];
	      _this.plugins = [];
	      _this.currentSlots = {};

	      _this.requestLevels = new Map();
	      _this.update = function (noRecalculate, force) {

	        _this.series.forEach(function (serie) {

	          this.updateSerie(serie, noRecalculate);
	        });

	        if (!noRecalculate) {
	          _this.recalculateSeries(force);
	        }
	      };

	      return _this;
	    }

	    _createClass(PluginTimeSerieManager, [{
	      key: 'init',
	      value: function init(graph, options) {
	        this.graph = graph;
	        _graphLru2.default.create(this.options.LRUName, 200);
	        this.requestsRunning = 0;
	      }
	    }, {
	      key: 'setURL',
	      value: function setURL(url) {
	        this.options.url = url;
	        return this;
	      }
	    }, {
	      key: 'setAvailableIntervals',
	      value: function setAvailableIntervals() {
	        this.options.intervals = arguments;
	      }
	    }, {
	      key: 'newSerie',
	      value: function newSerie(serieName, serieOptions, serieType, dbElements, noZoneSerie) {
	        var s = this.graph.newSerie(serieName, serieOptions, serieType);

	        this.currentSlots[serieName] = {
	          min: 0,
	          max: 0,
	          interval: 0
	        };

	        s.on('hide', function () {

	          if (s._zoneSerie) {

	            s._zoneSerie.hide();
	          }
	        });

	        s.on('show', function () {

	          if (s._zoneSerie) {
	            s._zoneSerie.show();
	          }
	        });

	        s.setInfo('timeSerieManagerDBElements', dbElements);

	        if (!noZoneSerie) {
	          s._zoneSerie = this.graph.newSerie(serieName + '_zone', {}, _graphCore2.default.SERIE_ZONE);
	        }

	        this.series.push(s);
	        return s;
	      }
	    }, {
	      key: 'registerPlugin',
	      value: function registerPlugin(plugin, event) {

	        var index;
	        if ((index = this.plugins.indexOf(plugin)) > -1) {

	          for (var i = 1; i < arguments.length; i++) {
	            plugin.removeListener(arguments[i], this.update);
	          }
	        }

	        for (var i = 1; i < arguments.length; i++) {
	          plugin.on(arguments[i], this.update);
	        }
	      }
	    }, {
	      key: 'updateSerie',
	      value: function updateSerie(serie, noRecalculate) {

	        var self = this;
	        var from = serie.getXAxis().getCurrentMin();
	        var to = serie.getXAxis().getCurrentMax();

	        var optimalInterval = this.getOptimalInterval(to - from);
	        var optimalIntervalIndex = this.options.intervals.indexOf(optimalInterval);
	        var interval;

	        this.cleanRegister(optimalIntervalIndex);

	        for (var i = optimalIntervalIndex; i <= optimalIntervalIndex + 1; i++) {

	          interval = this.options.intervals[i];
	          var startSlotId = self.computeSlotID(from, interval);
	          var endSlotId = self.computeSlotID(to, interval);

	          var intervalMultipliers = [[2, 5, 6], [1, 2, 4], [0, 1, 3]];

	          intervalMultipliers.forEach(function (multiplier) {

	            var firstSlotId = startSlotId - multiplier[0] * (endSlotId - startSlotId);
	            var lastSlotId = endSlotId + multiplier[0] * (endSlotId - startSlotId);

	            var slotId = firstSlotId;

	            while (slotId <= lastSlotId) {

	              if (self.computeTimeMin(slotId, interval) > Date.now()) {
	                break;
	              }

	              self.register(serie, slotId, interval, interval == optimalInterval ? multiplier[1] : multiplier[2], true, noRecalculate);
	              slotId++;
	            }
	          });
	        }

	        this.processRequests();
	      }
	    }, {
	      key: 'cleanRegister',
	      value: function cleanRegister(interval) {

	        if (!this.requestLevels) {
	          return;
	        }

	        this.requestLevels.forEach(function (levelArray) {

	          levelArray.forEach(function (levelElement, levelIndex) {

	            if (levelElement[4] < interval) {
	              levelArray.splice(levelIndex, 1);
	            }
	          });
	        });
	      }
	    }, {
	      key: 'register',
	      value: function register(serie, slotId, interval, priority, noProcess, noRecalculate) {

	        var id = this.computeUniqueID(serie, slotId, interval);

	        var data = _graphLru2.default.get(this.options.LRUName, id);

	        if (!data || this.computeTimeMax(slotId, interval) > Date.now() && data.timeout < Date.now() - (noRecalculate ? 5000 : 100000) && priority == 1) {

	          this.request(serie, slotId, interval, priority, id, noProcess);
	        }
	      }
	    }, {
	      key: 'request',
	      value: function request(serie, slotId, interval, priority, slotName, noProcess) {

	        for (var i in this.requestLevels) {

	          if (i == priority) {
	            continue;
	          }

	          if (this.requestLevels[i][slotName]) {

	            if (this.requestLevels[i][slotName][0] !== 1) {
	              // If the request is not pending

	              delete this.requestLevels[i][slotName];
	            } else {
	              this.requestLevels[i][slotName][5] = priority;
	            }
	          }
	        }

	        if (this.requestLevels[priority] && this.requestLevels[priority][slotName]) {
	          return;
	        }

	        this.requestLevels[priority] = this.requestLevels[priority] || {};
	        this.requestLevels[priority][slotName] = [0, slotName, serie.getName(), slotId, interval, priority, serie.getInfo('timeSerieManagerDBElements')];

	        if (!noProcess) {
	          this.processRequests();
	        }
	      }
	    }, {
	      key: 'processRequests',
	      value: function processRequests() {

	        if (this.requestsRunning >= this.options.maxParallelRequests) {
	          return;
	        }

	        var self = this,
	            currentLevelChecking = 1,
	            requestToMake;

	        while (true) {

	          for (var i in this.requestLevels[currentLevelChecking]) {

	            if (this.requestLevels[currentLevelChecking][i][0] == 1) {
	              // Running request
	              continue;
	            }

	            requestToMake = this.requestLevels[currentLevelChecking][i];
	            break;
	          }

	          if (requestToMake) {
	            break;
	          }

	          currentLevelChecking++;

	          if (currentLevelChecking > 10) {
	            return;
	          }
	        }

	        this.requestsRunning++;

	        if (!requestToMake) {
	          return;
	        }

	        requestToMake[0] = 1;

	        util.ajaxGet({

	          url: this.getURL(requestToMake),
	          method: 'GET',
	          json: true

	        }).done(function (data) {

	          if (data.status == 1) {
	            // Success

	            self.requestsRunning--;

	            delete self.requestLevels[currentLevelChecking][i];

	            _graphLru2.default.store(self.options.LRUName, requestToMake[1], data.data); // Element 1 is the unique ID
	            self.processRequests();

	            if (requestToMake[5] == 1 && Object.keys(self.requestLevels[1]).length == 0) {

	              self.recalculateSeries(true);
	            }
	          }
	        });
	      }
	    }, {
	      key: 'computeTimeMax',
	      value: function computeTimeMax(slotId, interval) {
	        return (slotId + 1) * (interval * this.options.nbPoints);
	      }
	    }, {
	      key: 'computeTimeMin',
	      value: function computeTimeMin(slotId, interval) {
	        return slotId * (interval * this.options.nbPoints);
	      }
	    }, {
	      key: 'getURL',
	      value: function getURL(requestElements) {

	        var url = this.options.url.replace('<measurementid>', requestElements[2]).replace('<from>', this.computeTimeMin(requestElements[3], requestElements[4])).replace('<to>', this.computeTimeMax(requestElements[3], requestElements[4])).replace('<interval>', requestElements[4]);

	        var dbElements = requestElements[6] || {};

	        for (var i in dbElements) {
	          url = url.replace('<' + i + '>', dbElements[i]);
	        }

	        return url;
	      }
	    }, {
	      key: 'getOptimalInterval',
	      value: function getOptimalInterval(totalspan) {

	        var optimalInterval = (this.options.optimalPxPerPoint || 1) * totalspan / this.graph.getDrawingWidth(),
	            diff = Infinity,
	            optimalIntervalAmongAvailable;

	        this.options.intervals.forEach(function (interval) {

	          var newDiff = Math.min(diff, Math.abs(interval - optimalInterval));
	          if (diff !== newDiff) {

	            optimalIntervalAmongAvailable = interval;
	            diff = newDiff;
	          }
	        });

	        return optimalIntervalAmongAvailable || 1000;
	      }
	    }, {
	      key: 'computeUniqueID',
	      value: function computeUniqueID(serie, slotId, interval) {
	        var extra = '';
	        var info = serie.getInfo('timeSerieManagerDBElements');
	        for (var i in info) {
	          extra += ';' + i + ':' + info[i];
	        }

	        return serie.getName() + ';' + slotId + ';' + interval + extra;
	      }
	    }, {
	      key: 'computeSlotID',
	      value: function computeSlotID(time, interval) {
	        return Math.floor(time / (interval * this.options.nbPoints));
	      }
	    }, {
	      key: 'computeSlotTime',
	      value: function computeSlotTime(slotId, interval) {
	        return slotId * (interval * this.options.nbPoints);
	      }
	    }, {
	      key: 'getZoneSerie',
	      value: function getZoneSerie(serie) {
	        return serie._zoneSerie;
	      }
	    }, {
	      key: 'updateZoneSerie',
	      value: function updateZoneSerie(serieName) {

	        var serie = this.graph.getSerie(serieName);

	        if (!serie) {
	          return;
	        }

	        if (!serie._zoneSerie) {
	          return;
	        }

	        serie._zoneSerie.setXAxis(serie.getXAxis());
	        serie._zoneSerie.setYAxis(serie.getYAxis());
	        serie._zoneSerie.setFillColor(serie.getLineColor());
	        serie._zoneSerie.setLineColor(serie.getLineColor());
	        serie._zoneSerie.setFillOpacity(0.2);
	        serie._zoneSerie.setLineOpacity(0.3);
	      }
	    }, {
	      key: 'recalculateSeries',
	      value: function recalculateSeries(force) {

	        var self = this;

	        if (this.locked) {
	          return;
	        }

	        this.changed = false;

	        this.series.map(function (serie) {
	          self.recalculateSerie(serie, force);
	        });

	        /*if ( this.changed ) {
	            self.graph._applyToAxes( "scaleToFitAxis", [ this.graph.getXAxis(), false, undefined, undefined, false, true ], false, true );
	          }
	        */
	        this.changed = false;
	        //self.graph.autoscaleAxes();

	        self.graph.draw();
	      }
	    }, {
	      key: 'recalculateSerie',
	      value: function recalculateSerie(serie, force) {

	        var from = serie.getXAxis().getCurrentMin(),
	            to = serie.getXAxis().getCurrentMax(),
	            interval = this.getOptimalInterval(to - from);

	        var startSlotId = this.computeSlotID(from, interval);
	        var endSlotId = this.computeSlotID(to, interval);

	        var data = [];
	        var dataMinMax = [];

	        if (!force && interval == this.currentSlots[serie.getName()].interval && this.currentSlots[serie.getName()].min <= startSlotId && this.currentSlots[serie.getName()].max >= endSlotId) {
	          return;
	        }

	        startSlotId -= 2;
	        endSlotId += 2;

	        this.currentSlots[serie.getName()].min = startSlotId;
	        this.currentSlots[serie.getName()].max = endSlotId;
	        this.currentSlots[serie.getName()].interval = interval;

	        var slotId = startSlotId;

	        while (slotId <= endSlotId) {

	          var lruData = _graphLru2.default.get(this.options.LRUName, this.computeUniqueID(serie, slotId, interval));
	          if (lruData) {

	            data = data.concat(lruData.data.mean);
	            dataMinMax = dataMinMax.concat(lruData.data.minmax);
	          } else {

	            this.recalculateSerieUpwards(serie, slotId, interval, data, dataMinMax);
	          }

	          slotId++;
	        }

	        this.changed = true;

	        serie.setData(data);

	        if (serie._zoneSerie) {
	          serie._zoneSerie.setData(dataMinMax);
	        }
	      }
	    }, {
	      key: 'setIntervalCheck',
	      value: function setIntervalCheck(interval) {
	        var _this2 = this;

	        if (this.interval) {
	          clearInterval(this.interval);
	        }

	        this.update(true, true);
	        this.interval = setInterval(function () {
	          _this2.update(true, false);
	        }, interval);
	      }
	    }, {
	      key: 'recalculateSerieUpwards',
	      value: function recalculateSerieUpwards(serie, downSlotId, downInterval, data, dataMinMax) {

	        var intervals = this.options.intervals.slice(0);
	        intervals.sort();

	        var nextInterval = intervals[intervals.indexOf(downInterval) + 1] || -1;
	        if (nextInterval < 0) {
	          return [];
	        }

	        var newSlotTime = this.computeSlotTime(downSlotId, downInterval);
	        var newSlotTimeEnd = this.computeSlotTime(downSlotId + 1, downInterval);
	        var newSlotId = this.computeSlotID(newSlotTime, nextInterval),
	            start = false;

	        var lruData = _graphLru2.default.get(this.options.LRUName, this.computeUniqueID(serie, newSlotId, nextInterval));
	        if (lruData) {

	          for (var i = 0, l = lruData.data.mean.length; i < l; i += 2) {

	            if (lruData.data.mean[i] < newSlotTime) {
	              continue;
	            } else if (start === false) {
	              start = i;
	            }

	            if (lruData.data.mean[i] >= newSlotTimeEnd) {

	              data = data.concat(lruData.data.mean.slice(start, i));
	              dataMinMax = data.concat(lruData.data.minmax.slice(start, i));

	              return;
	            }
	          }
	        }

	        return this.recalculateSerieUpwards(serie, newSlotId, nextInterval, data, dataMinMax);
	      }
	    }, {
	      key: 'lockRedraw',
	      value: function lockRedraw() {
	        this.locked = true;
	      }
	    }, {
	      key: 'unlockRedraw',
	      value: function unlockRedraw() {
	        this.locked = false;
	      }
	    }, {
	      key: 'isRedrawLocked',
	      value: function isRedrawLocked() {
	        return !!this.locked;
	      }
	    }], [{
	      key: 'default',
	      value: function _default() {

	        return {

	          LRUName: 'PluginTimeSerieManager',
	          intervals: [1000, 15000, 60000, 900000, 3600000, 8640000],
	          maxParallelRequests: 3,
	          optimalPxPerPoint: 2,
	          nbPoints: 1000,
	          url: ''
	        };
	      }
	    }]);

	    return PluginTimeSerieManager;
	  }(_graphPlugin2.default);

	  exports.default = PluginTimeSerieManager;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 373 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.create = create;
	  exports.get = get;
	  exports.store = store;
	  exports.empty = empty;
	  exports.exist = exist;
	  var memory = {},
	      memoryHead = {},
	      memoryCount = {},
	      memoryLimit = {};

	  function emptyMemory(store) {
	    memory[store] = {};
	    memoryCount[store] = 0;
	  }

	  function createStoreMemory(store, limit) {
	    limit = limit || 50;
	    if (!memory[store]) {
	      memory[store] = {};
	      memoryCount[store] = 0;
	    }

	    memoryLimit[store] = limit;
	  }

	  function getFromMemory(store, index) {
	    var obj, head;

	    if (memory[store] && memory[store][index]) {

	      head = memoryHead[store];

	      obj = memory[store][index];
	      obj.prev = head;
	      obj.next = head.next;
	      head.next.prev = obj;
	      head.next = obj;

	      memoryHead[store] = obj;
	      return obj.data;
	    }
	  }

	  function storeInMemory(store, index, data) {

	    var toStore, toDelete, head;
	    if (memory[store] && memoryCount[store] !== undefined && memoryLimit[store]) {
	      head = memoryHead[store];

	      if (memory[store][index]) {

	        getFromMemory(store, index);
	        memory[store][index].data.data = data;
	        memory[store][index].data.timeout = Date.now();
	      } else {

	        toStore = {
	          data: {
	            data: data,
	            timeout: Date.now()
	          }
	        };

	        if (typeof head == 'undefined') {
	          toStore.prev = toStore;
	          toStore.next = toStore;
	        } else {
	          toStore.prev = head.prev;
	          toStore.next = head.next;
	          head.next.prev = toStore;
	          head.next = toStore;
	        }

	        memoryHead[store] = toStore;
	        memory[store][index] = toStore;
	        memoryCount[store]++;
	      }

	      // Remove oldest one
	      if (memoryCount[store] > memoryLimit[store] && head) {
	        toDelete = head.next;
	        head.next.next.prev = head;
	        head.next = head.next.next;
	        toDelete.next.next = undefined;
	        toDelete.next.prev = undefined;
	        memoryCount[store]--;
	      }

	      return data;
	    }
	  }

	  function create(store, limitMemory) {
	    createStoreMemory(store, limitMemory);
	  }

	  function get(store, index) {
	    var result;
	    if ((result = getFromMemory(store, index)) != undefined) {
	      return result;
	    }
	  }

	  function store(store, index, value) {
	    storeInMemory(store, index, value);
	    return value;
	  }

	  function empty(store) {
	    emptyMemory(store);
	  }

	  function exist(store) {
	    return memory[store];
	  }

	  exports.default = get;
	});

	/***/ }),
	/* 374 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphPlugin) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PluginSerieLineDifference = function (_Plugin) {
	    _inherits(PluginSerieLineDifference, _Plugin);

	    function PluginSerieLineDifference() {
	      _classCallCheck(this, PluginSerieLineDifference);

	      return _possibleConstructorReturn(this, (PluginSerieLineDifference.__proto__ || Object.getPrototypeOf(PluginSerieLineDifference)).apply(this, arguments));
	    }

	    _createClass(PluginSerieLineDifference, [{
	      key: 'init',
	      value: function init(graph, options) {
	        this.graph = graph;

	        this.pathsPositive = [];
	        this.pathsNegative = [];

	        this.positivePolyline = this.graph.newShape('polyline').draw();

	        this.positivePolyline.setFillColor(this.options.positiveStyle.fillColor).setFillOpacity(this.options.positiveStyle.fillOpacity).setStrokeWidth(this.options.positiveStyle.strokeWidth).applyStyle();

	        this.negativePolyline = this.graph.newShape('polyline').draw();

	        this.negativePolyline.setFillColor(this.options.negativeStyle.fillColor).setFillOpacity(this.options.negativeStyle.fillOpacity).setStrokeWidth(this.options.negativeStyle.strokeWidth).applyStyle();
	      }
	    }, {
	      key: 'setSeries',
	      value: function setSeries(serieTop, serieBottom) {
	        this.serie1 = serieTop;
	        this.serie2 = serieBottom;
	      }
	    }, {
	      key: 'setBoundaries',
	      value: function setBoundaries(from, to) {
	        this.options.from = from;
	        this.options.to = to;
	      }
	    }, {
	      key: 'getFrom',
	      value: function getFrom() {
	        return this.options.from;
	      }
	    }, {
	      key: 'getTo',
	      value: function getTo() {
	        return this.options.to;
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {

	        var self = this;
	        var s1 = this.serie1.searchClosestValue(this.getFrom());
	        var i1, j1, i2, j2, y, y2, crossing;

	        var top = [];
	        var bottom = [];

	        var bottomBroken;

	        if (!s1) {
	          i1 = 0;
	          j1 = 0;
	        } else {

	          i1 = s1.dataIndex;
	          j1 = s1.xAfterIndex * 2;
	        }

	        y = this.interpolate(this.serie1, this.getFrom());
	        top.push(this.getFrom()); // x
	        top.push(y); // y

	        y = this.interpolate(this.serie2, this.getFrom());
	        bottom.push(this.getFrom()); // x
	        bottom.push(y); // y

	        var s2;

	        var order;

	        function nextSet() {

	          if (order === true) {
	            self.pathsPositive.push([top, bottom]);
	          } else if (order === false) {
	            self.pathsNegative.push([top, bottom]);
	          }

	          top = [];
	          bottom = [];
	          order = undefined;
	        }
	        var ended;
	        for (; i1 < this.serie1.data.length; i1++) {

	          for (; j1 < this.serie1.data[i1].length; j1 += 2) {

	            if (this.serie1.data[i1][j1] > this.getTo()) {
	              // FINISHED !

	              y = this.interpolate(this.serie1, this.getTo());
	              y2 = this.interpolate(this.serie2, this.getTo());

	              crossing = this.computeCrossing(top[top.length - 2], top[top.length - 1], this.getTo(), y, bottom[bottom.length - 2], bottom[bottom.length - 1], this.getTo(), y2);

	              if (crossing) {

	                top.push(crossing.x);
	                top.push(crossing.y);
	                bottom.push(crossing.x);
	                bottom.push(crossing.y);
	                nextSet();
	                top.push(crossing.x);
	                top.push(crossing.y);
	                bottom.push(crossing.x);
	                bottom.push(crossing.y);

	                order = this.serie1.data[i1][j1 + 1] > this.serie2.data[i2][j2 + 1];
	              }

	              top.push(this.getTo()); // x
	              top.push(y); // y

	              bottom.push(this.getTo()); // x
	              bottom.push(y2); // y

	              ended = true;
	              break;
	            }

	            if (!s2) {
	              s2 = this.serie2.searchClosestValue(this.serie1.data[i1][j1]); // Finds the first point

	              if (s2) {
	                i2 = s2.dataIndex;
	                j2 = s2.xBeforeIndex * 2;

	                // TODO: Add here first points

	                y = this.interpolate(this.serie2, this.serie1.data[i1][j1]);

	                top.push(this.serie1.data[i1][j1]); // x
	                top.push(this.serie1.data[i1][j1 + 1]); // y

	                bottom.push(this.serie1.data[i1][j1]); // x
	                bottom.push(y); // y

	                order = this.serie1.data[i1][j1 + 1] > y;
	              } else {
	                continue;
	              }
	            }

	            bottomBroken = false;

	            crossing = this.computeCrossing(top[top.length - 2], top[top.length - 1], this.serie1.data[i1][j1], this.serie1.data[i1][j1 + 1], bottom[bottom.length - 2], bottom[bottom.length - 1], this.serie2.data[i2][j2], this.serie2.data[i2][j2 + 1]);

	            if (crossing) {

	              top.push(crossing.x);
	              top.push(crossing.y);
	              bottom.push(crossing.x);
	              bottom.push(crossing.y);
	              nextSet();
	              top.push(crossing.x);
	              top.push(crossing.y);
	              bottom.push(crossing.x);
	              bottom.push(crossing.y);

	              order = this.serie1.data[i1][j1 + 1] > this.serie2.data[i2][j2 + 1];
	            }

	            while (this.serie2.data[i2][j2] < this.serie1.data[i1][j1]) {

	              bottom.push(this.serie2.data[i2][j2]);
	              bottom.push(this.serie2.data[i2][j2 + 1]);

	              j2 += 2;
	              if (j2 == this.serie2.data[i2].length) {
	                bottomBroken = this.serie2.data[i2][j2 - 2];
	                i2++;
	                j2 = 0;
	                break;
	              }

	              crossing = this.computeCrossing(top[top.length - 2], top[top.length - 1], this.serie1.data[i1][j1], this.serie1.data[i1][j1 + 1], bottom[bottom.length - 2], bottom[bottom.length - 1], this.serie2.data[i2][j2], this.serie2.data[i2][j2 + 1]);

	              if (crossing) {

	                top.push(crossing.x);
	                top.push(crossing.y);
	                bottom.push(crossing.x);
	                bottom.push(crossing.y);
	                nextSet();
	                top.push(crossing.x);
	                top.push(crossing.y);
	                bottom.push(crossing.x);
	                bottom.push(crossing.y);

	                order = this.serie1.data[i1][j1 + 1] > this.serie2.data[i2][j2 + 1];
	              }
	            }

	            if (bottomBroken === false) {
	              top.push(this.serie1.data[i1][j1]);
	              top.push(this.serie1.data[i1][j1 + 1]);
	            } else {

	              top.push(bottomBroken);
	              top.push(this.interpolate(this.serie1, bottomBroken));

	              s2 = false;
	              j1 -= 2;
	              nextSet();
	            }
	          }

	          if (ended) {
	            nextSet();
	            break;
	          }
	          // End of X

	          y = this.interpolate(this.serie2, top[top.length - 2]);
	          if (y) {
	            bottom.push(top[top.length - 2]);
	            bottom.push(y);
	          }

	          nextSet();

	          j1 = 0;
	          s2 = false;
	        }

	        var d = this.pathsPositive.reduce(makePaths, '');
	        this.positivePolyline.setPointsPx(d).redraw();

	        var d = this.pathsNegative.reduce(makePaths, '');
	        this.negativePolyline.setPointsPx(d).redraw();

	        //pathsBottom.map( function( map ) { makePaths( map, self.options.negativeStyle ); } );

	        function makePaths(d, path) {

	          for (var i = 0; i < path[0].length; i += 2) {
	            if (i == 0) {
	              d += 'M ';
	            }
	            d += ' ' + Math.round(self.serie1.getXAxis().getPx(path[0][i])) + ', ' + Math.round(self.serie1.getYAxis().getPx(path[0][i + 1]));
	            if (i < path[0].length - 2) {
	              d += ' L ';
	            }
	          }

	          for (var i = path[1].length - 2; i >= 0; i -= 2) {
	            d += ' L ' + Math.round(self.serie2.getXAxis().getPx(path[1][i])) + ', ' + Math.round(self.serie2.getYAxis().getPx(path[1][i + 1]));
	            if (i == 0) {
	              d += ' z ';
	            }
	          }
	          return d;
	        }
	      }
	    }, {
	      key: 'interpolate',
	      value: function interpolate(serie, valX) {

	        var value = serie.searchClosestValue(valX);

	        if (!value) {
	          return false;
	        }

	        if (value.xMax == undefined) {
	          return value.yMin;
	        }

	        if (value.xMin == undefined) {
	          return value.yMax;
	        }

	        var ratio = (valX - value.xMin) / (value.xMax - value.xMin);
	        return (1 - ratio) * value.yMin + ratio * value.yMax;
	      }
	    }, {
	      key: 'computeCrossing',
	      value: function computeCrossing(x11, y11, x12, y12, x21, y21, x22, y22) {
	        var a1 = (y12 - y11) / (x12 - x11);
	        var a2 = (y22 - y21) / (x22 - x21);

	        var b1 = y12 - a1 * x12;
	        var b2 = y22 - a2 * x22;

	        if (x11 == x12 || x21 == x22) {

	          return false;
	        }

	        if (a1 == a2) {
	          return {
	            x: x11,
	            y1: y11,
	            y2: y11
	          };
	        }

	        var x = (b1 - b2) / (a2 - a1);

	        if (x > x12 || x < x11 || x < x21 || x > x22) {
	          return false;
	        }

	        return {
	          x: x,
	          y: a1 * x + b1
	        };
	      }
	    }, {
	      key: 'getPositivePolyline',
	      value: function getPositivePolyline() {
	        return this.positivePolyline;
	      }
	    }, {
	      key: 'getNegativePolyline',
	      value: function getNegativePolyline() {
	        return this.negativePolyline;
	      }
	    }], [{
	      key: 'default',
	      value: function _default() {
	        return {

	          positiveStyle: {

	            fillColor: 'green',
	            fillOpacity: 0.2,
	            strokeWidth: 0
	          },

	          negativeStyle: {
	            fillColor: 'red',
	            fillOpacity: 0.2,
	            strokeWidth: 0
	          },

	          from: 0,
	          to: 0
	        };
	      }
	    }]);

	    return PluginSerieLineDifference;
	  }(_graphPlugin2.default);

	  exports.default = PluginSerieLineDifference;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 375 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(45), __webpack_require__(101), __webpack_require__(139), __webpack_require__(5), __webpack_require__(51), __webpack_require__(141), __webpack_require__(29), __webpack_require__(72)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphCore, _graphAxisX, _graphAxisY, _graphUtil, _graphSerieLine, _graphSerieScatter, _graphPlugin, _graphAxis) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var _graphCore2 = _interopRequireDefault(_graphCore);

	  var _graphAxisX2 = _interopRequireDefault(_graphAxisX);

	  var _graphAxisY2 = _interopRequireDefault(_graphAxisY);

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphSerieLine2 = _interopRequireDefault(_graphSerieLine);

	  var _graphSerieScatter2 = _interopRequireDefault(_graphSerieScatter);

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  var _graphAxis2 = _interopRequireDefault(_graphAxis);

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var SerieLineExtended = function (_SerieLine) {
	    _inherits(SerieLineExtended, _SerieLine);

	    function SerieLineExtended() {
	      _classCallCheck(this, SerieLineExtended);

	      var _this = _possibleConstructorReturn(this, (SerieLineExtended.__proto__ || Object.getPrototypeOf(SerieLineExtended)).apply(this, arguments));

	      _this.subSeries = [];
	      return _this;
	    }

	    _createClass(SerieLineExtended, [{
	      key: 'setData',
	      value: function setData() {
	        var _this2 = this;

	        _get(SerieLineExtended.prototype.__proto__ || Object.getPrototypeOf(SerieLineExtended.prototype), 'setData', this).apply(this, arguments);
	        this.subSeries.map(function (sub) {
	          sub.data = _this2.data;
	        });
	        return this;
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {
	        this.eraseMarkers();
	        return this;
	      }
	    }, {
	      key: 'getSymbolForLegend',
	      value: function getSymbolForLegend() {
	        if (!this.subSeries[0]) {
	          return false;
	        }

	        return this.subSeries[0].getSymbolForLegend();
	      }
	    }, {
	      key: 'getMarkerForLegend',
	      value: function getMarkerForLegend() {
	        if (!this.subSeries[0]) {
	          return false;
	        }

	        return this.subSeries[0].getMarkerForLegend();
	      }
	    }]);

	    return SerieLineExtended;
	  }(_graphSerieLine2.default);

	  var SerieScatterExtended = function (_SerieScatter) {
	    _inherits(SerieScatterExtended, _SerieScatter);

	    function SerieScatterExtended() {
	      _classCallCheck(this, SerieScatterExtended);

	      var _this3 = _possibleConstructorReturn(this, (SerieScatterExtended.__proto__ || Object.getPrototypeOf(SerieScatterExtended)).apply(this, arguments));

	      _this3.subSeries = [];
	      return _this3;
	    }

	    _createClass(SerieScatterExtended, [{
	      key: 'setData',
	      value: function setData() {
	        var _this4 = this;

	        _get(SerieScatterExtended.prototype.__proto__ || Object.getPrototypeOf(SerieScatterExtended.prototype), 'setData', this).apply(this, arguments);
	        this.subSeries.map(function (sub) {
	          sub.data = _this4.data;
	        });
	        return this;
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {
	        return this;
	      }
	    }, {
	      key: 'getSymbolForLegend',
	      value: function getSymbolForLegend() {
	        if (!this.subSeries[0]) {
	          return false;
	        }

	        return this.subSeries[0].getSymbolForLegend();
	      }
	    }, {
	      key: 'getMarkerForLegend',
	      value: function getMarkerForLegend() {
	        if (!this.subSeries[0]) {
	          return false;
	        }

	        return this.subSeries[0].getMarkerForLegend();
	      }
	    }]);

	    return SerieScatterExtended;
	  }(_graphSerieScatter2.default);

	  var excludingMethods = ['constructor', 'init', 'draw', 'setLineColor', 'setLineWidth', 'setLineStyle', 'getLineColor', 'getLineWidth', 'getLineStyle', 'setMarkers', 'showMarkers', 'hideMarkers', 'getMarkerDom', 'getMarkerDomIndependant', 'getMarkerPath', 'eraseMarkers', '_recalculateMarkerPoints'];
	  var addMethods = [];

	  Object.getOwnPropertyNames(_graphSerieLine2.default.prototype).concat(addMethods).map(function (i) {

	    if (excludingMethods.indexOf(i) > -1) {
	      return;
	    }

	    SerieLineExtended.prototype[i] = function (j) {

	      return function () {

	        var args = arguments;
	        this.subSeries.map(function (subSerie) {
	          subSerie[j].apply(subSerie, _toConsumableArray(args));
	        });
	      };
	    }(i);
	  });

	  /**
	   * Axis splitting plugin
	   * @augments Plugin
	   */

	  var PluginAxisSplitting = function (_Plugin) {
	    _inherits(PluginAxisSplitting, _Plugin);

	    function PluginAxisSplitting(options) {
	      _classCallCheck(this, PluginAxisSplitting);

	      var _this5 = _possibleConstructorReturn(this, (PluginAxisSplitting.__proto__ || Object.getPrototypeOf(PluginAxisSplitting)).apply(this, arguments));

	      _this5.series = new Map();
	      return _this5;
	    }

	    _createClass(PluginAxisSplitting, [{
	      key: 'init',
	      value: function init(graph) {
	        this.graph = graph;
	      }
	    }, {
	      key: 'newXAxis',
	      value: function newXAxis(options) {
	        return this.newBottomAxis(options);
	      }
	    }, {
	      key: 'newYAxis',
	      value: function newYAxis(options) {
	        return this.newLeftAxis(options);
	      }
	    }, {
	      key: 'newTopAxis',
	      value: function newTopAxis(options) {
	        options = this.getOptions(options);
	        return new SplitXAxis(this.graph, 'top', options);
	      }
	    }, {
	      key: 'newBottomAxis',
	      value: function newBottomAxis(options) {
	        options = this.getOptions(options);
	        return new SplitXAxis(this.graph, 'bottom', options);
	      }
	    }, {
	      key: 'newLeftAxis',
	      value: function newLeftAxis(options) {
	        options = this.getOptions(options);
	        return new SplitYAxis(this.graph, 'left', options);
	      }
	    }, {
	      key: 'newRightAxis',
	      value: function newRightAxis(options) {
	        options = this.getOptions(options);
	        return new SplitYAxis(this.graph, 'right', options);
	      }
	    }, {
	      key: 'getOptions',
	      value: function getOptions(options) {
	        var defaults = {
	          marginMin: this.options.axes.margins.low,
	          marginMax: this.options.axes.margins.high
	        };
	        return util.extend(true, defaults, options);
	      }
	    }, {
	      key: 'preDraw',
	      value: function preDraw() {
	        var _this6 = this;

	        var xAxis, yAxis;

	        //    for ( let { serie } of this.series.values() ) {
	        this.series.forEach(function (_ref) {
	          var serie = _ref.serie;


	          xAxis = serie.getXAxis();
	          yAxis = serie.getYAxis();

	          var splits = 1;

	          if (xAxis.splitNumber) {
	            splits *= xAxis.splitNumber;
	          }

	          if (yAxis.splitNumber) {
	            splits *= yAxis.splitNumber;
	          }

	          while (serie.subSeries.length < splits) {

	            var name = serie.getName() + '_' + serie.subSeries.length;

	            var s = _this6.graph.newSerie(name, {}, serie.getType() || _graphCore2.default.SERIE_LINE);

	            s.excludedFromLegend = true;
	            s.styles = serie.styles;
	            s.data = serie.data; // Copy data

	            if (serie.getType() == _graphCore2.default.SERIE_LINE) {
	              s.markerPoints = serie.markerPoints;
	              s.markerFamilies = serie.markerFamilies;
	            }

	            serie.subSeries.push(s);
	          }

	          while (serie.subSeries.length > splits) {

	            var subserie = _this6.graph.getSerie(serie.getName() + '_' + (serie.subSeries.length - 1));

	            if (subserie && subserie.kill) {
	              subserie.kill();
	            }
	            serie.subSeries.pop();
	          }

	          if (!serie.getXAxis().splitNumber && serie.getXAxis().splitAxis) {
	            serie.getXAxis().splitAxis();
	          }

	          if (!serie.getYAxis().splitNumber && serie.getYAxis().splitAxis) {
	            serie.getYAxis().splitAxis();
	          }

	          // Re-assign axes to the sub series
	          serie.subSeries.map(function (sserie, index) {

	            var xSubAxis, ySubAxis;

	            //sserie.groupMarkers = firstSubSerie.groupMarkers;

	            if (serie.getXAxis().getSubAxis) {
	              var subAxisIndex = index % (xAxis.splitNumber || 1);
	              xSubAxis = serie.getXAxis().getSubAxis(subAxisIndex);
	            } else {
	              xSubAxis = serie.getXAxis();
	            }

	            sserie.setXAxis(xSubAxis);

	            if (serie.getYAxis().getSubAxis) {

	              var _subAxisIndex = Math.floor(index / (xAxis.splitNumber || 1));
	              ySubAxis = serie.getYAxis().getSubAxis(_subAxisIndex);
	            } else {
	              ySubAxis = serie.getYAxis();
	            }

	            sserie.setYAxis(ySubAxis);

	            sserie.draw(true);
	          });
	          //}
	        });
	      }
	    }, {
	      key: 'newSerie',
	      value: function newSerie(name) {
	        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	        var type = arguments[2];


	        switch (type) {

	          case 'line':
	            return this.newLineSerie(name, options);
	            break;

	          case 'scatter':
	            return this.newScatterSerie(name, options);
	            break;
	        }

	        throw 'Cannot create a split serie of type ' + type;
	      }
	    }, {
	      key: 'newLineSerie',
	      value: function newLineSerie(name, options) {
	        var serieObj = {
	          type: 'lineSerie',
	          serie: new SerieLineExtended(name, options, 'line')
	        };
	        this.series.set(name, serieObj);
	        serieObj.serie.init(this.graph, name, options);
	        this.graph.series.push(serieObj.serie);
	        return serieObj.serie;
	      }
	    }, {
	      key: 'newScatterSerie',
	      value: function newScatterSerie(name, options) {
	        var serieObj = {
	          type: 'scatterSerie',
	          serie: new SerieScatterExtended(name, options, 'scatter')
	        };
	        this.series.set(name, serieObj);
	        serieObj.serie.init(this.graph, options);
	        this.graph.series.push(serieObj.serie);
	        return serieObj.serie;
	      }
	    }], [{
	      key: 'defaults',
	      value: function defaults() {

	        return {
	          axes: {
	            margins: {
	              high: 5,
	              low: 5
	            }
	          }
	        };
	      }
	    }]);

	    return PluginAxisSplitting;
	  }(_graphPlugin2.default);

	  var defaultAxisConstructorOptions = {
	    splitMarks: true
	  };

	  var SplitAxis = function SplitAxis(mixin) {

	    var delegateMethods = ['turnGridsOff', 'turnGridsOn', 'gridsOff', 'gridsOn', 'setEngineering', 'setScientificScaleExponent', 'setScientific', 'setLabelColor', 'setSecondaryGridDasharray', 'setPrimaryGridDasharray', 'setSecondaryGridsOpacity', 'setPrimaryGridOpacity', 'setSecondaryGridWidth', 'setPrimaryGridWidth', 'setSecondaryGridColor', 'setPrimaryGridColor', 'setTicksLabelColor', 'setSecondaryTicksColor', 'setPrimaryTicksColor', 'setAxisColor', 'secondaryGridOn', 'secondaryGridOff', 'primaryGridOff', 'primaryGridOn', 'setSecondaryGrid', 'setPrimaryGrid', 'setGrids', 'setTickPosition', 'setExponentialFactor', 'setExponentialLabelFactor', 'setGridLinesStyle', 'forcePrimaryTickUnitMin', 'forcePrimaryTickUnitMax', 'forcePrimaryTickUnit', 'flip', 'show', 'hide', 'setDisplay'];

	    /**
	     * Split axis
	     * @mixes AxisX
	     * @mixes AxisY
	     * @name SplitAxis
	     * @static
	     */
	    var cl = function (_mixin) {
	      _inherits(SplitAxis, _mixin);

	      function SplitAxis(graph, position) {
	        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	        _classCallCheck(this, SplitAxis);

	        var _this7 = _possibleConstructorReturn(this, (SplitAxis.__proto__ || Object.getPrototypeOf(SplitAxis)).call(this, graph, position, options));

	        _this7.axes = [];
	        _this7.position = position;
	        _this7.constructorOptions = util.extend(true, {}, defaultAxisConstructorOptions, options);

	        _this7._splitVal = [];
	        return _this7;
	      }

	      /**
	       *  Calls a callback onto each chunk axes. The callback receives two parameters: 1) the ```axis``` itself and 2) the ```index``` of the axis in the stack
	       *  @param {Function} callback - The callback to be applied to each axes
	       *  @return {SplitAxis} The current axis instance
	       */


	      _createClass(SplitAxis, [{
	        key: 'all',
	        value: function all(callback) {

	          if (!(typeof callback == 'function')) {
	            return;
	          }

	          this.axes.map(callback);
	          return this;
	        }
	      }, {
	        key: 'splitAxis',
	        value: function splitAxis() {
	          for (var _len = arguments.length, splits = Array(_len), _key = 0; _key < _len; _key++) {
	            splits[_key] = arguments[_key];
	          }

	          splits.push(1);
	          var splitNumber = splits.length;

	          while (this.axes.length > splitNumber) {
	            this.axes.pop().kill(true, true);
	          }

	          while (this.axes.length < splitNumber) {
	            var axis = new (this.getConstructor())(this.graph, this.position, this.constructorOptions);
	            this.axes.push(axis);
	            axis.zoomLock = true;
	            axis.init(this.graph, this.constructorOptions);
	          }

	          var from = 0;
	          var i = 0;
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;

	          try {
	            for (var _iterator = this.axes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var _axis = _step.value;


	              _axis.options.marginMin = 10;
	              _axis.options.marginMax = 10;

	              if (i == 0) {
	                _axis.options.marginMin = 0;
	              }

	              if (i == this.axes.length - 1) {
	                _axis.options.marginMax = 0;
	              }

	              _axis.setSpan(from, from = splits[i]);
	              _axis.setMinMaxFlipped();
	              i++;
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }

	          this._splits = splits;
	          return this;
	        }
	      }, {
	        key: 'fixGridIntervalBasedOnAxis',
	        value: function fixGridIntervalBasedOnAxis(axisIndex) {

	          this.fixGridFor = axisIndex;
	          this.graph._axisHasChanged();
	          return this;
	        }
	      }, {
	        key: 'splitSpread',
	        value: function splitSpread(bln) {
	          this.autoSpread = !!bln;
	          return this;
	        }
	      }, {
	        key: 'hasAxis',
	        value: function hasAxis(axis) {
	          return this.axes.indexOf(axis) > -1;
	        }
	      }, {
	        key: '_splitSpread',
	        value: function _splitSpread() {

	          var splits = [],
	              total = 0,
	              currentSplit = 0;
	          //console.log( this._splitVal );
	          var _iteratorNormalCompletion2 = true;
	          var _didIteratorError2 = false;
	          var _iteratorError2 = undefined;

	          try {
	            for (var _iterator2 = this._splitVal[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	              var split = _step2.value;

	              total += split[1] - split[0];
	            }
	          } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	              }
	            } finally {
	              if (_didIteratorError2) {
	                throw _iteratorError2;
	              }
	            }
	          }

	          var _iteratorNormalCompletion3 = true;
	          var _didIteratorError3 = false;
	          var _iteratorError3 = undefined;

	          try {
	            for (var _iterator3 = this._splitVal[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	              var _split = _step3.value;


	              splits.push(currentSplit += (_split[1] - _split[0]) / total);
	            }
	          } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	              }
	            } finally {
	              if (_didIteratorError3) {
	                throw _iteratorError3;
	              }
	            }
	          }

	          splits.pop();
	          this.splitAxis.apply(this, splits);
	        }
	      }, {
	        key: 'setChunkBoundaries',
	        value: function setChunkBoundaries(values) {

	          var index = 0,
	              baseWidth = void 0,
	              baseWidthIndex = void 0;

	          var _iteratorNormalCompletion4 = true;
	          var _didIteratorError4 = false;
	          var _iteratorError4 = undefined;

	          try {
	            for (var _iterator4 = this.axes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	              var axis = _step4.value;
	              // List all axes

	              // Two elements in the array => becomes the new reference
	              if (Array.isArray(values[index]) && values[index].length > 1 && !baseWidth) {
	                baseWidth = values[index][1] - values[index][0];
	                baseWidthIndex = index;
	              }

	              if (values[index].length == 1 || !Array.isArray(values[index])) {
	                axis._mean = values[index];

	                if (Array.isArray(axis._mean)) {
	                  axis._mean = axis._mean[0];
	                }
	              } else {

	                axis.forceMin(values[index][0]).forceMax(values[index][1]);
	              }

	              index++;
	            }
	          } catch (err) {
	            _didIteratorError4 = true;
	            _iteratorError4 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                _iterator4.return();
	              }
	            } finally {
	              if (_didIteratorError4) {
	                throw _iteratorError4;
	              }
	            }
	          }

	          this._baseWidthVal = baseWidth;
	          this._baseWidthIndex = baseWidthIndex;

	          this._splitVal = values;

	          this.graph._axisHasChanged();

	          return this;
	        }
	      }, {
	        key: 'setMinMaxToFitSeries',
	        value: function setMinMaxToFitSeries() {

	          if (!this._splitVal || this._splitVal.length < 1) {
	            _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'setMinMaxToFitSeries', this).apply(this, arguments);
	            this._splitVal[0] = this._splitVal[0] || [];
	            this._splitVal[this._splitVal.length - 1] = this._splitVal[this._splitVal.length - 1] || [];

	            this._splitVal[0][0] = this.getCurrentMin();
	            this._splitVal[this._splitVal.length - 1][1] = this.getCurrentMax();
	            this.setChunkBoundaries(this._splitVal);
	          }
	        }
	      }, {
	        key: 'draw',
	        value: function draw() {
	          var _this8 = this;

	          if (this.autoSpread) {
	            this._splitSpread();
	          }

	          var max = 0;
	          var unit = void 0;
	          var subAxis = void 0;
	          var spanReference = void 0;

	          if (this._baseWidthIndex >= 0 && (subAxis = this.getSubAxis(this._baseWidthIndex))) {
	            spanReference = subAxis.getSpan();
	          }

	          subAxis = undefined;

	          if (this.fixGridFor >= 0 && (subAxis = this.getSubAxis(this.fixGridFor))) {

	            if (subAxis._mean !== undefined) {
	              var width = (subAxis.getSpan()[1] - subAxis.getSpan()[0]) / (spanReference[1] - spanReference[0]) * this._baseWidthVal;
	              subAxis.forceMin(subAxis._mean - width / 2);
	              subAxis.forceMax(subAxis._mean + width / 2);
	            }

	            max = subAxis.draw();
	            unit = subAxis.getPrimaryTickUnit();
	          }

	          this.axes.map(function (axis) {

	            if (subAxis === axis) {
	              return;
	            }

	            if (axis._mean !== undefined) {
	              var _width = (axis.getSpan()[1] - axis.getSpan()[0]) / (spanReference[1] - spanReference[0]) * _this8._baseWidthVal;
	              axis.forceMin(axis._mean - _width / 2);
	              axis.forceMax(axis._mean + _width / 2);
	            }

	            if (unit) {
	              axis.forcePrimaryTickUnit(unit);
	            }

	            max = Math.max(max, axis.draw());
	          });

	          //    this.drawLabel();
	          this.writeUnit();

	          return max;
	        }
	      }, {
	        key: 'setMinPx',
	        value: function setMinPx(min) {

	          _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'setMinPx', this).call(this, min);
	          var _iteratorNormalCompletion5 = true;
	          var _didIteratorError5 = false;
	          var _iteratorError5 = undefined;

	          try {
	            for (var _iterator5 = this.axes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	              var axis = _step5.value;

	              axis.setMinPx(min);
	            }
	          } catch (err) {
	            _didIteratorError5 = true;
	            _iteratorError5 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                _iterator5.return();
	              }
	            } finally {
	              if (_didIteratorError5) {
	                throw _iteratorError5;
	              }
	            }
	          }
	        }
	      }, {
	        key: 'setMaxPx',
	        value: function setMaxPx(max) {

	          _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'setMaxPx', this).call(this, max);

	          var _iteratorNormalCompletion6 = true;
	          var _didIteratorError6 = false;
	          var _iteratorError6 = undefined;

	          try {
	            for (var _iterator6 = this.axes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	              var axis = _step6.value;

	              axis.setMaxPx(max);
	            }
	          } catch (err) {
	            _didIteratorError6 = true;
	            _iteratorError6 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                _iterator6.return();
	              }
	            } finally {
	              if (_didIteratorError6) {
	                throw _iteratorError6;
	              }
	            }
	          }
	        }
	      }, {
	        key: 'setShift',
	        value: function setShift() {

	          _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'setShift', this).apply(this, arguments);

	          var _iteratorNormalCompletion7 = true;
	          var _didIteratorError7 = false;
	          var _iteratorError7 = undefined;

	          try {
	            for (var _iterator7 = this.axes[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	              var axis = _step7.value;

	              axis.setShift.apply(axis, arguments);
	            }
	          } catch (err) {
	            _didIteratorError7 = true;
	            _iteratorError7 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion7 && _iterator7.return) {
	                _iterator7.return();
	              }
	            } finally {
	              if (_didIteratorError7) {
	                throw _iteratorError7;
	              }
	            }
	          }
	        }
	      }, {
	        key: 'init',
	        value: function init() {
	          _get(SplitAxis.prototype.__proto__ || Object.getPrototypeOf(SplitAxis.prototype), 'init', this).apply(this, arguments);
	          this.splitAxis();
	        }
	      }, {
	        key: 'getAxisPosition',
	        value: function getAxisPosition() {
	          var max = 0;

	          this.axes.map(function (axis) {
	            max = Math.max(max, axis.getAxisPosition());
	          });

	          return max;
	        }
	      }, {
	        key: 'getSubAxis',
	        value: function getSubAxis(index) {

	          if (this.axes.length <= index) {
	            throw 'Impossible to reach axis. Index ' + index + ' is out of range';
	          }

	          return this.axes[index];
	        }
	      }, {
	        key: 'splitNumber',
	        get: function get() {
	          return this._splits.length;
	        }
	      }]);

	      return SplitAxis;
	    }(mixin);

	    delegateMethods.map(function (methodName) {

	      cl.prototype[methodName] = function (method) {

	        return function () {
	          var _arguments = arguments;

	          //super[ method ]( ...arguments )

	          this.axes.map(function (axis) {
	            axis[method].apply(axis, _arguments);
	          });
	          return this;
	        };
	      }(methodName);
	    });

	    return cl;
	  };

	  var SplitXAxis = function (_SplitAxis) {
	    _inherits(SplitXAxis, _SplitAxis);

	    function SplitXAxis(graph, topbottom, options) {
	      _classCallCheck(this, SplitXAxis);

	      var _this9 = _possibleConstructorReturn(this, (SplitXAxis.__proto__ || Object.getPrototypeOf(SplitXAxis)).apply(this, arguments));

	      _this9.topbottom = topbottom;
	      return _this9;
	    }

	    _createClass(SplitXAxis, [{
	      key: 'getConstructor',
	      value: function getConstructor() {
	        return _graphAxisX2.default;
	      }
	    }, {
	      key: 'getAxisPosition',
	      value: function getAxisPosition() {
	        var max = _get(SplitXAxis.prototype.__proto__ || Object.getPrototypeOf(SplitXAxis.prototype), 'getAxisPosition', this).apply(this, arguments);

	        this.labelPosY = max;

	        if (this.getLabel()) {
	          max += this.graph.options.fontSize;
	        }

	        return max;
	      }
	    }, {
	      key: 'drawLabel',
	      value: function drawLabel() {
	        _get(SplitXAxis.prototype.__proto__ || Object.getPrototypeOf(SplitXAxis.prototype), 'drawLabel', this).call(this);
	        this.label.setAttribute('y', (this.top ? -1 : 1) * (this.graph.options.fontSize + this.labelPosY));
	      }
	    }, {
	      key: 'draw',
	      value: function draw() {
	        var height = _get(SplitXAxis.prototype.__proto__ || Object.getPrototypeOf(SplitXAxis.prototype), 'draw', this).apply(this, arguments);
	        this.drawLabel();
	        return height;
	      }
	    }]);

	    return SplitXAxis;
	  }(SplitAxis(_graphAxisX2.default));

	  var SplitYAxis = function (_SplitAxis2) {
	    _inherits(SplitYAxis, _SplitAxis2);

	    function SplitYAxis(graph, leftright, options) {
	      _classCallCheck(this, SplitYAxis);

	      return _possibleConstructorReturn(this, (SplitYAxis.__proto__ || Object.getPrototypeOf(SplitYAxis)).apply(this, arguments));
	    }

	    _createClass(SplitYAxis, [{
	      key: 'getConstructor',
	      value: function getConstructor() {
	        return _graphAxisY2.default;
	      }
	    }, {
	      key: 'drawLabel',
	      value: function drawLabel() {
	        _get(SplitYAxis.prototype.__proto__ || Object.getPrototypeOf(SplitYAxis.prototype), 'drawLabel', this).call(this);
	      }
	    }, {
	      key: 'equalizePosition',
	      value: function equalizePosition(width) {

	        var widthAfter = width;

	        if (this.getLabel()) {
	          this.axes.map(function (axis) {
	            widthAfter = Math.max(axis.equalizePosition(width), widthAfter);
	          }); // Extra shift allowed for the label
	          //this.setShift( this.graph.options.fontSize );
	        }

	        if (this.getLabel()) {
	          this.placeLabel(this.left ? -widthAfter : widthAfter);
	          return widthAfter + this.graph.options.fontSize;
	        }
	      }
	    }]);

	    return SplitYAxis;
	  }(SplitAxis(_graphAxisY2.default));

	  util.mix(SplitXAxis, new _graphAxisX2.default());
	  util.mix(SplitYAxis, new _graphAxisY2.default());

	  exports.default = PluginAxisSplitting;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 376 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphUtil, _graphPlugin) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _toConsumableArray(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	        arr2[i] = arr[i];
	      }

	      return arr2;
	    } else {
	      return Array.from(arr);
	    }
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PluginMakeTracesDifferent = function (_Plugin) {
	    _inherits(PluginMakeTracesDifferent, _Plugin);

	    function PluginMakeTracesDifferent() {
	      _classCallCheck(this, PluginMakeTracesDifferent);

	      return _possibleConstructorReturn(this, (PluginMakeTracesDifferent.__proto__ || Object.getPrototypeOf(PluginMakeTracesDifferent)).apply(this, arguments));
	    }

	    _createClass(PluginMakeTracesDifferent, [{
	      key: 'init',
	      value: function init(graph, options) {
	        _get(PluginMakeTracesDifferent.prototype.__proto__ || Object.getPrototypeOf(PluginMakeTracesDifferent.prototype), 'init', this).call(this, graph, options);
	      }
	    }, {
	      key: 'checkHSL',
	      value: function checkHSL(color) {

	        var result = {},
	            hue = void 0,
	            saturation = void 0,
	            lightness = void 0;

	        if (hue = color.h || color.hue) {

	          if (hue < 1) {
	            hue = Math.round(hue * 360);
	          }

	          result.hue = hue;
	        } else {
	          result.h = 0;
	        }

	        if (saturation = color.s || color.saturation) {

	          if (saturation > 1) {
	            saturation /= 100;
	          }

	          result.saturation = saturation;
	        } else {
	          result.saturation = 0.75;
	        }

	        if (lightness = color.lightness || color.l) {

	          if (lightness > 1) {
	            lightness /= 100;
	          }

	          result.lightness = lightness;
	        } else {
	          result.lightness = 0.5;
	        }

	        return result;
	      }
	    }, {
	      key: 'buildHSLString',
	      value: function buildHSLString(hsl) {
	        return 'hsl( ' + Math.round(hsl.h) + ', ' + Math.round(hsl.s * 100) + '%, ' + Math.round(hsl.l * 100) + '%)';
	      }
	    }, {
	      key: 'colorizeAll',
	      value: function colorizeAll(options) {
	        var _this2 = this;

	        var series = void 0,
	            seriesLength = void 0;

	        if (options.serieTypes) {
	          var _graph;

	          if (!Array.isArray(options.serieTypes)) {
	            options.serieTypes = [options.serieTypes];
	          }

	          series = (_graph = this.graph).allSeries.apply(_graph, _toConsumableArray(options.serieTypes));
	        } else {
	          series = this.graph.getSeries();
	        }

	        seriesLength = series.length;

	        if (!options.startingColorHSL) {

	          if (options.colorHSL) {
	            options.startingColorHSL = this.checkHSL(options.colorHSL);
	          } else {
	            throw 'No starting color was provided. There must exist either options.colorHSL or options.startingColorHSL';
	          }
	        }

	        if (!options.endingColorHSL) {

	          if (!options.affect || !['h', 's', 'l', 'hue', 'saturation', 'lightness'].include(options.affect)) {
	            options.affect = 'h';
	          }

	          switch (options.affect) {

	            case 'h':
	            case 'hue':
	              options.endingColorHSL = {
	                h: options.startingColorHSL.h + 300,
	                s: options.startingColorHSL.s,
	                l: options.startingColorHSL.l
	              };
	              break;

	            case 'saturation':
	            case 's':
	              var endS = void 0;

	              if (options.startingColorHSL.s > 0.5) {
	                endS = 0;
	              } else {
	                endS = 1;
	              }

	              options.endingColorHSL = {
	                h: options.startingColorHSL.h,
	                s: endS,
	                l: options.startingColorHSL.l
	              };
	              break;

	            case 'lightness':
	            case 'l':
	              var endL = void 0;

	              if (options.startingColorHSL.l > 0.5) {
	                endL = 0;
	              } else {
	                endL = 0.75;
	              }

	              options.endingColorHSL = {
	                h: options.startingColorHSL.h,
	                s: options.startingColorHSL.s,
	                l: endL
	              };
	              break;
	          }
	        } else {
	          options.endingColorHSL = Object.assign({}, options.startingColorHSL, options.endingColorHSL);
	        }

	        return series.map(function (serie, index) {

	          if (!serie.setLineColor) {
	            throw 'The serie ' + serie.getName() + ' does not implement the method `startingColor`';
	          }

	          var colorString = _this2.buildHSLString({
	            h: options.startingColorHSL.h + index / (seriesLength - 1) * (options.endingColorHSL.h - options.startingColorHSL.h),
	            s: options.startingColorHSL.s + index / (seriesLength - 1) * (options.endingColorHSL.s - options.startingColorHSL.s),
	            l: options.startingColorHSL.l + index / (seriesLength - 1) * (options.endingColorHSL.l - options.startingColorHSL.l)
	          });

	          serie.setLineColor(colorString);
	          return colorString;
	        });
	      }
	    }], [{
	      key: 'default',
	      value: function _default() {

	        return {};
	      }
	    }]);

	    return PluginMakeTracesDifferent;
	  }(_graphPlugin2.default);

	  exports.default = PluginMakeTracesDifferent;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 377 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(29)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphUtil, _graphPlugin) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphPlugin2 = _interopRequireDefault(_graphPlugin);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  var _get = function get(object, property, receiver) {
	    if (object === null) object = Function.prototype;
	    var desc = Object.getOwnPropertyDescriptor(object, property);

	    if (desc === undefined) {
	      var parent = Object.getPrototypeOf(object);

	      if (parent === null) {
	        return undefined;
	      } else {
	        return get(parent, property, receiver);
	      }
	    } else if ("value" in desc) {
	      return desc.value;
	    } else {
	      var getter = desc.get;

	      if (getter === undefined) {
	        return undefined;
	      }

	      return getter.call(receiver);
	    }
	  };

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var PluginPeakPicking = function (_Plugin) {
	    _inherits(PluginPeakPicking, _Plugin);

	    function PluginPeakPicking() {
	      _classCallCheck(this, PluginPeakPicking);

	      return _possibleConstructorReturn(this, (PluginPeakPicking.__proto__ || Object.getPrototypeOf(PluginPeakPicking)).apply(this, arguments));
	    }

	    _createClass(PluginPeakPicking, [{
	      key: 'init',
	      value: function init(graph, options) {

	        _get(PluginPeakPicking.prototype.__proto__ || Object.getPrototypeOf(PluginPeakPicking.prototype), 'init', this).call(this, graph, options);
	        this.picks = [];

	        for (var n = 0, m = this.options.autoPeakPickingNb; n < m; n++) {

	          var shape = this.graph.newShape({
	            type: 'label',
	            label: {
	              text: '',
	              position: {
	                x: 0
	              },
	              anchor: 'middle'

	            },

	            selectable: true,

	            shapeOptions: {
	              minPosY: 15
	            }

	          });

	          shape.draw();

	          this.picks.push(shape);
	        }
	      }
	    }, {
	      key: 'setSerie',
	      value: function setSerie(serie) {
	        this.serie = serie;
	      }
	    }, {
	      key: 'serieRemoved',
	      value: function serieRemoved(serie) {

	        if (this.serie == serie) {
	          this.picks.map(function (pick) {
	            pick.kill();
	          });
	        }
	      }
	    }, {
	      key: 'preDraw',
	      value: function preDraw() {

	        if (!this.serie) {
	          return;
	        }

	        this.detectedPeaks = [];
	        this.lastYPeakPicking = false;
	      }
	    }, {
	      key: 'postDraw',
	      value: function postDraw() {

	        if (!this.serie) {
	          return;
	        }
	        var lookForMaxima = true;
	        var lookForMinima = false;
	        var lastYPeakPicking = void 0;
	        var peaks = [];

	        var waveform = this.serie.getWaveform();

	        if (!waveform) {
	          throw 'The serie must have a waveform for the peak picking to work';
	        }

	        var length = waveform.getLength(),
	            i = 0,
	            y = void 0;

	        for (; i < length; i++) {

	          y = waveform.getY(i);

	          if (this.serie.options.lineToZero) {
	            peaks.push([waveform.getX(i), y]);
	            continue;
	          }

	          if (!lastYPeakPicking) {
	            lastYPeakPicking = [waveform.getX(i), y];
	            continue;
	          }

	          if (y >= lastYPeakPicking[1] && lookForMaxima || y <= lastYPeakPicking[1] && lookForMinima) {

	            lastYPeakPicking = [waveform.getX(i), y];
	          } else if (y < lastYPeakPicking[1] && lookForMaxima || y > lastYPeakPicking[1] && lookForMinima) {

	            if (lookForMinima) {
	              lookForMinima = false;
	              lookForMaxima = true;
	            } else {

	              lookForMinima = true;
	              lookForMaxima = false;

	              peaks.push(lastYPeakPicking);
	              lastYPeakPicking = false;
	            }

	            lastYPeakPicking = [waveform.getX(i), y];
	          }
	        }

	        var ys = peaks;
	        var x,
	            px,
	            passed = [],
	            px,
	            l = ys.length,
	            k,
	            m,
	            index;

	        i = 0;

	        var selected = this.graph.selectedShapes.map(function (shape) {
	          return shape.getProp('xval');
	        });

	        ys.sort(function (a, b) {
	          return b[1] - a[1];
	        });

	        m = 0;

	        for (; i < l; i++) {

	          x = ys[i][0];
	          px = this.serie.getX(x);
	          k = 0;
	          y = this.serie.getY(ys[i][1]);

	          if (px < this.serie.getXAxis().getMinPx() || px > this.serie.getXAxis().getMaxPx()) {
	            continue;
	          }

	          if (!this.options.autoPeakPickingAllowAllY && (y > this.serie.getYAxis().getMinPx() || y < this.serie.getYAxis().getMaxPx())) {

	            continue;
	          }

	          // Distance check
	          for (; k < passed.length; k++) {
	            if (Math.abs(passed[k] - px) < this.options.autoPeakPickingMinDistance) {
	              break;
	            }
	          }
	          if (k < passed.length) {
	            continue;
	          }

	          // Distance check end

	          // If the retained one has already been selected somewhere, continue;
	          if ((index = selected.indexOf(x)) > -1) {
	            passed.push(px);
	            continue;
	          }

	          if (!this.picks[m]) {
	            return;
	          }

	          //console.log( this.getYAxis().getDataMax(), this.getYAxis().getCurrentMin(), y );
	          //    this.picks[ m ].show();

	          if (this.serie.getYAxis().getPx(ys[i][1]) - 20 < 0) {

	            this.picks[m].setLabelPosition({
	              x: x,
	              y: '5px'
	            });

	            this.picks[m].setLabelBaseline('hanging');
	          } else {

	            this.picks[m].setLabelBaseline('no-change');

	            this.picks[m].setLabelPosition({
	              x: x,
	              y: ys[i][1],
	              dy: '-15px'
	            });
	          }

	          this.picks[m].setProp('xval', x);

	          if (this.options.autoPeakPickingFormat) {

	            this.picks[m].setLabelText(this.options.autoPeakPickingFormat.call(this.picks[m], x, m));
	          } else {
	            this.picks[m].setLabelText(String(Math.round(x * 1000) / 1000));
	          }

	          this.picks[m].makeLabels();

	          m++;
	          while (this.picks[m] && this.picks[m].isSelected()) {
	            m++;
	          }

	          if (passed.length == this.options.autoPeakPickingNb) {
	            break;
	          }
	        }
	      }
	    }, {
	      key: 'hidePeakPicking',
	      value: function hidePeakPicking(lock) {

	        if (!this._hidePeakPickingLocked) {
	          this._hidePeakPickingLocked = lock;
	        }

	        if (!this.graph.picks) {
	          return;
	        }
	        for (var i = 0; i < this.graph.picks.length; i++) {
	          this.graph.picks[i].hide();
	        }
	      }
	    }, {
	      key: 'showPeakPicking',
	      value: function showPeakPicking(unlock) {

	        if (this._hidePeakPickingLocked && !unlock) {
	          return;
	        }

	        if (!this.graph.picks) {
	          return;
	        }

	        for (var i = 0; i < this.graph.picks.length; i++) {
	          this.graph.picks[i].show();
	        }
	      }
	    }, {
	      key: 'killPeakPicking',
	      value: function killPeakPicking() {

	        if (this.picks) {
	          for (var i = 0, l = this.picks.length; i < l; i++) {
	            this.picks[i].kill();
	          }
	        }
	      }
	    }], [{
	      key: 'default',
	      value: function _default() {

	        return {
	          autoPeakPicking: false,
	          autoPeakPickingNb: 4,
	          autoPeakPickingMinDistance: 10,
	          autoPeakPickingFormat: false,
	          autoPeakPickingAllowAllY: false
	        };
	      }
	    }]);

	    return PluginPeakPicking;
	  }(_graphPlugin2.default);

	  exports.default = PluginPeakPicking;
	  module.exports = exports['default'];
	});

	/***/ }),
	/* 378 */
	/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
	  {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, exports, __webpack_require__(5), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
					__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
					(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
					__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})(this, function (module, exports, _graphUtil, _graphShape) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });

	  var util = _interopRequireWildcard(_graphUtil);

	  var _graphShape2 = _interopRequireDefault(_graphShape);

	  function _interopRequireDefault(obj) {
	    return obj && obj.__esModule ? obj : {
	      default: obj
	    };
	  }

	  function _interopRequireWildcard(obj) {
	    if (obj && obj.__esModule) {
	      return obj;
	    } else {
	      var newObj = {};

	      if (obj != null) {
	        for (var key in obj) {
	          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	        }
	      }

	      newObj.default = obj;
	      return newObj;
	    }
	  }

	  function _classCallCheck(instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	      throw new TypeError("Cannot call a class as a function");
	    }
	  }

	  var _createClass = function () {
	    function defineProperties(target, props) {
	      for (var i = 0; i < props.length; i++) {
	        var descriptor = props[i];
	        descriptor.enumerable = descriptor.enumerable || false;
	        descriptor.configurable = true;
	        if ("value" in descriptor) descriptor.writable = true;
	        Object.defineProperty(target, descriptor.key, descriptor);
	      }
	    }

	    return function (Constructor, protoProps, staticProps) {
	      if (protoProps) defineProperties(Constructor.prototype, protoProps);
	      if (staticProps) defineProperties(Constructor, staticProps);
	      return Constructor;
	    };
	  }();

	  function _possibleConstructorReturn(self, call) {
	    if (!self) {
	      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    }

	    return call && (typeof call === "object" || typeof call === "function") ? call : self;
	  }

	  function _inherits(subClass, superClass) {
	    if (typeof superClass !== "function" && superClass !== null) {
	      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	    }

	    subClass.prototype = Object.create(superClass && superClass.prototype, {
	      constructor: {
	        value: subClass,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	  }

	  var ShapeEllipse = function (_Shape) {
	    _inherits(ShapeEllipse, _Shape);

	    function ShapeEllipse(graph, options) {
	      _classCallCheck(this, ShapeEllipse);

	      return _possibleConstructorReturn(this, (ShapeEllipse.__proto__ || Object.getPrototypeOf(ShapeEllipse)).call(this, graph, options));
	    }

	    _createClass(ShapeEllipse, [{
	      key: 'createDom',
	      value: function createDom() {
	        this._dom = document.createElementNS(this.graph.ns, 'ellipse');
	      }
	    }, {
	      key: 'applyPosition',
	      value: function applyPosition() {

	        var pos = this.computePosition(0);

	        this.setDom('cx', pos.x || 0);
	        this.setDom('cy', pos.y || 0);

	        var posR = this.graph.newPosition({

	          dx: this.getProp('rx'),
	          dy: this.getProp('ry') || this.getProp('rx')

	        });

	        var posComputed = this.calculatePosition(posR);

	        this.setDom('rx', Math.abs(posComputed.x) || 0);
	        this.setDom('ry', Math.abs(posComputed.y) || 0);
	        return true;
	      }
	    }, {
	      key: 'setR',
	      value: function setR(rx, ry) {
	        this.setProp('rx', rx);
	        this.setProp('ry', ry);
	        return this;
	      }
	    }, {
	      key: 'handleMouseUpImpl',
	      value: function handleMouseUpImpl() {
	        this.triggerChange();
	      }
	    }, {
	      key: 'handleMouseMoveImpl',
	      value: function handleMouseMoveImpl(e, deltaX, deltaY, deltaXPx, deltaYPx) {}
	    }]);

	    return ShapeEllipse;
	  }(_graphShape2.default);

	  exports.default = ShapeEllipse;
	  module.exports = exports['default'];
	});

	/***/ })
	/******/ ]);
	});
	});

	var Graph = unwrapExports(jsgraph);

	var colors = ["e61414", "e614cb", "ad14e6", "7714e6", "3214e6", "146de6", "14b2e6", "13cfc4", "13cf67", "20880c", "8fae14", "c6bf0e", "c6900e", "c64f0e", "555455", "000000"];

	var JVData = function (_React$Component) {
		inherits(JVData, _React$Component);

		function JVData() {
			classCallCheck(this, JVData);
			return possibleConstructorReturn(this, (JVData.__proto__ || Object.getPrototypeOf(JVData)).apply(this, arguments));
		}

		createClass(JVData, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				this.graph = new Graph(this.graphDOM);
				this.graph.getLeftAxis().setLabel('Current density').setUnit('A').setUnitWrapper('(', ')').setScientific(true).setUnitDecade(true).setLineAt([0]);

				this.graph.getBottomAxis().setLabel('Voltage').setUnit('V').setUnitWrapper('(', ')').setScientific(true).setUnitDecade(true);

				this.graph.resize(900, 400);

				this.legend = this.graph.makeLegend();
				this.legend.setAutoPosition('left');
			}
		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate() {
				var _this2 = this;

				this.graph.removeSeries();

				this.props.jvs.map(function (jv) {

					_this2.graph.newSerie().autoAxis().setWaveform(jv.jv).setLabel('Ch' + jv.chanId).setLineColor("#" + colors[jv.chanId - 1]).setLineStyle(jv.jvId + 1);
				});

				this.graph.autoscaleAxes();
				this.graph.draw();
			}
		}, {
			key: 'render',
			value: function render() {
				var _this3 = this;

				return react.createElement('div', { ref: function ref(el) {
						return _this3.graphDOM = el;
					} });
			}
		}]);
		return JVData;
	}(react.Component);

	JVData.propTypes = {
		jvs: propTypes.arrayOf(propTypes.shape({ jv: propTypes.array.isRequired })).isRequired
	};

	var mapStateToProps$5 = function mapStateToProps(state) {

		var data = state.viewData.data[state.currentQueueElement] || [];
		var channels = state.viewData.channels;
		var jvs = state.viewData.jvs;

		return {
			jvs: data.filter(function (el) {
				return channels.indexOf(el.chanId) > -1 && jvs.indexOf(el.jvId) > -1;
			})
		};
	};

	var JVDataWrapper = connect(mapStateToProps$5)(JVData);

	var JV = function (_Graph$getConstructor) {
		inherits(JV, _Graph$getConstructor);

		function JV() {
			classCallCheck(this, JV);
			return possibleConstructorReturn(this, (JV.__proto__ || Object.getPrototypeOf(JV)).apply(this, arguments));
		}

		createClass(JV, [{
			key: 'getVoc',
			value: function getVoc() {

				var index = void 0;
				if ((index = this.findLevel(0, { rounding: 'interpolate' })) === undefined) {
					throw new Error("No crossing at 0A found");
				}

				return this.interpolateIndex_X(index);
			}
		}, {
			key: 'getJsc',
			value: function getJsc() {

				return this.interpolate(0);
			}
		}, {
			key: 'getFF',
			value: function getFF() {
				return 0.5;
			}
		}, {
			key: 'getPCE',
			value: function getPCE(cellArea, sunIntensity) {

				if (!this.power) {
					this.computePower();
				}

				var maxPower = this.power.getMax();
				var maxPowerIndex = this.power.findLevel(maxPower, { rounding: 'after' });

				if (maxPowerIndex == 0 || maxPowerIndex == this.getLength()) {
					throw "Cannot find maximum power";
				}

				return maxPower / cellArea / sunIntensity;
			}
		}, {
			key: 'computePower',
			value: function computePower() {

				this.power = this.duplicate();

				this.power = this.power.math(function (x, y) {
					return x * y;
				});
			}
		}]);
		return JV;
	}(Graph.getConstructor('graph.waveform'));

	var findJV = function findJV(measurementStack, index) {
		return measurementStack.filter(function (meas) {
			return meas.jvId == index;
		})[0];
	};

	var formatNumber = function formatNumber(number) {
		return number.toPrecision(3);
	};

	var JVChannelTable = function JVChannelTable(_ref) {
		var jvs = _ref.jvs,
		    jvElements = _ref.jvElements,
		    jvToDisplay = _ref.jvToDisplay,
		    chanId = _ref.chanId,
		    cellArea = _ref.cellArea,
		    sunIntensity = _ref.sunIntensity;
		return react.createElement(
			'div',
			null,
			react.createElement(
				'h4',
				null,
				'Channel ',
				chanId
			),
			react.createElement(
				'table',
				null,
				react.createElement(
					'tr',
					null,
					react.createElement(
						'th',
						null,
						'Start (V)'
					),
					react.createElement(
						'th',
						null,
						'End (V)'
					),
					react.createElement(
						'th',
						null,
						'Scan rate (V/s)'
					),
					react.createElement(
						'th',
						null,
						'V',
						react.createElement(
							'sub',
							null,
							'oc'
						),
						' (V)'
					),
					react.createElement(
						'th',
						null,
						'J',
						react.createElement(
							'sub',
							null,
							'jsc'
						),
						' (mA)'
					),
					react.createElement(
						'th',
						null,
						'FF (%)'
					),
					react.createElement(
						'th',
						null,
						'PCE (%)'
					),
					react.createElement(
						'th',
						null,
						'R',
						react.createElement(
							'sub',
							null,
							'p'
						)
					),
					react.createElement(
						'th',
						null,
						'R',
						react.createElement(
							'sub',
							null,
							's'
						)
					)
				),
				jvElements.map(function (jvElement, index) {

					// Let's not display any j-v section that's not selected

					if (jvToDisplay.indexOf(index) == -1) {
						return null;
					}

					var jv = findJV(jvs, index);
					var tds = [];

					if (jv) {

						var voc = void 0,
						    jsc = void 0,
						    pce = void 0;
						try {
							voc = formatNumber(jv.jv.getVoc()) + " V";
						} catch (error) {
							voc = react.createElement(
								'span',
								{ className: 'error', title: error },
								'N/A'
							);
						}

						try {

							try {
								jsc = react.createElement(
									'span',
									null,
									formatNumber(jv.jv.getJsc()),
									'mA cm',
									react.createElement(
										'sup',
										null,
										'-2'
									)
								);
							} catch (error) {
								throw new Error("Crossing at 0V could not be found. Make sure that the j-V curve boundaries include a 0V crossing (stopping at 0V is not enough).");
							}

							if (!cellArea) {
								throw new Error("Area is not defined. Cannot normalize the current");
							}

							jsc /= cellArea;
						} catch (error) {

							jsc = react.createElement(
								'span',
								{ className: 'error', title: error },
								'N/A'
							);
						}

						try {

							if (!cellArea) {
								throw new Error("Area is not defined. Cannot normalize the power output");
							}

							if (!sunIntensity) {
								throw new Error("Sun intensity is not defined. Cannot calculate the PCE");
							}

							try {
								pce = react.createElement(
									'span',
									null,
									formatNumber(Math.round(1000 * jv.jv.getPCE(cellArea, sunIntensity / 1000)) / 10),
									'%'
								);
							} catch (error) {

								throw new Error("Could not find the maximum power point. Make sure that there is a local maximum in the power - voltage curve");
							}
						} catch (error) {

							pce = react.createElement(
								'span',
								{ className: 'error', title: error },
								'N/A'
							);
						}

						tds = [react.createElement(
							'td',
							null,
							voc
						), react.createElement(
							'td',
							null,
							jsc
						), react.createElement(
							'td',
							null,
							jv.jv.getFF()
						), react.createElement(
							'td',
							null,
							pce
						)];
					}

					return react.createElement(
						'tr',
						null,
						react.createElement(
							'td',
							null,
							jvElement.start
						),
						react.createElement(
							'td',
							null,
							jvElement.end
						),
						react.createElement(
							'td',
							null,
							jvElement.scanRate
						),
						tds
					);
				})
			)
		);
	};

	JVChannelTable.propTypes = {
		jvs: propTypes.arrayOf(propTypes.shape({ jv: propTypes.instanceOf(JV).isRequired })).isRequired,
		jvElements: propTypes.arrayOf(propTypes.number.isRequired).isRequired,
		jvToDisplay: propTypes.arrayOf(propTypes.number.isRequired).isRequired,
		chanId: propTypes.number.isRequired,
		cellArea: propTypes.number.isRequired,
		sunIntensity: propTypes.number.isRequired
	};

	var mapStateToProps$6 = function mapStateToProps(state, ownProps) {

		var data = state.viewData.data[state.currentQueueElement] || [];
		var jvs = state.viewData.jvs;
		var queueDetails = state.queue[state.currentQueueElement];

		if (!queueDetails) {
			return {};
		}

		return {
			jvs: data.filter(function (el) {
				return el.chanId == ownProps.chanId && jvs.indexOf(el.jvId) > -1;
			}),

			jvToDisplay: ownProps.jvs,
			jvElements: queueDetails.jvStopValues,
			cellArea: ownProps.config.area,
			sunIntensity: state.sunIntensity
		};
	};

	var mapDispathToProps = function mapDispathToProps(dispatch) {

		return {};
	};

	var JVChannelTableWrapper = connect(mapStateToProps$6, mapDispathToProps)(JVChannelTable);

	var JVTable = function JVTable(_ref) {
		var channels = _ref.channels,
		    channelsConfig = _ref.channelsConfig,
		    jvs = _ref.jvs,
		    exportToXLS = _ref.exportToXLS;
		return react.createElement(
			'div',
			null,
			react.createElement(
				'button',
				{ className: 'btn btn-default', onClick: exportToXLS },
				'Export to Excel'
			),
			channels.map(function (chan) {
				return react.createElement(JVChannelTableWrapper, { jvs: jvs, chanId: chan, config: channelsConfig.filter(function (c) {
						return c.chanId == chan;
					})[0] });
			})
		);
	};

	JVTable.propTypes = {
		channelsConfig: propTypes.arrayOf(propTypes.shape({ chanId: propTypes.number.isRequired })),
		channels: propTypes.arrayOf(propTypes.number.isRequired).isRequired,
		jvs: propTypes.arrayOf(propTypes.number.isRequired).isRequired
	};

	var mapStateToProps$7 = function mapStateToProps(state) {

		var data = state.viewData.data[state.currentQueueElement] || [];
		var channels = state.viewData.channels;
		var channelsConfig = state.channels;
		var jvs = state.viewData.jvs;

		return {
			channels: channels,
			channelsConfig: channelsConfig,
			jvs: jvs,

			exportToXLS: function exportToXLS() {
				/*	var ws = XLSX.utils.aoa_to_sheet([[1,2,3],[4,5,6],[7,8,9]]);
	   	var wb = XLSX.utils.book_new();
	   	XLSX.utils.book_append_sheet( wb, ws, "JV");
	   		XLSX.writeFile(wb, "myfile.xlsx");*/
			}
		};
	};

	var JVTableWrapper = connect(mapStateToProps$7)(JVTable);

	var ChanList = function ChanList(_ref) {
		var channels = _ref.channels,
		    channelsView = _ref.channelsView,
		    toggleChannel = _ref.toggleChannel,
		    toggleAllChannel = _ref.toggleAllChannel,
		    toggleNoChannel = _ref.toggleNoChannel;
		return react.createElement(
			'div',
			null,
			react.createElement(
				'h4',
				null,
				'Available channels'
			),
			react.createElement(
				'div',
				null,
				channels.filter(function (chan) {
					return chan.active;
				}).map(function (chan) {
					return react.createElement(
						'button',
						{ type: 'button', className: "btn " + (channelsView.filter(function (c) {
								return c == chan.chanId;
							}).length > 0 ? ' btn-primary' : ' btn-default'), onClick: function onClick() {
								return toggleChannel(chan.chanId);
							} },
						chan.chanId
					);
				}),
				react.createElement(
					'button',
					{ type: 'button', className: 'btn btn-default', onClick: function onClick() {
							return toggleAllChannel(channelsView);
						} },
					'All'
				),
				react.createElement(
					'button',
					{ type: 'button', className: 'btn btn-default', onClick: function onClick() {
							return toggleNoChannel(channelsView);
						} },
					'None'
				)
			)
		);
	};

	ChanList.propTypes = {
		channels: propTypes.arrayOf(propTypes.number.isRequired).isRequired,
		toggleChannel: propTypes.func.isRequired,
		toggleAllChannel: propTypes.func.isRequired,
		toggleNoChannel: propTypes.func.isRequired
	};

	var mapStateToProps$8 = function mapStateToProps(state) {

		return {
			channels: state.channels,
			channelsView: state.viewData.channels
		};
	};

	var mapDispatchToProps$4 = function mapDispatchToProps(dispatch) {

		return {

			toggleChannel: function toggleChannel(chanId) {
				dispatch(ChannelsToggleViewData(chanId));
			},

			toggleAllChannel: function toggleAllChannel(channels) {
				channels.map(function (chanId) {
					dispatch(ChannelsToggleViewData(chanId, true));
				});
			},

			toggleNoChannel: function toggleNoChannel(channels) {
				channels.map(function (chanId) {
					dispatch(ChannelsToggleViewData(chanId, false));
				});
			}
		};
	};

	var ChanListWrapper = connect(mapStateToProps$8, mapDispatchToProps$4)(ChanList);

	var JVList = function JVList(_ref) {
		var jvList = _ref.jvList,
		    jvEnabled = _ref.jvEnabled,
		    toggleJV = _ref.toggleJV;
		return react.createElement(
			'div',
			null,
			react.createElement(
				'h4',
				null,
				'j(V) sections'
			),
			react.createElement(
				'div',
				{ className: 'list-group' },
				jvList.map(function (jv, index) {
					return react.createElement(
						'button',
						{ type: 'button', className: "btn " + (jvEnabled.indexOf(index) > -1 ? ' btn-primary' : ' btn-default'), onClick: function onClick() {
								return toggleJV(index);
							} },
						jv.start,
						'V ',
						react.createElement('span', { className: 'glyphicon glyphicon-arrow-right' }),
						' ',
						jv.end,
						'V @ ',
						jv.scanRate,
						'V/s'
					);
				}),
				react.createElement(
					'button',
					{ type: 'button', className: "btn  btn-default", onClick: function onClick() {
							jvList.map(function (jv, index) {
								return toggleJV(index, true);
							});
						} },
					'All'
				),
				react.createElement(
					'button',
					{ type: 'button', className: "btn btn-default", onClick: function onClick() {
							jvList.map(function (jv, index) {
								return toggleJV(index, false);
							});
						} },
					'None'
				)
			)
		);
	};

	JVList.propTypes = {
		jvList: propTypes.shape({ start: propTypes.number.isRequired, end: propTypes.number.isRequired, scanRate: propTypes.number.isRequired }),
		jvEnabled: propTypes.arrayOf(propTypes.number).isRequired,
		toggleJV: propTypes.func.isRequired
	};

	var mapStateToProps$9 = function mapStateToProps(state) {

		return {
			jvEnabled: state.viewData.jvs,
			jvList: state.queue[state.currentQueueElement] && state.queue[state.currentQueueElement].type == 'JV' ? state.queue[state.currentQueueElement].jvStopValues : []
		};
	};

	var mapDispatchToProps$5 = function mapDispatchToProps(dispatch) {

		return {

			toggleJV: function toggleJV(jvId, force) {

				dispatch(JVToggleViewData(jvId, force));
			}

		};
	};

	var JVListWrapper = connect(mapStateToProps$9, mapDispatchToProps$5)(JVList);

	var JVData$1 = function (_React$Component) {
		inherits(JVData, _React$Component);

		function JVData() {
			classCallCheck(this, JVData);
			return possibleConstructorReturn(this, (JVData.__proto__ || Object.getPrototypeOf(JVData)).apply(this, arguments));
		}

		createClass(JVData, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				this.graphs = {
					power: new Graph(this.graphDOMPower)
				};

				this.graphs.power.getLeftAxis().setLabel('Power density').setUnit('W cm^-2').setUnitWrapper('(', ')').setScientific(true).setUnitDecade(true).setLineAt([0]);

				this.graphs.power.getBottomAxis().setLabel('Time').setUnit('s').setUnitWrapper('(', ')');

				this.graph.resize(900, 400);

				this.legend = this.graph.makeLegend();
				this.legend.setAutoPosition('left');
			}
		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate() {
				var _this2 = this;

				this.graph.removeSeries();

				this.props.mpp.map(function (mpp) {

					_this2.graph.newSerie().autoAxis().setWaveform(mpp.waveform).setLabel('Ch' + mpp.chanId).setLineColor("#" + colors[mpp.chanId - 1]);
				});

				this.graph.autoscaleAxes();
				this.graph.draw();
			}
		}, {
			key: 'render',
			value: function render() {
				var _this3 = this;

				return react.createElement('div', { ref: function ref(el) {
						return _this3.graphDOMPower = el;
					} });
			}
		}]);
		return JVData;
	}(react.Component);

	JVData$1.propTypes = {
		jvs: propTypes.arrayOf(propTypes.shape({ jv: propTypes.array.isRequired })).isRequired
	};

	var mapStateToProps$10 = function mapStateToProps(state) {

		var data = state.viewData.data[state.currentQueueElement] || [];
		var channels = state.viewData.channels;

		return {
			mpp: data.filter(function (el) {
				return channels.indexOf(el.chanId) > -1;
			})
		};
	};

	var MPPDataWrapper$1 = connect(mapStateToProps$10)(JVData$1);

	var mapStateToProps$11 = function mapStateToProps(state) {
		return {
			queueElement: state.queue[state.currentQueueElement]
		};
	};

	var ViewDataElement = function ViewDataElement(_ref) {
		var dispatch = _ref.dispatch,
		    queueElement = _ref.queueElement;


		if (!queueElement) {
			return null;
		}

		return react.createElement(
			'div',
			null,
			function () {

				switch (queueElement.type) {

					case 'JV':
						return react.createElement(
							'div',
							null,
							react.createElement(
								'div',
								{ className: 'row view-list' },
								react.createElement(ChanListWrapper, null)
							),
							react.createElement(
								'div',
								{ className: 'row view-list' },
								react.createElement(JVListWrapper, null)
							),
							react.createElement(
								'div',
								{ className: 'row' },
								react.createElement(
									'div',
									{ className: 'col-sm-12' },
									react.createElement(JVDataWrapper, null)
								),
								react.createElement(
									'div',
									{ className: 'col-sm-12' },
									react.createElement(JVTableWrapper, null)
								)
							)
						);
						break;

					case 'MPPT':

						return react.createElement(
							'div',
							null,
							react.createElement(
								'div',
								{ className: 'row view-list' },
								react.createElement(ChanListWrapper, null)
							),
							react.createElement(
								'div',
								{ className: 'row' },
								react.createElement(
									'div',
									{ className: 'col-sm-12' },
									react.createElement(MPPDataWrapper, null)
								)
							)
						);
						break;

				}
			}()
		);
	};

	var ViewData = connect(mapStateToProps$11)(ViewDataElement);

	function dataReceived(queueId, data) {

		return {
			type: 'DATA_RECEIVED',
			queueId: queueId,
			data: data
		};
	}

	var hasOwn$1 = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;

	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}

		return toStr.call(arr) === '[object Array]';
	};

	var isPlainObject$1 = function isPlainObject(obj) {
		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}

		var hasOwnConstructor = hasOwn$1.call(obj, 'constructor');
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn$1.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) { /**/ }

		return typeof key === 'undefined' || hasOwn$1.call(obj, key);
	};

	var extend = function extend() {
		var options, name, src, copy, copyIsArray, clone;
		var target = arguments[0];
		var i = 1;
		var length = arguments.length;
		var deep = false;

		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}
		if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
			target = {};
		}

		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target !== copy) {
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && isArray(src) ? src : [];
							} else {
								clone = src && isPlainObject$1(src) ? src : {};
							}

							// Never move original objects, clone them
							target[name] = extend(deep, clone, copy);

						// Don't bring in undefined values
						} else if (typeof copy !== 'undefined') {
							target[name] = copy;
						}
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	var extend$1 = /*#__PURE__*/Object.freeze({
		default: extend,
		__moduleExports: extend
	});

	var require$$0$4 = ( extend$1 && extend ) || extend$1;

	function _interopDefault$1 (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

	var extend$2 = _interopDefault$1(require$$0$4);

	class FitHost {

	  constructor(options) {

	    this.DELTAP = 1e-6;
	    this.BIGVAL = 9e99;
	    this.WEIGHT = 1.0;

	    this.setYData(options.dataY);
	    this.setXData(options.dataX);
	    this.setWeight(options.weight);
	    this.setInitialParams(options.params);

	    if (options.subsetIndex) {
	      this.setSubset(...options.subsetIndex);
	    }

	    this.setFunction(options.function);

	    if (options.progress) {
	      this.hookIteration(options.progress);
	    }

	    this.options = options;
	  }

	  //[ [ x1, y1 ], [ x2, y2 ] ]
	  setYData(data) {
	    // Waveform instance
	    this.data = data;
	  }

	  setXData(data) {
	    // Waveform instance
	    this.dataX = data;
	  }

	  setWeight(weight) {
	    // Waveform instance
	    this.weight = weight;
	  }

	  setInitialParams(params) {
	    this.parms = params;

	    this.parms = this.parms.map(el => {
	      if (typeof el == 'function') {
	        return el(this.data, this.dataX);
	      } else {
	        return el;
	      }
	    });
	    this.NPARMS = params.length;
	  }

	  setSubset(fromIndex, toIndex) {
	    if (fromIndex !== undefined && toIndex !== undefined) {
	      this._from = fromIndex;
	      this._to = toIndex;
	    }
	  }

	  hookIteration(f) {
	    this._hookIteration = params => {
	      let data = this.buildFit(params, 200);
	      f(data);
	    };
	  }

	  setFunction(func) {
	    this._func = func;
	  }

	  init() {

	    // Get data length
	    if (this._from !== undefined && this._to !== undefined) {

	      if (this._from >= this._to) {
	        throw 'Impossible to fit negative subranges. The starting index must be lower than the ending index';
	      }

	      this.NPTS = this._to - this._from + 1;

	      if (this.data && this.data.getLength() <= this._to) {
	        throw 'Wave Y has not enough point to be fitted to subrange [' + this._from + ', ' + this._to + ']';
	      }

	      if (this._from < 0) {
	        throw 'Impossible to fit a subrange with negative indices';
	      }
	    } else {

	      this.NPTS = this.data.getLength();
	      this._from = 0;
	      this._to = this.data.getLength() - 1;
	    }

	    if (this.dataX && this.dataX.getLength() <= this._to) {
	      throw 'Wave X has not enough point to be fitted to subrange [' + this._from + ', ' + this._to + ']';
	    }

	    this.arrY = this.data.getDataY();

	    if (this.dataX) {
	      this.arrX = this.dataX.getDataY();
	    } else {
	      this.arrX = this.data.getDataX();
	    }

	    this.resid = new Array(this.NPTS).fill(0);
	    this.jac = new Array(this.NPTS).fill(0);
	    this.jac = this.jac.map(el => new Array(this.NPARMS));
	  }

	  fit() {

	    this.log('Starting the fit with initial parameter list {' + this.parms.join() + '};');
	    new LM(this, this.NPARMS, this.NPTS, this._hookIteration);
	    this.log('Fit successful. Output parameters {' + this.parms.join() + '};');

	    this._result = this.buildFit(this.parms, 200);

	    if (this.options.done) {
	      this.options.done(this.parms, this._result);
	    }

	    return this._result;
	  }

	  func(x, param) {
	    return this._func(x, param);
	  }

	  computeResiduals() {
	    var sumsq = 0;
	    for (var i = 0; i < this.NPTS; i++) {
	      this.resid[i] = (this.func(this.arrX[i + this._from], this.parms) - this.arrY[i + this._from]) * this.WEIGHT;
	      sumsq += this.resid[i] * this.resid[i];
	    }

	    return sumsq;
	  }

	  log(message) {
	    if (this.options.log) {
	      console.log(message);
	    }
	  }

	  //------the four mandated interface methods------------
	  nudge(dp) {

	    for (var j = 0; j < this.NPARMS; j++) {
	      this.parms[j] += dp[j];
	    }
	    return this.computeResiduals();
	  }

	  buildJacobian() {
	    // Allows LM to compute a new Jacobian.
	    // Uses current parms[] and two-sided finite difference.
	    // If current parms[] is bad, returns false.
	    var delta = new Array(this.NPARMS);
	    var FACTOR = 0.5 / this.DELTAP;
	    var d = 0;

	    for (var j = 0; j < this.NPARMS; j++) {
	      for (var k = 0; k < this.NPARMS; k++) delta[k] = k == j ? this.DELTAP : 0.0;

	      d = this.nudge(delta); // resid at pplus
	      if (d == this.BIGVAL) {
	        throw 'Bad dBuildJacobian() exit 2';
	      }

	      for (var i = 0; i < this.NPTS; i++) {
	        this.jac[i][j] = this.getResidualElement(i);
	      }

	      for (var k = 0; k < this.NPARMS; k++) {
	        delta[k] = k == j ? -2 * this.DELTAP : 0.0;
	      }

	      d = this.nudge(delta); // resid at pminus
	      if (d == this.BIGVAL) {
	        throw 'Bad dBuildJacobian(). exit 3';
	      }

	      for (var i = 0; i < this.NPTS; i++) this.jac[i][j] -= this.getResidualElement(i); // fetches resid[]

	      for (var i = 0; i < this.NPTS; i++) this.jac[i][j] *= FACTOR;

	      for (var k = 0; k < this.NPARMS; k++) delta[k] = k == j ? this.DELTAP : 0.0;

	      d = this.nudge(delta);
	      if (d == this.BIGVAL) {
	        throw 'Bad dBuildJacobian(). exit 4';
	      }
	    }
	    return true;
	  }

	  getResidualElement(i) {
	    // Allows LM to see one element of the resid[] vector.
	    return this.resid[i];
	  }

	  getJacobianElement(i, j) {
	    // Allows LM to see one element of the Jacobian matrix.
	    return this.jac[i][j];
	  }

	  buildFit(parms, length) {
	    let x;

	    if (!length) {
	      x = this.arrX;
	    } else {

	      const xmin = this.dataX.getMin(this._from, this._to);
	      const xmax = this.dataX.getMax(this._from, this._to);

	      x = new Array(length).fill(0).map((el, index) => index * (xmax - xmin) / (length - 1) + xmin);
	    }

	    var fit = new Array(x.length);
	    for (var i = 0, l = x.length; i < l; i++) {
	      fit[i] = this.func(x[i], this.parms);
	    }

	    let waveformResult = this.options.waveform;
	    waveformResult.setData(fit, x);
	    //waveformResult.setXWaveform( x );

	    return waveformResult;
	  }
	}

	class LM {

	  constructor(gH, gnadj, gnpnts, hook) {

	    this.LMITER = 100; // max number of L-M iterations
	    this.LMBOOST = 2.0; // damping increase per failed step
	    this.LMSHRINK = 0.10; // damping decrease per successful step
	    this.LAMBDAZERO = 0.001; // initial damping
	    this.LAMBDAMAX = 1E9; // max damping
	    this.LMTOL = 1E-12; // exit tolerance
	    this.BIGVAL = 9e99; // trouble flag

	    this.sos;
	    this.sosprev;
	    this.lambda;

	    this.myH = null; // overwritten by constructor
	    this.nadj = 0; // overwritten by constructor
	    this.npts = 0; // overwritten by constructor

	    this.delta; // local parm change
	    this.beta;
	    this.alpha;
	    this.amatrix;

	    // Constructor sets up fields and drives iterations.
	    this.myH = gH;
	    this.nadj = gnadj;
	    this.npts = gnpnts;

	    this.delta = new Array(this.nadj).fill(0);
	    this.beta = new Array(this.nadj).fill(0);

	    this.alpha = new Array(this.nadj).fill(0);
	    this.amatrix = new Array(this.nadj).fill(0);

	    this.alpha = this.alpha.map(() => new Array(this.nadj));
	    this.amatrix = this.amatrix.map(() => new Array(this.nadj));

	    this.lambda = this.LAMBDAZERO;

	    var niter = 0;
	    var done = false;
	    do {
	      done = this.bLMiter();

	      if (hook) {
	        hook(this.myH.params);
	      }

	      niter++;
	    } while (!done && niter < this.LMITER);
	  }

	  bLMiter() {
	    // Each call performs one LM iteration.
	    // Returns true if done with iterations; false=wants more.
	    // Global nadj, npts; needs nadj, myH to be preset.
	    // Ref: M.Lampton, Computers in Physics v.11 pp.110-115 1997.
	    for (var k = 0; k < this.nadj; k++) this.delta[k] = 0.0;
	    this.sos = this.myH.nudge(this.delta);
	    if (this.sos == this.BIGVAL) {
	      console.error('  bLMiter finds faulty initial nudge()');
	      return false;
	    }
	    this.sosprev = this.sos;

	    this.myH.log('  bLMiter..SumOfSquares= ' + this.sos);
	    if (!this.myH.buildJacobian()) {
	      console.error('  bLMiter finds buildJacobian()=false');
	      return false;
	    }

	    for (var k = 0; k < this.nadj; k++) // get downhill gradient beta
	    {
	      this.beta[k] = 0.0;
	      for (var i = 0; i < this.npts; i++) {
	        this.beta[k] -= this.myH.getResidualElement(i) * this.myH.getJacobianElement(i, k);
	      }
	    }

	    for (var k = 0; k < this.nadj; k++) // get curvature matrix alpha
	    for (var j = 0; j < this.nadj; j++) {
	      this.alpha[j][k] = 0.0;
	      for (var i = 0; i < this.npts; i++) {
	        this.alpha[j][k] += this.myH.getJacobianElement(i, j) * this.myH.getJacobianElement(i, k);
	      }
	    }
	    var rrise = 0;
	    do // inner damping loop searches for one downhill step
	    {
	      for (var k = 0; k < this.nadj; k++) {
	        // copy and damp it
	        for (var j = 0; j < this.nadj; j++) {
	          this.amatrix[j][k] = this.alpha[j][k] + (j == k ? this.lambda : 0.0);
	        }
	      }

	      this.gaussj(this.amatrix, this.nadj); // invert

	      for (var k = 0; k < this.nadj; k++) // compute delta[]
	      {
	        this.delta[k] = 0.0;
	        for (var j = 0; j < this.nadj; j++) this.delta[k] += this.amatrix[j][k] * this.beta[j];
	      }
	      this.sos = this.myH.nudge(this.delta); // try it out.
	      if (this.sos == this.BIGVAL) {
	        console.error('  LMinner failed SOS step');
	        return false;
	      }
	      rrise = (this.sos - this.sosprev) / (1 + this.sos);
	      if (rrise <= 0.0) // good step!
	        {
	          this.lambda *= this.LMSHRINK; // shrink lambda
	          break; // leave lmInner.
	        }
	      for (var q = 0; q < this.nadj; q++) {
	        // reverse course!
	        this.delta[q] *= -1.0;
	      }
	      this.myH.nudge(this.delta); // sosprev should still be OK
	      if (rrise < this.LMTOL) {
	        // finished but keep prev parms
	        break; // leave inner loop
	      }
	      this.lambda *= this.LMBOOST; // else try more damping.
	    } while (this.lambda < this.LAMBDAMAX);
	    return rrise > -this.LMTOL || this.lambda > this.LAMBDAMAX;
	  }

	  gaussj(a, N) {
	    // Inverts the double array a[N][N] by Gauss-Jordan method
	    // M.Lampton UCB SSL (c)2003, 2005

	    var det = 1.0,
	        big,
	        save;
	    var i, j, k, L;
	    var ik = new Array(100);
	    var jk = new Array(100);

	    for (k = 0; k < N; k++) {
	      big = 0.0;
	      for (i = k; i < N; i++) for (j = k; j < N; j++) // find biggest element
	      if (Math.abs(big) <= Math.abs(a[i][j])) {
	        big = a[i][j];
	        ik[k] = i;
	        jk[k] = j;
	      }
	      if (big == 0.0) return 0.0;
	      i = ik[k];
	      if (i > k) for (j = 0; j < N; j++) // exchange rows
	      {
	        save = a[k][j];
	        a[k][j] = a[i][j];
	        a[i][j] = -save;
	      }
	      j = jk[k];
	      if (j > k) for (i = 0; i < N; i++) {
	        save = a[i][k];
	        a[i][k] = a[i][j];
	        a[i][j] = -save;
	      }
	      for (i = 0; i < N; i++) // build the inverse
	      if (i != k) a[i][k] = -a[i][k] / big;
	      for (i = 0; i < N; i++) for (j = 0; j < N; j++) if (i != k && j != k) a[i][j] += a[i][k] * a[k][j];
	      for (j = 0; j < N; j++) if (j != k) a[k][j] /= big;
	      a[k][k] = 1.0 / big;
	      det *= big; // bomb point
	    } // end k loop
	    for (L = 0; L < N; L++) {
	      k = N - L - 1;
	      j = ik[k];
	      if (j > k) for (i = 0; i < N; i++) {
	        save = a[i][k];
	        a[i][k] = -a[i][j];
	        a[i][j] = save;
	      }
	      i = jk[k];
	      if (i > k) for (j = 0; j < N; j++) {
	        save = a[k][j];
	        a[k][j] = -a[i][j];
	        a[i][j] = save;
	      }
	    }
	    return det;
	  }
	}


	//module.export = FitHost

	class Waveform {

	  constructor(data = [], xOffset = 0, xScale = 1) {

	    this.xOffset = xOffset;
	    this.xScale = xScale;

	    // Error bar handling
	    this.errors = {

	      nb: 0,

	      bars: {
	        above: null,
	        below: null
	      },

	      boxes: {
	        above: null,
	        below: null
	      }
	    };

	    this.BELOW = Waveform.BELOW;
	    this.ABOVE = Waveform.ABOVE;
	    this.BOX = Waveform.BOX;
	    this.BAR = Waveform.BAR;

	    this.setData(data);
	  }

	  /** [ [ x1, y1 ], [ x2, y2 ] ] */

	  /*
	  setDataXY( data ) {
	     let newData = [ this._makeArray( data.length ), this._makeArray( data.length ) ],
	      warnNaN = false;
	    const nanable = this.isNaNAllowed();
	     data.map( ( el, index ) => {
	       if ( !nanable && ( el[ 0 ] !== el[ 0 ] || el[ 1 ] !== el[ 1 ] ) ) {
	        warnNaN = true;
	      }
	       newData[ 0 ][ index ] = el[ 0 ];
	      newData[ 1 ][ index ] = el[ 1 ];
	    } );
	     if ( warnNaN ) {
	      this.warn( "Trying to assign NaN values to a typed array that does not support NaNs. 0's will be used instead" );
	    }
	     this._setData( ...newData );
	    return this;
	  }
	  */
	  setData(data, dataX = null) {

	    /* First, we must treat the case of the array of array for backward compatibility */
	    if (Array.isArray(data[0])) {
	      let x = [];
	      let y = [];
	      data.forEach(el => {
	        x.push(el[0]);
	        y.push(el[1]);
	      });

	      this.setXWaveform(x);
	      data = y;
	    }

	    let newData = this._makeArray(data.length),
	        warnNaN = false;

	    const nanable = this.isNaNAllowed();

	    data.map((el, index) => {

	      if (!nanable && (el[0] !== el[0] || el[1] !== el[1])) {
	        warnNaN = true;
	      }

	      newData[index] = el;
	    });

	    if (warnNaN) {
	      this.warn("Trying to assign NaN values to a typed array that does not support NaNs. 0's will be used instead");
	    }

	    this._setData(newData);

	    if (dataX) {
	      this.setXWaveform(dataX);
	    }
	    return this;
	  }

	  getY(index, optimized) {

	    if (optimized && this.dataInUse) {
	      return this.dataInUse.y[index] * this.getScale() + this.getShift();
	    }

	    return this.data[index] * this.getScale() + this.getShift();
	  }

	  /*
	    flipXY() {
	      let temp;
	      temp = this.data.x;
	      this.data.x = this.data.y;
	      this.data.y = temp;
	       this._setData( this.data.x, this.data.y );
	    }*/

	  setXWaveform(waveform) {

	    if (!(waveform instanceof Waveform)) {

	      if (Array.isArray(waveform)) {
	        waveform = new Waveform(waveform);
	      } else {
	        throw "Cannot set X waveform. Data is not a valid array.";
	      }
	    }

	    this.xdata = waveform;
	    this.computeXMinMax();
	    return this;
	  }

	  hasXWaveform() {
	    return !!this.xdata;
	  }

	  getXWaveform() {
	    if (this.xdata) {
	      return this.xdata;
	    }

	    var wave = new Waveform();
	    for (var i = 0; i < this.getLength(); i += 1) {
	      wave.append(this.getX(i));
	    }
	    return wave;
	  }

	  rescaleX(offset, scale) {
	    this.xScale = scale;
	    this.xOffset = offset;
	    this.computeXMinMax();
	    return this;
	  }

	  getTypedArrayClass() {
	    return this._typedArrayClass || false;
	  }

	  setTypedArrayClass(constructor) {

	    if (this.getTypedArrayClass() && this.isNaNAllowed() && !this.isNaNAllowed(constructor)) {
	      this.warn("NaN values are not allowed by the new constructor (" + constructor.name + ") while it was allowed by the previous one (" + this._typedArrayClass.name + ")");
	    }

	    if (this.getTypedArrayClass() && this.isUnsigned() && !this.isUnsigned(constructor)) {
	      this.warn("You are switching from signed values to unsigned values. You may experience data corruption if there were some negative values.");
	    }

	    this._typedArrayClass = constructor;

	    if (this.data) {
	      this._setData(constructor.from(this.data));
	    }

	    if (this.hasXWaveform()) {
	      this.getXWaveform().setTypedArrayClass(constructor);
	    }
	  }

	  isNaNAllowed(constructor = this._typedArrayClass) {

	    // The following types accept NaNs
	    return constructor == Array || constructor == Float32Array || constructor == Float64Array;
	  }

	  isUnsigned(constructor = this._typedArrayClass) {

	    // The following types accept NaNs
	    return constructor == Uint8Array || constructor == Uint8ClampedArray || constructor == Uint16Array || constructor == Uint32Array;
	  }

	  recalculateMinMaxNewPoint(x, y) {
	    if (x < this.minX || this.minX === undefined) {
	      this.minX = x;
	    }

	    if (x > this.maxX || this.maxX === undefined) {
	      this.maxX = x;
	    }

	    if (y < this.minY || this.minY === undefined) {
	      this.minY = y;
	    }

	    if (y > this.maxY || this.maxY === undefined) {
	      this.maxY = y;
	    }
	  }

	  prepend(x, y) {

	    if (typeof x == "function") {
	      x = x(this);
	    }

	    if (typeof y == "function") {
	      y = y(this);
	    }

	    if (this.xdata) {
	      this.xdata.prepend(null, x);
	    } else if (x !== null) {
	      this.xdata = this.getXWaveform();
	      this.xdata.prepend(null, x);
	    } else {
	      this.xOffset -= this.xScale;
	    }

	    this.data.unshift(y);
	    this.recalculateMinMaxNewPoint(x, y);
	    return this;
	  }

	  append(x, y) {

	    if (typeof x == "function") {
	      x = x(this);
	    }

	    if (typeof y == "function") {
	      y = y(this);
	    }

	    if (this.xdata) {
	      this.xdata.append(null, x);
	    } else if (x !== null) {
	      this.xdata = this.getXWaveform();
	      this.xdata.append(null, x);
	    }

	    if (this.monotoneous) {
	      if (y > this.data[this.data.y] && this.getMonotoneousAscending() === false) {
	        this.monotoneous = false;
	      } else if (y < this.data[this.data.y] && this.getMonotoneousAscending() === true) {
	        this.monotoneous = false;
	      }
	    }

	    if (this.data.length == 1 || this._monotoneousAscending === undefined) {

	      this.monotoneous = true;

	      if (y == this.data[0]) {
	        this._monotoneousAscending = undefined;
	      } else {
	        this._monotoneousAscending = y > this.data[0];
	      }
	    }

	    this.data.push(y);
	    this.recalculateMinMaxNewPoint(x, y);

	    return this;
	  }

	  _makeArray(length) {

	    const constructor = this.getTypedArrayClass();
	    if (constructor) {
	      return new constructor(length);
	    }
	    return new Array(length);
	  }

	  _setData(dataY) {
	    const l = dataY.length;
	    let i = 1,
	        monoDir = dataY[1] > dataY[0],
	        minY = dataY[0],
	        maxY = dataY[0];

	    this._monotoneous = true;

	    for (; i < l; i++) {
	      if (dataY[i] !== dataY[i - 1] && monoDir !== dataY[i] > dataY[i - 1]) {
	        this._monotoneous = false;
	      }

	      if (dataY[i] === dataY[i]) {
	        // NaN support
	        minY = Math.min(dataY[i], minY);
	        maxY = Math.max(dataY[i], maxY);
	      }
	    }

	    if (this._monotoneous) {
	      this._monotoneousAscending = dataY[1] > dataY[0];
	    }

	    if (this.hasErrorBars()) {
	      // If prefer to loop again here

	      for (i = 0; i < l; i++) {

	        if (dataY[i] === dataY[i]) {
	          // NaN support

	          minY = Math.min(minY, dataY[i] - this.getMaxError(i, 'below'));
	          maxY = Math.max(maxY, dataY[i] + this.getMaxError(i, 'above'));
	        }
	      }

	      this.minY = minY;
	      this.maxY = maxY;
	    } else {
	      this.minY = minY;
	      this.maxY = maxY;
	    }

	    this.data = dataY;

	    this.computeXMinMax();
	  }

	  computeXMinMax() {

	    if (!this.data) {

	      return;
	    }

	    if (this.xdata) {

	      this.minX = this.xdata.getMin();
	      this.maxX = this.xdata.getMax();
	    } else {

	      const b1 = this.xOffset + this.xScale * this.getLength(),
	            b2 = this.xOffset;

	      this.minX = Math.min(b1, b2);
	      this.maxX = Math.max(b1, b2);
	    }
	  }

	  getDataInUse() {
	    return this.dataInUse || this.data;
	  }

	  getIndexFromVal(val, useDataToUse = false, roundingMethod = Math.round) {

	    let data;

	    if (useDataToUse && this.dataInUse) {
	      data = this.dataInUse.y;
	    } else {
	      data = this.data;
	    }

	    let position;

	    position = this.getIndexFromData(val, data, this.data.getMonotoneousAscending(), roundingMethod);

	    if (useDataToUse && this.dataInUse && this.dataInUseType == "aggregateY") {
	      // In case of aggregation, round to the closest element of 4.
	      return position - position % 4;
	    }

	    return position;
	  }

	  getIndexFromX(xval, useDataToUse = false, roundingMethod = Math.round) {

	    let xdata;

	    if (useDataToUse && this.dataInUse) {
	      xdata = this.dataInUse.x;
	    } else if (this.xdata) {
	      xdata = this.xdata.getData();
	    }

	    let position;

	    if (this.hasXWaveform()) {
	      position = this.xdata.getIndexFromData(xval, xdata, this.xdata.getMonotoneousAscending(), roundingMethod);
	    } else {
	      position = Math.max(0, Math.min(this.getLength() - 1, roundingMethod((xval - this.xOffset) / this.xScale)));
	    }

	    if (useDataToUse && this.dataInUse && this.dataInUseType == "aggregateX") {
	      // In case of aggregation, round to the closest element of 4.
	      return position - position % 4;
	    }

	    return position;
	  }

	  getIndexFromXY(xval, yval, useDataToUse = false, roundingMethod = Math.round, scaleX, scaleY) {

	    let xdata, ydata;

	    if (useDataToUse && this.dataInUse) {

	      xdata = this.dataInUse.x;
	      ydata = this.dataInUse.y;
	    } else if (this.xdata) {

	      xdata = this.xdata.data;
	      ydata = this.data;
	    }

	    let position;

	    if (this.isXMonotoneous()) {
	      // X lookup only

	      if (this.hasXWaveform()) {
	        // The x value HAS to be rescaled
	        position = this.xdata.getIndexFromData(xval, xdata, this.xdata.getMonotoneousAscending(), roundingMethod);
	      } else {
	        position = Math.max(0, Math.min(this.getLength() - 1, roundingMethod((xval - this.xOffset) / this.xScale)));
	      }
	    } else if (!isNaN(yval)) {

	      position = this.getIndexFromDataXY(xval, xdata, yval, ydata, scaleX, scaleY);
	    } else {
	      return;
	    }

	    if (useDataToUse && this.dataInUse && this.dataInUseType == 'aggregateX') {
	      // In case of aggregation, round to the closest element of 4.
	      return position - position % 4;
	    }

	    return position;
	  }

	  getIndexFromDataXY(valX, dataX, valY, dataY, scaleX = 1, scaleY = 1) {

	    valX -= this.getXShift();
	    valX /= this.getXScale();

	    valY -= this.getShift();
	    valY /= this.getScale();

	    return euclidianSearch(valX, valY, dataX, dataY, scaleX, scaleY);
	  }

	  getIndexFromData(val, valCollection, isAscending, roundingMethod) {

	    if (!this.isMonotoneous()) {
	      console.trace();
	      throw "Impossible to get the index from a non-monotoneous wave !";
	    }

	    val -= this.getShift();
	    val /= this.getScale();

	    return binarySearch(val, valCollection, !isAscending);
	  }

	  getReductionType() {
	    return this.dataInUseType;
	  }

	  getXMin() {
	    return this.minX * this.getXScale() + this.getXShift();
	  }

	  getXMax() {
	    return this.maxX * this.getXScale() + this.getXShift();
	  }

	  getYMin() {
	    return this.minY * this.getScale() + this.getShift();
	  }

	  getYMax() {
	    return this.maxY * this.getScale() + this.getShift();
	  }

	  getMin() {
	    return this.minY * this.getScale() + this.getShift();
	  }

	  getMax() {
	    return this.maxY * this.getScale() + this.getShift();
	  }

	  getMinX() {

	    return this.minX * this.getXScale() + this.getXShift();
	  }

	  getMaxX() {
	    return this.maxX * this.getXScale() + this.getXShift();
	  }

	  getMinY() {
	    return this.minY * this.getScale() + this.getShift();
	  }

	  getMaxY() {
	    return this.maxY * this.getScale() + this.getShift();
	  }

	  getDataY() {
	    return this.data;
	  }

	  getData(optimized) {
	    if (!optimized || !this.dataInUse) {
	      return this.data;
	    }
	    return this.dataInUse.y;
	  }

	  setShift(shift = 0) {

	    // We must update the min and the max of the y data
	    //this.minY += ( shift - this.getShift() );
	    //this.maxY += ( shift - this.getShift() );
	    this.shift = shift;
	    return this;
	  }

	  getShift() {
	    return this.shift || 0;
	  }

	  getScale() {
	    return this.scale || 1;
	  }

	  setScale(scale = 1) {

	    // this.minY = ( this.minY - this.getShift() ) * scale;
	    // this.maxY = ( this.maxY - this.getShift() ) * scale;
	    this.scale = scale;
	    return this;
	  }

	  setXShift(shift = 0) {

	    if (!this.hasXWaveform) {
	      return this;
	    }

	    // We must update the min and the max of the x data
	    // That's important for when the data has already been set
	    //  this.minX += ( shift - this.getXShift() );
	    //    this.maxX += ( shift - this.getXShift() );
	    this.getXWaveform().setShift(shift);
	    return this;
	  }

	  getXShift(shift = 0) {

	    if (!this.hasXWaveform) {
	      return 0;
	    }

	    return this.getXWaveform().getShift();
	  }

	  setXScale(scale = 1) {

	    if (!this.hasXWaveform) {
	      return this;
	    }

	    this.getXWaveform().setScale(scale);
	    return this;
	  }

	  getXScale() {

	    if (!this.hasXWaveform) {
	      return 1;
	    }

	    return this.getXWaveform().getScale();
	  }

	  getLength() {
	    return this.data.length;
	  }

	  getDataToUseFlat() {

	    let l;
	    let j = 0;
	    let arr;

	    if (this.dataInUse) {

	      l = this.dataInUse.x.length;
	      arr = new Array(l * 2).fill(0);

	      for (var i = 0; i < l; i += 1) {
	        arr[j] = this.dataInUse.x[i];
	        arr[j + 1] = this.dataInUse.y[i];
	        j += 2;
	      }
	    } else {

	      l = this.getLength();
	      arr = new Array(l * 2).fill(0);
	      for (var i = 0; i < l; i += 1) {
	        arr[j + 1] = this.data[i];
	        arr[j] = this.getX(i);
	        j += 2;
	      }
	    }

	    return arr;
	  }

	  fit(options) {

	    var self = this;

	    return new Promise(function (resolver, rejector) {

	      var fit = new FitHost(extend$2({}, {

	        dataY: self,
	        dataX: self.getXWaveform(),
	        done: function (results) {
	          resolver(results);
	        },
	        waveform: new Waveform()

	      }, options));

	      fit.init();
	      fit.fit();
	    });
	  }

	  getX(index, optimized) {

	    if (optimized && this.dataInUse) {
	      return this.dataInUse.x[index] * this.getXScale() + this.getXShift();
	    }

	    if (this.xdata) {
	      return this.xdata.data[index] * this.getXScale() + this.getXShift();
	    } else {
	      return this.xOffset + index * this.xScale;
	    }
	  }

	  getXRaw(index, optimized) {

	    if (optimized && this.dataInUse) {
	      return this.dataInUse.x[index];
	    }

	    if (this.xdata) {
	      return this.xdata.data[index];
	    } else {
	      return index;
	    }
	  }

	  _integrateP(from = 0, to = this.getLength() - 1) {

	    from = Math.round(from);
	    to = Math.round(to);

	    if (from > to) {
	      let temp = from;
	      from = to;
	      to = temp;
	    }

	    var l = to - from + 1;
	    var sum = 0;

	    let deltaTot = 0;
	    let diff;
	    var arrY = this.getData();

	    for (; from <= to; from++) {

	      if (arrY.length - 1 > from) {
	        diff = this.getX(from + 1) - this.getX(from);
	        deltaTot += diff;
	        sum += arrY[from] * diff;
	      }
	    }

	    return [sum, l, deltaTot];
	  }

	  integrateP(from, to) {
	    var val = this._integrateP(from, to);
	    return val[0];
	  }

	  integrate(fromX, toX) {
	    return this.integrateP(this.getIndexFromX(fromX), this.getIndexFromX(toX));
	  }

	  average(p0 = 0, p1 = this.getLength() - 1) {
	    return this.getAverageP(p0, p1);
	  }

	  mean() {
	    return this.average();
	  }

	  getAverageP(from, to) {
	    var sum = this._integrateP(from, to);
	    return sum[0] / sum[2];
	  }

	  getAverageX(from, to) {
	    var sum = this._integrateX(from, to);
	    return sum[0] / sum[2];
	  }

	  checkMonotonicity() {

	    let i = 1,
	        data = this.getData();
	    const l = this.data.length;
	    let dir = data[1] > data[0];

	    for (; i < l; i++) {
	      if (data[i] !== data[i - 1] && dir !== data[i] > data[i - 1]) {
	        return this._monotoneous = false;
	      }
	    }

	    this._monotoneousAscending = data[1] > data[0];
	    return this._monotoneous = true;
	  }

	  requireXMonotonicity() {
	    if (this.xdata) {
	      this.xdata.requireMonotonicity();
	    }
	  }

	  requireMonotonicity() {
	    if (!this.isMonotoneous()) {
	      throw "The wave must be monotonic";
	    }
	  }

	  isMonotoneous() {
	    return !!this._monotoneous;
	  }

	  isXMonotoneous() {
	    if (this.xdata) {
	      return this.xdata.isMonotoneous();
	    }
	    // Offset and scale is always monotoneous
	    return true;
	  }

	  invert(data) {

	    let d = dataY || this.data;
	    d.reverse();

	    if (this.isMonotoneous()) {
	      this._monotoneousAscending = !this._monotoneousAscending;
	    }

	    return d;
	  }

	  resampleForDisplay(options) {
	    // Serie redrawing

	    let i = 0;

	    this.requireXMonotonicity();

	    let inverting = false,
	        dataY = this.getDataY(),
	        data = {
	      x: [],
	      y: []
	    },
	        dataMinMax = [],
	        resampleSum,
	        resampleMin,
	        resampleMax,
	        resampleNum,
	        resample_x_start,
	        resample_x_px_start,
	        x_px,
	        doing_mean = false,
	        firstPointIndex = 0,
	        xval;

	    const l = this.getLength();

	    if (!options.xPosition) {
	      throw "No position calculation method provided";
	    }

	    if (!options.resampleToPx) {
	      throw "No \"resampleToPx\" method was provided. Unit: px per point";
	    }

	    if (options.minX > options.maxX) {
	      let temp = options.minX;
	      options.minX = options.maxX;
	      options.maxX = temp;
	    }

	    if (this.xdata && !this.xdata.getMonotoneousAscending() || !this.xdata && this.xScale < -0) {
	      inverting = true;
	      i = l;
	    }

	    for (; inverting ? i > 0 : i < l; inverting ? i-- : i++) {

	      xval = this.getX(i);

	      if (options.minX > xval) {

	        firstPointIndex = i;
	        continue;
	      }

	      x_px = options.xPosition(xval);

	      if (!doing_mean) {

	        if (!firstPointIndex) {

	          firstPointIndex = i;
	        } else {

	          data.x.push(xval);
	          data.y.push(dataY[firstPointIndex]);
	        }

	        while (isNaN(dataY[i])) {

	          if (inverting) {
	            i--;
	          } else {
	            i++;
	          }
	        }

	        resampleSum = resampleMin = resampleMax = dataY[firstPointIndex];
	        resampleNum = 1;
	        resample_x_px_start = x_px;
	        resample_x_start = xval;
	        firstPointIndex = 0;

	        doing_mean = true;

	        continue;
	      }

	      if (Math.abs(x_px - resample_x_px_start) > options.resampleToPx || i == l || i == 0 || isNaN(dataY[i])) {

	        let xpos = (resample_x_start + xval) / 2;

	        data.x.push(xpos);
	        data.y.push(resampleSum / resampleNum);

	        dataMinMax.push(xpos, resampleMin, resampleMax);

	        if (options.maxX !== undefined && xval > options.maxX) {

	          break;
	        }

	        doing_mean = false;

	        continue;
	      }

	      resampleSum += dataY[i];
	      resampleNum++;

	      resampleMin = Math.min(resampleMin, dataY[i]);
	      resampleMax = Math.max(resampleMax, dataY[i]);
	    }

	    this.dataInUseType = "resampled";
	    this.dataInUse = data;
	    return dataMinMax;
	  }

	  interpolate(x) {

	    let yData = this.getDataY();
	    let xIndex;

	    if (this.xdata) {
	      let xData = this.xdata.getData();
	      xIndex = binarySearch(x, xData, !this.xdata.getMonotoneousAscending());
	      if (xData[xIndex] == x) {
	        return yData[xIndex];
	      }
	      return (x - xData[xIndex]) / (xData[xIndex + 1] - xData[xIndex]) * (yData[xIndex + 1] - yData[xIndex]) + yData[xIndex];
	    } else {
	      xIndex = (x - this.xOffset) / this.xScale;
	      let xIndexF = Math.floor(xIndex);
	      return (xIndex - xIndexF) * (yData[xIndexF + 1] - yData[xIndexF]) + yData[xIndexF];
	    }
	  }

	  interpolateIndex_X(index) {

	    let yData = this.getDataY();
	    if (this.xdata) {
	      let xData = this.xdata.getData();
	      let indexStart = Math.floor(index);

	      return (index - indexStart) * (xData[indexStart + 1] - xData[indexStart]) + xData[indexStart];
	    }
	  }

	  getMonotoneousAscending() {

	    if (!this.isMonotoneous()) {
	      return "The waveform is not monotoneous";
	    }

	    return this._monotoneousAscending;
	  }

	  getXMonotoneousAscending() {
	    if (this.xdata) {
	      return this.xdata.getMonotoneousAscending();
	    }

	    return this.xScale > 0;
	  }

	  isXMonotoneousAscending() {
	    return this.getXMonotoneousAscending(...arguments);
	  }

	  divide(numberOrWave) {
	    return this._arithmetic(numberOrWave, DIVIDE);
	  }

	  divideBy() {
	    return this.divide(...arguments);
	  }

	  multiply(numberOrWave) {
	    return this._arithmetic(numberOrWave, MULTIPLY);
	  }

	  multiplyBy() {
	    return this.multiply(...arguments);
	  }

	  log() {
	    return this.logBase(10);
	  }

	  ln() {
	    return this.logBase(Math.E);
	  }

	  logBase(base) {

	    let logBase = Math.log(base);
	    this.data.map(valY => {

	      return Math.log(valY) / logBase;
	    });
	  }

	  add(numberOrWave) {
	    return this._arithmetic(numberOrWave, ADD);
	  }

	  addBy() {
	    return this.add(...arguments);
	  }

	  subtract(numberOrWave) {
	    return this._arithmetic(numberOrWave, SUBTRACT);
	  }

	  subtractBy() {
	    return this.subtract(...arguments);
	  }

	  math(method) {

	    for (var i = 0; i < this.getLength(); i++) {
	      this.data[i] = method(this.getY(i), this.getX(i));
	    }

	    this._setData(this.data);
	    return this;
	  }

	  _arithmetic(numberOrWave, operator) {

	    if (numberOrWave instanceof Waveform) {
	      return this._waveArithmetic(numberOrWave, operator);
	    } else if (typeof numberOrWave == 'number') {

	      return this._numberArithmetic(numberOrWave, operator);
	    }
	  }

	  _numberArithmetic(num, operation) {

	    let i = 0,
	        l = this.getLength();

	    if (operation == MULTIPLY) {

	      for (; i < l; i++) {
	        this.data[i] *= num;
	      }

	      this.minY *= num;
	      this.maxY *= num;
	    } else if (operation == DIVIDE) {

	      for (; i < l; i++) {
	        this.data[i] /= num;
	      }

	      this.minY /= num;
	      this.maxY /= num;
	    } else if (operation == ADD) {

	      for (; i < l; i++) {
	        this.data[i] += num;
	      }

	      this.minY += num;
	      this.maxY += num;
	    } else if (operation == SUBTRACT) {

	      for (; i < l; i++) {
	        this.data[i] -= num;
	      }

	      this.minY -= num;
	      this.maxY -= num;
	    }

	    return this;
	  }

	  _waveArithmetic(wave, operation) {

	    let yDataThis = this.getDataY(),
	        i = 0;
	    const l = this.getLength();
	    this.requireXMonotonicity();
	    wave.requireXMonotonicity();

	    if (operation == MULTIPLY) {

	      for (; i < l; i++) {
	        yDataThis[i] *= wave.interpolate(this.getX(i));
	      }
	    } else if (operation == DIVIDE) {

	      for (; i < l; i++) {
	        yDataThis[i] /= wave.interpolate(this.getX(i));
	      }
	    } else if (operation == ADD) {

	      for (; i < l; i++) {
	        yDataThis[i] += wave.interpolate(this.getX(i));
	      }
	    } else if (operation == SUBTRACT) {

	      for (; i < l; i++) {
	        yDataThis[i] -= wave.interpolate(this.getX(i));
	      }
	    }

	    this._setData(yDataThis);
	    return this;
	  }

	  aggregate(direction = 'x') {

	    this._dataAggregating = {};
	    this._dataAggregated = {};
	    this._dataAggregationDirection = direction.toUpperCase();

	    var pow2 = pow2floor(this.getLength());

	    this._dataAggregating = aggregator({

	      minX: this.minX,
	      maxX: this.maxX,
	      minY: this.minY,
	      maxY: this.maxY,
	      data: this.data,
	      xdata: this.xdata ? this.xdata.getData() : undefined,
	      xScale: this.xScale,
	      xOffset: this.xOffset,
	      numPoints: pow2,
	      direction: direction

	    }).then(event => {

	      this._dataAggregated = event.aggregates;
	      this._dataAggregating = false;
	    });
	  }

	  hasAggregation() {
	    return !!this._dataAggregated;
	  }

	  selectAggregatedData(pxWidth) {

	    if (pxWidth < 2) {
	      return false;
	    }
	    /*
	    console.log( direction, this._dataAggregationDirection );
	         if( direction !== this._dataAggregationDirection ) {
	          throw "The data is not aggregated in that direction";
	        }
	    */

	    var level = pow2ceil(pxWidth);

	    if (this._dataAggregated[level]) {

	      this.dataInUseType = "aggregate" + this._dataAggregationDirection;
	      this.dataInUse = this._dataAggregated[level];
	      return;
	    } else if (this._dataAggregating) {

	      return this._dataAggregating;
	    }

	    this.dataInUseType = "none";
	    this.dataInUse = {
	      y: this.data,
	      x: this.getXWaveform().data
	    };
	  }

	  duplicate(alsoDuplicateXWave) {
	    var newWaveform = new Waveform();
	    newWaveform._setData(this.getDataY().slice());
	    newWaveform.rescaleX(this.xOffset, this.xShift);
	    newWaveform.setShift(this.getShift());
	    newWaveform.setScale(this.getScale());

	    if (this.xdata) {
	      if (alsoDuplicateXWave) {
	        newWaveform.setXWaveform(this.xdata.duplicate());
	      } else {
	        newWaveform.setXWaveform(this.xdata);
	      }

	      newWaveform.setXShift(this.getXShift());
	      newWaveform.setXScale(this.getXScale());
	    } else {
	      newWaveform.xOffset = this.xOffset;
	      newWaveform.xScale = this.xScale;
	    }

	    return newWaveform;
	  }

	  subrangeX(fromX, toX) {

	    if (!this.xdata) {
	      // We can select the new range from there

	      let fromP = this.getIndexFromX(fromX),
	          toP = this.getIndexFromX(toP);

	      return new Waveform().setData(this.data.slice(fromP, toP)).rescaleX(this.xOffset, this.xScale);
	    } else {

	      var waveform = new Waveform();

	      for (var i = 0, l = this.data.length; i < l; i++) {

	        if (this.data[i] >= fromX && this.data[i] < toX) {

	          waveform.append(this.dataX[i], this.data[i]);
	        }
	      }

	      return waveform;
	    }
	  }

	  findLocalMinMax(xRef, xWithin, type) {

	    let index = this.getIndexFromX(xRef),
	        indexPlus = this.getIndexFromX(xRef + xWithin),
	        indexMinus = this.getIndexFromX(xRef - xWithin);

	    return this.findLocalMinMaxIndex(indexMinus, indexPlus, type);
	  }

	  findLocalMinMaxIndex(indexMinus, indexPlus, type) {

	    let tmp;

	    if (indexPlus < indexMinus) {
	      tmp = indexPlus;
	      indexPlus = indexMinus;
	      indexMinus = tmp;
	    }

	    let curr, currI;

	    if (type == 'max') {

	      curr = Number.NEGATIVE_INFINITY;

	      for (var i = indexMinus; i <= indexPlus; i++) {

	        if (this.getY(i) > curr) {
	          curr = this.getY(i);
	          currI = i;
	        }
	      }
	    } else {

	      curr = Number.POSITIVE_INFINITY;

	      for (var i = indexMinus; i <= indexPlus; i++) {

	        if (this.getY(i) < curr) {
	          curr = this.getY(i);
	          currI = i;
	        }
	      }
	    }

	    if (currI == indexMinus || currI == indexPlus) {
	      return false;
	    }

	    return this.getX(currI);
	  }

	  warn(text) {
	    if (console) {
	      console.warn(text);
	    }
	  }

	  setUnit(unit) {
	    this.unit = unit;
	    return this;
	  }

	  setXUnit(unit) {
	    if (this.hasXWaveform()) {
	      this.xdata.setUnit(unit);
	    }

	    this.xunit = unit;
	    return this;
	  }

	  getUnit() {
	    return this.unit || "";
	  }

	  getXUnit() {
	    if (this.hasXWaveform()) {
	      return this.xdata.getUnit();
	    }

	    return this.xunit | "";
	  }

	  hasXUnit() {
	    return this.getXUnit().length > 0;
	  }

	  hasUnit() {
	    return this.getUnit().length > 0;
	  }

	  findLevels(level, options) {

	    options = extend$2({

	      box: 1,
	      edge: 'both',
	      rounding: 'before',
	      rangeP: [0, this.getLength()]

	    }, options);

	    var lastLvlIndex = options.rangeP[0];
	    var lvlIndex;
	    var indices = [];
	    var i = 0;

	    while (lvlIndex = this.findLevel(level, extend$2(true, {}, options, {
	      rangeP: [lastLvlIndex, options.rangeP[1]]
	    }))) {
	      indices.push(lvlIndex);
	      lastLvlIndex = Math.ceil(lvlIndex);

	      i++;
	      if (i > 1000) {
	        return;
	      }
	    }

	    return indices;
	  }

	  // Find the first level in the specified range
	  findLevel(level, options) {

	    options = extend$2({

	      box: 1,
	      edge: 'both',
	      direction: 'ascending',
	      rounding: 'before',
	      rangeP: [0, this.getLength()]

	    }, options);

	    if (options.rangeX) {
	      options.rangeP = options.rangeX.map(this.getIndexFromX);
	    }

	    var value, below, i, j, l, increment;

	    var box = options.box;

	    if (box % 2 == 0) {
	      box++;
	    }

	    if (options.direction == "descending") {
	      i = options.rangeP[1], l = options.rangeP[0], increment = -1;
	    } else {
	      i = options.rangeP[0], l = options.rangeP[1], increment = +1;
	    }

	    for (;; i += increment) {

	      if (options.direction == "descending") {
	        if (i < l) {
	          break;
	        }
	      } else {
	        if (i > l) {
	          break;
	        }
	      }

	      if (i < options.rangeP[0] + (box - 1) / 2) {
	        continue;
	      }

	      if (i > options.rangeP[1] - (box - 1) / 2) {
	        break;
	      }

	      value = this.getAverageP(i - (box - 1) / 2, i + (box - 1) / 2);

	      if (below === undefined) {
	        below = value < level;
	        continue;
	      }
	      // Crossing up
	      if (value >= level && below) {

	        below = false;

	        if (options.edge == 'ascending' || options.edge == 'both') {
	          // Found something

	          for (j = i + (box - 1) / 2; j >= i - (box - 1) / 2; j--) {

	            if (this.data[j] >= level && this.data[j - 1] <= level) {
	              // Find a crossing

	              switch (options.rounding) {
	                case 'before':
	                  return j - 1;
	                  break;

	                case 'after':
	                  return j;
	                  break;

	                case 'interpolate':
	                  return getIndexInterpolate(level, this.data[j], this.data[j - 1], j, j - 1);
	                  break;
	              }
	            }
	          }
	        }
	      } else if (value <= level && !below) {

	        below = true;

	        if (options.edge == 'descending' || options.edge == 'both') {

	          for (j = i + (box - 1) / 2; j >= i - (box - 1) / 2; j--) {

	            if (this.data[j] <= level && this.data[j - 1] >= level) {
	              // Find a crossing

	              switch (options.rounding) {
	                case 'before':
	                  return j - 1;
	                  break;

	                case 'after':
	                  return j;
	                  break;

	                case 'interpolate':
	                  return getIndexInterpolate(level, this.data[j], this.data[j - 1], j, j - 1);
	                  break;
	              }
	            }
	          }
	        }
	      }
	    }
	  }

	  normalize(mode) {

	    let factor, total, minValue, maxValue, ratio, i;

	    if (mode == 'max1' || mode == 'max100') {

	      factor = 1;

	      if (mode == 'max100') {
	        factor = 100;
	      }

	      maxValue = this.data[0];

	      for (i = 1; i < this.getLength(); i++) {

	        if (this.data[i] > maxValue) {

	          maxValue = this.data[i];
	        }
	      }

	      for (i = 0; i < this.getLength(); i++) {

	        this.data[i] /= maxValue / factor;
	      }
	    } else if (mode == 'sum1') {

	      total = 0;

	      for (i = 0; i < this.getLength(); i++) {
	        total += this.data[i];
	      }

	      for (i = 0; i < this.getLength(); i++) {

	        this.data[i] /= total;
	      }
	    } else if (mode == 'max1min0') {

	      maxValue = this.data[0], minValue = this.data[0];

	      for (i = 1; i < this.getLength(); i++) {
	        if (this.data[i] > maxValue) {

	          maxValue = this.data[i];
	        } else if (this.data[i] < minValue) {

	          minValue = this.data[i];
	        }
	      }

	      ratio = 1 / (maxValue - minValue);

	      for (i = 0; i < this.getLength(); i++) {

	        this.data[i] = (this.data[i] - minValue) * ratio;
	      }
	    }

	    this.setData(this.data);
	  }

	  ////////////////////////////////////////////////////////////
	  ///// HANDLING ERRORS   ////////////////////////////////////
	  ////////////////////////////////////////////////////////////

	  setErrorBarX(waveform) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }

	    var xWave = this.getXWaveform();
	    xWave.setErrorBar(waveform);
	    return this;
	  }

	  setErrorBarXBelow(waveform) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }

	    var xWave = this.getXWaveform();
	    xWave.setErrorBarBelow(waveform);
	    return this;
	  }

	  setErrorBarXAbove(waveform) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }

	    var xWave = this.getXWaveform();
	    xWave.setErrorBarAbove(waveform);
	    return this;
	  }

	  setErrorBoxX(waveform) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }

	    var xWave = this.getXWaveform();
	    xWave.setErrorBoxAbove(waveform);
	    xWave.setErrorBoxBelow(waveform);
	    return this;
	  }

	  setErrorBoxXBelow(waveform) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }

	    var xWave = this.getXWaveform();

	    xWave.setErrorBoxBelow(waveform);
	    return this;
	  }

	  setErrorBoxXAbove(waveform) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }

	    var xWave = this.getXWaveform();
	    xWave.setErrorBoxAbove(waveform);
	    return this;
	  }

	  setErrorBar(waveform, checkMinMax = true) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }
	    this.errors.nb++;
	    this.errors.nb++;
	    this.errors.bars.bottom = waveform;
	    this.errors.bars.top = waveform;

	    if (checkMinMax) {
	      this._setData();
	    }
	  }

	  setErrorBarBelow(waveform, checkMinMax = true) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }
	    this.errors.nb++;
	    this.errors.bars.below = waveform;

	    if (checkMinMax) {
	      this._setData();
	    }
	  }

	  setErrorBarAbove(waveform, checkMinMax = true) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }

	    this.errors.nb++;
	    this.errors.bars.above = waveform;

	    if (checkMinMax) {
	      this._setData();
	    }
	  }

	  setErrorBox(waveform, checkMinMax = true) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }
	    this.errors.nb++;
	    this.errors.nb++;
	    this.errors.boxes.above = waveform;
	    this.errors.boxes.below = waveform;

	    if (checkMinMax) {
	      this._setData();
	    }
	  }

	  setErrorBoxBelow(waveform, checkMinMax = true) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }
	    this.errors.nb++;
	    this.errors.boxes.below = waveform;

	    if (checkMinMax) {
	      this._setData();
	    }
	  }

	  setErrorBoxAbove(waveform, checkMinMax = true) {

	    if (Array.isArray(waveform)) {
	      waveform = new Waveform(waveform);
	    }

	    this.errors.boxes.above = waveform;
	    if (checkMinMax) {
	      this._setData();
	    }
	  }

	  getMaxError(i, side = Waveform.ABOVE) {

	    return Math.max(this.getMaxErrorType(i, side, Waveform.BOX), this.getMaxErrorType(i, side, Waveform.BAR));
	  }

	  getMaxErrorType(i, side = Waveform.ABOVE, type = Waveform.BOX) {

	    let stack;
	    if (type == Waveform.BOX) {
	      stack = this.errors.boxes;
	    } else if (type == Waveform.BAR) {
	      stack = this.errors.bars;
	    } else {
	      throw 'Unknown type of error';
	    }

	    let waveform;
	    if (!(waveform = stack[side])) {
	      if (side == Waveform.ABOVE) {
	        if (stack[side] == Waveform.BELOW) {
	          waveform = stack.below;
	        }
	      } else {
	        if (stack[side] == Waveform.ABOVE) {
	          waveform = stack.above;
	        }
	      }
	    }

	    if (!waveform) {
	      return 0;
	    }

	    return waveform.getY(i);
	  }

	  getErrorBarXBelow(index) {
	    return this.getErrorX(index, Waveform.BELOW, Waveform.BAR);
	  }
	  getErrorBarXAbove(index) {
	    return this.getErrorX(index, Waveform.ABOVE, Waveform.BAR);
	  }
	  getErrorBoxXBelow(index) {
	    return this.getErrorX(index, Waveform.BELOW, Waveform.BOX);
	  }
	  getErrorBoxXAbove(index) {
	    return this.getErrorX(index, Waveform.ABOVE, Waveform.BOX);
	  }

	  getErrorBarYBelow(index) {
	    return this.getError(index, Waveform.BELOW, Waveform.BAR);
	  }
	  getErrorBarYAbove(index) {
	    return this.getError(index, Waveform.ABOVE, Waveform.BAR);
	  }
	  getErrorBoxYBelow(index) {
	    return this.getError(index, Waveform.BELOW, Waveform.BOX);
	  }
	  getErrorBoxYAbove(index) {
	    return this.getError(index, Waveform.ABOVE, Waveform.BOX);
	  }

	  getErrorX(index, side = Waveform.ABOVE, type = Waveform.BAR) {

	    if (!this.hasXWaveform()) {
	      return false;
	    }

	    return this.xdata.getError(index, side, type);
	  }

	  getError(index, side = Waveform.ABOVE, type = Waveform.BAR) {

	    let errors = type == Waveform.BAR ? this.errors.bars : this.errors.boxes;

	    if (!errors) {
	      return false;
	    }

	    let wave;
	    if (wave = side == Waveform.ABOVE ? errors.above : errors.below) {

	      if (wave == Waveform.ABOVE && side == Waveform.BELOW) {
	        wave = errors.above;
	      } else if (wave == Waveform.BELOW && side == Waveform.ABOVE) {
	        wave = errors.below;
	      }

	      if (!wave) {
	        return false;
	      }

	      return wave.getY(index);
	    }
	  }

	  hasErrorBars() {

	    return this.errors.nb > 0 || this.hasXWaveform() && this.xdata.errors.nb > 0;
	  }

	}

	Waveform.BELOW = Symbol();
	Waveform.ABOVE = Symbol();

	Waveform.BOX = Symbol();
	Waveform.BAR = Symbol();

	const MULTIPLY = Symbol();
	const ADD = Symbol();
	const SUBTRACT = Symbol();
	const DIVIDE = Symbol();

	// http://stackoverflow.com/questions/26965171/fast-nearest-power-of-2-in-javascript
	function pow2ceil(v) {
	  v--;
	  var p = 2;
	  while (v >>= 1) {
	    p <<= 1;
	  }
	  return p;
	}

	function pow2floor(v) {

	  var p = 1;

	  while (v >>= 1) {
	    p <<= 1;
	  }
	  return p;
	}

	function getIndexInterpolate(value, valueBefore, valueAfter, indexBefore, indexAfter) {
	  return (value - valueBefore) / (valueAfter - valueBefore) * (indexAfter - indexBefore) + indexBefore;
	}

	function euclidianSearch(targetX, targetY, haystackX, haystackY, scaleX = 1, scaleY = 1) {

	  let distance = Number.MAX_VALUE,
	      distance_i;

	  let index = -1;

	  for (var i = 0, l = haystackX.length; i < l; i++) {

	    distance_i = Math.pow((targetX - haystackX[i]) * scaleX, 2) + Math.pow((targetY - haystackY[i]) * scaleY, 2);

	    if (distance_i < distance) {

	      index = i;
	      distance = distance_i;
	    }
	  }

	  return index;
	}

	function binarySearch(target, haystack, reverse = haystack[haystack.length - 1] < haystack[0]) {

	  let seedA = 0,
	      length = haystack.length,
	      seedB = length - 1,
	      seedInt,
	      i = 0,
	      nanDirection = 1;

	  if (!reverse && (haystack[0] > target || haystack[seedB] < target) || reverse && (haystack[0] < target || haystack[seedB] > target)) {
	    throw new Error(`Target ${target} is not in the stack`);
	  }

	  if (haystack[seedA] == target) {
	    return seedA;
	  }

	  if (haystack[seedB] == target) {
	    return seedB;
	  }

	  while (true) {
	    i++;
	    if (i > 100) {
	      throw new Error("Error loop");
	    }

	    seedInt = Math.floor((seedA + seedB) / 2);

	    //  seedInt -= seedInt % 2; // Always looks for an x.

	    while (isNaN(haystack[seedInt])) {

	      if (seedInt >= haystack.length - 1) {

	        return haystack.length - 1;
	      } else if (seedInt <= 0) {

	        return 0;
	      }

	      seedInt += nanDirection;
	    }

	    if (seedInt == seedA || haystack[seedInt] == target || seedInt == seedB) {
	      return seedInt;
	    }

	    //    console.log(seedA, seedB, seedInt, haystack[seedInt]);
	    if (haystack[seedInt] < target) {
	      if (reverse) {
	        seedB = seedInt;
	      } else {
	        seedA = seedInt;
	      }
	    } else if (haystack[seedInt] > target) {
	      if (reverse) {
	        seedA = seedInt;
	      } else {
	        seedB = seedInt;
	      }
	    } else {
	      return false;
	    }

	    nanDirection *= -1;
	  }
	}

	var waveform = Waveform;

	var store = createStore(app, applyMiddleware(logger));

	reactDom.render(react.createElement(
		Provider,
		{ store: store },
		react.createElement(
			'div',
			{ className: 'container-fluid' },
			react.createElement(ChanControlWrapper, { channels: store.channels, buttonView: true }),
			react.createElement(
				'div',
				{ className: 'col-sm-3' },
				react.createElement(QueueWrapper, null)
			),
			react.createElement(
				'div',
				{ className: 'col-sm-9' },
				react.createElement(
					'ul',
					{ className: 'nav nav-tabs', role: 'tablist' },
					react.createElement(
						'li',
						{ role: 'presentation', className: 'active' },
						react.createElement(
							'a',
							{ href: '#configuration', 'aria-controls': 'home', role: 'tab', 'data-toggle': 'tab' },
							'Configuration'
						)
					),
					react.createElement(
						'li',
						{ role: 'presentation' },
						react.createElement(
							'a',
							{ href: '#dataview', 'aria-controls': 'profile', role: 'tab', 'data-toggle': 'tab' },
							'Output data'
						)
					)
				),
				react.createElement(
					'div',
					{ className: 'tab-content' },
					react.createElement(
						'div',
						{ role: 'tabpanel', className: 'tab-pane active', id: 'configuration' },
						react.createElement(QueueConfigElement$1, null)
					),
					react.createElement(
						'div',
						{ role: 'tabpanel', className: 'tab-pane', id: 'dataview' },
						react.createElement(ViewData, null)
					)
				)
			)
		)
	), document.getElementById('root'));

	store.dispatch(dataReceived(0, { chanId: 1, jvId: 1, jv: new JV().setData([-0.00304091, -0.00298028, -0.00280809, -0.00254911, -0.00223318, -0.00188613, -0.00152594, -0.00116367, -0.000806279, -0.000458696, -0.000124681, 0.000192992, 0.000492411, 0.000772319, 0.001032, 0.00127123, 0.00149017, 0.00168908, 0.00186816, 0.00202758, 0.00216768, 0.00228895, 0.00239205, 0.00247804, 0.00254855, 0.00260563, 0.00265132, 0.00268747, 0.00271596, 0.00273863, 0.00275695, 0.00277185, 0.00278398, 0.00279393, 0.00280193, 0.00280743, 0.00280943], [0.999147, 0.975932, 0.947839, 0.92093, 0.892886, 0.864744, 0.83788, 0.809797, 0.781681, 0.753626, 0.726713, 0.698655, 0.670511, 0.643653, 0.615607, 0.587467, 0.559408, 0.532481, 0.504412, 0.476292, 0.449472, 0.421451, 0.393358, 0.366574, 0.338499, 0.310498, 0.282431, 0.255548, 0.227497, 0.199381, 0.172546, 0.144491, 0.116473, 0.089661, 0.061567, 0.033572, 0.005493]) }));

	store.dispatch(dataReceived(1, { chanId: 1, mpp: new waveform().setData([-0.00304091, -0.00298028, -0.00280809, -0.00254911, -0.00223318, -0.00188613, -0.00152594, -0.00116367, -0.000806279, -0.000458696, -0.000124681, 0.000192992, 0.000492411, 0.000772319, 0.001032, 0.00127123, 0.00149017, 0.00168908, 0.00186816, 0.00202758, 0.00216768, 0.00228895, 0.00239205, 0.00247804, 0.00254855, 0.00260563, 0.00265132, 0.00268747, 0.00271596, 0.00273863, 0.00275695, 0.00277185, 0.00278398, 0.00279393, 0.00280193, 0.00280743, 0.00280943], [0.999147, 0.975932, 0.947839, 0.92093, 0.892886, 0.864744, 0.83788, 0.809797, 0.781681, 0.753626, 0.726713, 0.698655, 0.670511, 0.643653, 0.615607, 0.587467, 0.559408, 0.532481, 0.504412, 0.476292, 0.449472, 0.421451, 0.393358, 0.366574, 0.338499, 0.310498, 0.282431, 0.255548, 0.227497, 0.199381, 0.172546, 0.144491, 0.116473, 0.089661, 0.061567, 0.033572, 0.005493]) }));

}(electron));
